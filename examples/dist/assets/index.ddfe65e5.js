var yQ=Object.defineProperty;var DQ=(i,A,t)=>A in i?yQ(i,A,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[A]=t;var UA=(i,A,t)=>(DQ(i,typeof A!="symbol"?A+"":A,t),t);(function(){const A=document.createElement("link").relList;if(A&&A.supports&&A.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))e(n);new MutationObserver(n=>{for(const a of n)if(a.type==="childList")for(const o of a.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&e(o)}).observe(document,{childList:!0,subtree:!0});function t(n){const a={};return n.integrity&&(a.integrity=n.integrity),n.referrerpolicy&&(a.referrerPolicy=n.referrerpolicy),n.crossorigin==="use-credentials"?a.credentials="include":n.crossorigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function e(n){if(n.ep)return;n.ep=!0;const a=t(n);fetch(n.href,a)}})();/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Cl="145",na={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},aa={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},SQ=0,Jl=1,wQ=2,vc=1,_Q=2,Rs=3,Za=0,ve=1,Xi=2,en=0,Ya=1,Pl=2,Yl=3,Kl=4,xQ=5,Ua=100,MQ=101,FQ=102,Ol=103,Wl=104,RQ=200,vQ=201,GQ=202,NQ=203,Gc=204,Nc=205,LQ=206,bQ=207,UQ=208,kQ=209,TQ=210,HQ=0,qQ=1,JQ=2,MI=3,PQ=4,YQ=5,KQ=6,OQ=7,Bl=0,WQ=1,VQ=2,Gi=0,zQ=1,XQ=2,ZQ=3,jQ=4,$Q=5,Lc=300,ja=301,$a=302,FI=303,RI=304,br=306,Ks=1e3,se=1001,Tn=1002,Ae=1003,Vl=1004,zl=1005,Wt=1006,Ad=1007,ao=1008,Hn=1009,td=1010,ed=1011,bc=1012,id=1013,Mn=1014,ni=1015,Ri=1016,nd=1017,ad=1018,Ka=1020,sd=1021,od=1022,ai=1023,rd=1024,gd=1025,Ln=1026,As=1027,Id=1028,ld=1029,Cd=1030,Bd=1031,hd=1033,Wr=33776,Vr=33777,zr=33778,Xr=33779,Xl=35840,Zl=35841,jl=35842,$l=35843,cd=36196,AC=37492,tC=37496,eC=37808,iC=37809,nC=37810,aC=37811,sC=37812,oC=37813,rC=37814,gC=37815,IC=37816,lC=37817,CC=37818,BC=37819,hC=37820,cC=37821,EC=36492,gn=3e3,ut=3001,Ed=3200,Qd=3201,hl=0,dd=1,Di="srgb",Fn="srgb-linear",Zr=7680,fd=519,QC=35044,dC="300 es",vI=1035;class $n{addEventListener(A,t){this._listeners===void 0&&(this._listeners={});const e=this._listeners;e[A]===void 0&&(e[A]=[]),e[A].indexOf(t)===-1&&e[A].push(t)}hasEventListener(A,t){if(this._listeners===void 0)return!1;const e=this._listeners;return e[A]!==void 0&&e[A].indexOf(t)!==-1}removeEventListener(A,t){if(this._listeners===void 0)return;const n=this._listeners[A];if(n!==void 0){const a=n.indexOf(t);a!==-1&&n.splice(a,1)}}dispatchEvent(A){if(this._listeners===void 0)return;const e=this._listeners[A.type];if(e!==void 0){A.target=this;const n=e.slice(0);for(let a=0,o=n.length;a<o;a++)n[a].call(this,A);A.target=null}}}const Xt=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],jr=Math.PI/180,GI=180/Math.PI;function so(){const i=Math.random()*4294967295|0,A=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0;return(Xt[i&255]+Xt[i>>8&255]+Xt[i>>16&255]+Xt[i>>24&255]+"-"+Xt[A&255]+Xt[A>>8&255]+"-"+Xt[A>>16&15|64]+Xt[A>>24&255]+"-"+Xt[t&63|128]+Xt[t>>8&255]+"-"+Xt[t>>16&255]+Xt[t>>24&255]+Xt[e&255]+Xt[e>>8&255]+Xt[e>>16&255]+Xt[e>>24&255]).toLowerCase()}function ae(i,A,t){return Math.max(A,Math.min(t,i))}function ud(i,A){return(i%A+A)%A}function $r(i,A,t){return(1-t)*i+t*A}function fC(i){return(i&i-1)===0&&i!==0}function NI(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))}function Qo(i,A){switch(A.constructor){case Float32Array:return i;case Uint16Array:return i/65535;case Uint8Array:return i/255;case Int16Array:return Math.max(i/32767,-1);case Int8Array:return Math.max(i/127,-1);default:throw new Error("Invalid component type.")}}function Qe(i,A){switch(A.constructor){case Float32Array:return i;case Uint16Array:return Math.round(i*65535);case Uint8Array:return Math.round(i*255);case Int16Array:return Math.round(i*32767);case Int8Array:return Math.round(i*127);default:throw new Error("Invalid component type.")}}class XA{constructor(A=0,t=0){XA.prototype.isVector2=!0,this.x=A,this.y=t}get width(){return this.x}set width(A){this.x=A}get height(){return this.y}set height(A){this.y=A}set(A,t){return this.x=A,this.y=t,this}setScalar(A){return this.x=A,this.y=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setComponent(A,t){switch(A){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y)}copy(A){return this.x=A.x,this.y=A.y,this}add(A){return this.x+=A.x,this.y+=A.y,this}addScalar(A){return this.x+=A,this.y+=A,this}addVectors(A,t){return this.x=A.x+t.x,this.y=A.y+t.y,this}addScaledVector(A,t){return this.x+=A.x*t,this.y+=A.y*t,this}sub(A){return this.x-=A.x,this.y-=A.y,this}subScalar(A){return this.x-=A,this.y-=A,this}subVectors(A,t){return this.x=A.x-t.x,this.y=A.y-t.y,this}multiply(A){return this.x*=A.x,this.y*=A.y,this}multiplyScalar(A){return this.x*=A,this.y*=A,this}divide(A){return this.x/=A.x,this.y/=A.y,this}divideScalar(A){return this.multiplyScalar(1/A)}applyMatrix3(A){const t=this.x,e=this.y,n=A.elements;return this.x=n[0]*t+n[3]*e+n[6],this.y=n[1]*t+n[4]*e+n[7],this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this}clamp(A,t){return this.x=Math.max(A.x,Math.min(t.x,this.x)),this.y=Math.max(A.y,Math.min(t.y,this.y)),this}clampScalar(A,t){return this.x=Math.max(A,Math.min(t,this.x)),this.y=Math.max(A,Math.min(t,this.y)),this}clampLength(A,t){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(A,Math.min(t,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(A){return this.x*A.x+this.y*A.y}cross(A){return this.x*A.y-this.y*A.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const t=this.x-A.x,e=this.y-A.y;return t*t+e*e}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,t){return this.x+=(A.x-this.x)*t,this.y+=(A.y-this.y)*t,this}lerpVectors(A,t,e){return this.x=A.x+(t.x-A.x)*e,this.y=A.y+(t.y-A.y)*e,this}equals(A){return A.x===this.x&&A.y===this.y}fromArray(A,t=0){return this.x=A[t],this.y=A[t+1],this}toArray(A=[],t=0){return A[t]=this.x,A[t+1]=this.y,A}fromBufferAttribute(A,t){return this.x=A.getX(t),this.y=A.getY(t),this}rotateAround(A,t){const e=Math.cos(t),n=Math.sin(t),a=this.x-A.x,o=this.y-A.y;return this.x=a*e-o*n+A.x,this.y=a*n+o*e+A.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Re{constructor(){Re.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(A,t,e,n,a,o,s,I,r){const g=this.elements;return g[0]=A,g[1]=n,g[2]=s,g[3]=t,g[4]=a,g[5]=I,g[6]=e,g[7]=o,g[8]=r,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(A){const t=this.elements,e=A.elements;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],this}extractBasis(A,t,e){return A.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),e.setFromMatrix3Column(this,2),this}setFromMatrix4(A){const t=A.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,t){const e=A.elements,n=t.elements,a=this.elements,o=e[0],s=e[3],I=e[6],r=e[1],g=e[4],C=e[7],B=e[2],c=e[5],Q=e[8],h=n[0],l=n[3],E=n[6],f=n[1],u=n[4],d=n[7],m=n[2],S=n[5],D=n[8];return a[0]=o*h+s*f+I*m,a[3]=o*l+s*u+I*S,a[6]=o*E+s*d+I*D,a[1]=r*h+g*f+C*m,a[4]=r*l+g*u+C*S,a[7]=r*E+g*d+C*D,a[2]=B*h+c*f+Q*m,a[5]=B*l+c*u+Q*S,a[8]=B*E+c*d+Q*D,this}multiplyScalar(A){const t=this.elements;return t[0]*=A,t[3]*=A,t[6]*=A,t[1]*=A,t[4]*=A,t[7]*=A,t[2]*=A,t[5]*=A,t[8]*=A,this}determinant(){const A=this.elements,t=A[0],e=A[1],n=A[2],a=A[3],o=A[4],s=A[5],I=A[6],r=A[7],g=A[8];return t*o*g-t*s*r-e*a*g+e*s*I+n*a*r-n*o*I}invert(){const A=this.elements,t=A[0],e=A[1],n=A[2],a=A[3],o=A[4],s=A[5],I=A[6],r=A[7],g=A[8],C=g*o-s*r,B=s*I-g*a,c=r*a-o*I,Q=t*C+e*B+n*c;if(Q===0)return this.set(0,0,0,0,0,0,0,0,0);const h=1/Q;return A[0]=C*h,A[1]=(n*r-g*e)*h,A[2]=(s*e-n*o)*h,A[3]=B*h,A[4]=(g*t-n*I)*h,A[5]=(n*a-s*t)*h,A[6]=c*h,A[7]=(e*I-r*t)*h,A[8]=(o*t-e*a)*h,this}transpose(){let A;const t=this.elements;return A=t[1],t[1]=t[3],t[3]=A,A=t[2],t[2]=t[6],t[6]=A,A=t[5],t[5]=t[7],t[7]=A,this}getNormalMatrix(A){return this.setFromMatrix4(A).invert().transpose()}transposeIntoArray(A){const t=this.elements;return A[0]=t[0],A[1]=t[3],A[2]=t[6],A[3]=t[1],A[4]=t[4],A[5]=t[7],A[6]=t[2],A[7]=t[5],A[8]=t[8],this}setUvTransform(A,t,e,n,a,o,s){const I=Math.cos(a),r=Math.sin(a);return this.set(e*I,e*r,-e*(I*o+r*s)+o+A,-n*r,n*I,-n*(-r*o+I*s)+s+t,0,0,1),this}scale(A,t){const e=this.elements;return e[0]*=A,e[3]*=A,e[6]*=A,e[1]*=t,e[4]*=t,e[7]*=t,this}rotate(A){const t=Math.cos(A),e=Math.sin(A),n=this.elements,a=n[0],o=n[3],s=n[6],I=n[1],r=n[4],g=n[7];return n[0]=t*a+e*I,n[3]=t*o+e*r,n[6]=t*s+e*g,n[1]=-e*a+t*I,n[4]=-e*o+t*r,n[7]=-e*s+t*g,this}translate(A,t){const e=this.elements;return e[0]+=A*e[2],e[3]+=A*e[5],e[6]+=A*e[8],e[1]+=t*e[2],e[4]+=t*e[5],e[7]+=t*e[8],this}equals(A){const t=this.elements,e=A.elements;for(let n=0;n<9;n++)if(t[n]!==e[n])return!1;return!0}fromArray(A,t=0){for(let e=0;e<9;e++)this.elements[e]=A[e+t];return this}toArray(A=[],t=0){const e=this.elements;return A[t]=e[0],A[t+1]=e[1],A[t+2]=e[2],A[t+3]=e[3],A[t+4]=e[4],A[t+5]=e[5],A[t+6]=e[6],A[t+7]=e[7],A[t+8]=e[8],A}clone(){return new this.constructor().fromArray(this.elements)}}function Uc(i){for(let A=i.length-1;A>=0;--A)if(i[A]>=65535)return!0;return!1}function Os(i){return document.createElementNS("http://www.w3.org/1999/xhtml",i)}function bn(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function Br(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}const Ag={[Di]:{[Fn]:bn},[Fn]:{[Di]:Br}},be={legacyMode:!0,get workingColorSpace(){return Fn},set workingColorSpace(i){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(i,A,t){if(this.legacyMode||A===t||!A||!t)return i;if(Ag[A]&&Ag[A][t]!==void 0){const e=Ag[A][t];return i.r=e(i.r),i.g=e(i.g),i.b=e(i.b),i}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(i,A){return this.convert(i,this.workingColorSpace,A)},toWorkingColorSpace:function(i,A){return this.convert(i,A,this.workingColorSpace)}},kc={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ft={r:0,g:0,b:0},Ue={h:0,s:0,l:0},fo={h:0,s:0,l:0};function tg(i,A,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?i+(A-i)*6*t:t<1/2?A:t<2/3?i+(A-i)*6*(2/3-t):i}function uo(i,A){return A.r=i.r,A.g=i.g,A.b=i.b,A}class st{constructor(A,t,e){return this.isColor=!0,this.r=1,this.g=1,this.b=1,t===void 0&&e===void 0?this.set(A):this.setRGB(A,t,e)}set(A){return A&&A.isColor?this.copy(A):typeof A=="number"?this.setHex(A):typeof A=="string"&&this.setStyle(A),this}setScalar(A){return this.r=A,this.g=A,this.b=A,this}setHex(A,t=Di){return A=Math.floor(A),this.r=(A>>16&255)/255,this.g=(A>>8&255)/255,this.b=(A&255)/255,be.toWorkingColorSpace(this,t),this}setRGB(A,t,e,n=Fn){return this.r=A,this.g=t,this.b=e,be.toWorkingColorSpace(this,n),this}setHSL(A,t,e,n=Fn){if(A=ud(A,1),t=ae(t,0,1),e=ae(e,0,1),t===0)this.r=this.g=this.b=e;else{const a=e<=.5?e*(1+t):e+t-e*t,o=2*e-a;this.r=tg(o,a,A+1/3),this.g=tg(o,a,A),this.b=tg(o,a,A-1/3)}return be.toWorkingColorSpace(this,n),this}setStyle(A,t=Di){function e(a){a!==void 0&&parseFloat(a)<1&&console.warn("THREE.Color: Alpha component of "+A+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(A)){let a;const o=n[1],s=n[2];switch(o){case"rgb":case"rgba":if(a=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(255,parseInt(a[1],10))/255,this.g=Math.min(255,parseInt(a[2],10))/255,this.b=Math.min(255,parseInt(a[3],10))/255,be.toWorkingColorSpace(this,t),e(a[4]),this;if(a=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(100,parseInt(a[1],10))/100,this.g=Math.min(100,parseInt(a[2],10))/100,this.b=Math.min(100,parseInt(a[3],10))/100,be.toWorkingColorSpace(this,t),e(a[4]),this;break;case"hsl":case"hsla":if(a=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)){const I=parseFloat(a[1])/360,r=parseFloat(a[2])/100,g=parseFloat(a[3])/100;return e(a[4]),this.setHSL(I,r,g,t)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(A)){const a=n[1],o=a.length;if(o===3)return this.r=parseInt(a.charAt(0)+a.charAt(0),16)/255,this.g=parseInt(a.charAt(1)+a.charAt(1),16)/255,this.b=parseInt(a.charAt(2)+a.charAt(2),16)/255,be.toWorkingColorSpace(this,t),this;if(o===6)return this.r=parseInt(a.charAt(0)+a.charAt(1),16)/255,this.g=parseInt(a.charAt(2)+a.charAt(3),16)/255,this.b=parseInt(a.charAt(4)+a.charAt(5),16)/255,be.toWorkingColorSpace(this,t),this}return A&&A.length>0?this.setColorName(A,t):this}setColorName(A,t=Di){const e=kc[A.toLowerCase()];return e!==void 0?this.setHex(e,t):console.warn("THREE.Color: Unknown color "+A),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(A){return this.r=A.r,this.g=A.g,this.b=A.b,this}copySRGBToLinear(A){return this.r=bn(A.r),this.g=bn(A.g),this.b=bn(A.b),this}copyLinearToSRGB(A){return this.r=Br(A.r),this.g=Br(A.g),this.b=Br(A.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(A=Di){return be.fromWorkingColorSpace(uo(this,Ft),A),ae(Ft.r*255,0,255)<<16^ae(Ft.g*255,0,255)<<8^ae(Ft.b*255,0,255)<<0}getHexString(A=Di){return("000000"+this.getHex(A).toString(16)).slice(-6)}getHSL(A,t=Fn){be.fromWorkingColorSpace(uo(this,Ft),t);const e=Ft.r,n=Ft.g,a=Ft.b,o=Math.max(e,n,a),s=Math.min(e,n,a);let I,r;const g=(s+o)/2;if(s===o)I=0,r=0;else{const C=o-s;switch(r=g<=.5?C/(o+s):C/(2-o-s),o){case e:I=(n-a)/C+(n<a?6:0);break;case n:I=(a-e)/C+2;break;case a:I=(e-n)/C+4;break}I/=6}return A.h=I,A.s=r,A.l=g,A}getRGB(A,t=Fn){return be.fromWorkingColorSpace(uo(this,Ft),t),A.r=Ft.r,A.g=Ft.g,A.b=Ft.b,A}getStyle(A=Di){return be.fromWorkingColorSpace(uo(this,Ft),A),A!==Di?`color(${A} ${Ft.r} ${Ft.g} ${Ft.b})`:`rgb(${Ft.r*255|0},${Ft.g*255|0},${Ft.b*255|0})`}offsetHSL(A,t,e){return this.getHSL(Ue),Ue.h+=A,Ue.s+=t,Ue.l+=e,this.setHSL(Ue.h,Ue.s,Ue.l),this}add(A){return this.r+=A.r,this.g+=A.g,this.b+=A.b,this}addColors(A,t){return this.r=A.r+t.r,this.g=A.g+t.g,this.b=A.b+t.b,this}addScalar(A){return this.r+=A,this.g+=A,this.b+=A,this}sub(A){return this.r=Math.max(0,this.r-A.r),this.g=Math.max(0,this.g-A.g),this.b=Math.max(0,this.b-A.b),this}multiply(A){return this.r*=A.r,this.g*=A.g,this.b*=A.b,this}multiplyScalar(A){return this.r*=A,this.g*=A,this.b*=A,this}lerp(A,t){return this.r+=(A.r-this.r)*t,this.g+=(A.g-this.g)*t,this.b+=(A.b-this.b)*t,this}lerpColors(A,t,e){return this.r=A.r+(t.r-A.r)*e,this.g=A.g+(t.g-A.g)*e,this.b=A.b+(t.b-A.b)*e,this}lerpHSL(A,t){this.getHSL(Ue),A.getHSL(fo);const e=$r(Ue.h,fo.h,t),n=$r(Ue.s,fo.s,t),a=$r(Ue.l,fo.l,t);return this.setHSL(e,n,a),this}equals(A){return A.r===this.r&&A.g===this.g&&A.b===this.b}fromArray(A,t=0){return this.r=A[t],this.g=A[t+1],this.b=A[t+2],this}toArray(A=[],t=0){return A[t]=this.r,A[t+1]=this.g,A[t+2]=this.b,A}fromBufferAttribute(A,t){return this.r=A.getX(t),this.g=A.getY(t),this.b=A.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}st.NAMES=kc;let sa;class Tc{static getDataURL(A){if(/^data:/i.test(A.src)||typeof HTMLCanvasElement>"u")return A.src;let t;if(A instanceof HTMLCanvasElement)t=A;else{sa===void 0&&(sa=Os("canvas")),sa.width=A.width,sa.height=A.height;const e=sa.getContext("2d");A instanceof ImageData?e.putImageData(A,0,0):e.drawImage(A,0,0,A.width,A.height),t=sa}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",A),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(A){if(typeof HTMLImageElement<"u"&&A instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&A instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&A instanceof ImageBitmap){const t=Os("canvas");t.width=A.width,t.height=A.height;const e=t.getContext("2d");e.drawImage(A,0,0,A.width,A.height);const n=e.getImageData(0,0,A.width,A.height),a=n.data;for(let o=0;o<a.length;o++)a[o]=bn(a[o]/255)*255;return e.putImageData(n,0,0),t}else if(A.data){const t=A.data.slice(0);for(let e=0;e<t.length;e++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[e]=Math.floor(bn(t[e]/255)*255):t[e]=bn(t[e]);return{data:t,width:A.width,height:A.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),A}}class Hc{constructor(A=null){this.isSource=!0,this.uuid=so(),this.data=A,this.version=0}set needsUpdate(A){A===!0&&this.version++}toJSON(A){const t=A===void 0||typeof A=="string";if(!t&&A.images[this.uuid]!==void 0)return A.images[this.uuid];const e={uuid:this.uuid,url:""},n=this.data;if(n!==null){let a;if(Array.isArray(n)){a=[];for(let o=0,s=n.length;o<s;o++)n[o].isDataTexture?a.push(eg(n[o].image)):a.push(eg(n[o]))}else a=eg(n);e.url=a}return t||(A.images[this.uuid]=e),e}}function eg(i){return typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&i instanceof ImageBitmap?Tc.getDataURL(i):i.data?{data:Array.from(i.data),width:i.width,height:i.height,type:i.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let pd=0;class we extends $n{constructor(A=we.DEFAULT_IMAGE,t=we.DEFAULT_MAPPING,e=se,n=se,a=Wt,o=ao,s=ai,I=Hn,r=1,g=gn){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:pd++}),this.uuid=so(),this.name="",this.source=new Hc(A),this.mipmaps=[],this.mapping=t,this.wrapS=e,this.wrapT=n,this.magFilter=a,this.minFilter=o,this.anisotropy=r,this.format=s,this.internalFormat=null,this.type=I,this.offset=new XA(0,0),this.repeat=new XA(1,1),this.center=new XA(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Re,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=g,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(A){this.source.data=A}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(A){return this.name=A.name,this.source=A.source,this.mipmaps=A.mipmaps.slice(0),this.mapping=A.mapping,this.wrapS=A.wrapS,this.wrapT=A.wrapT,this.magFilter=A.magFilter,this.minFilter=A.minFilter,this.anisotropy=A.anisotropy,this.format=A.format,this.internalFormat=A.internalFormat,this.type=A.type,this.offset.copy(A.offset),this.repeat.copy(A.repeat),this.center.copy(A.center),this.rotation=A.rotation,this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrix.copy(A.matrix),this.generateMipmaps=A.generateMipmaps,this.premultiplyAlpha=A.premultiplyAlpha,this.flipY=A.flipY,this.unpackAlignment=A.unpackAlignment,this.encoding=A.encoding,this.userData=JSON.parse(JSON.stringify(A.userData)),this.needsUpdate=!0,this}toJSON(A){const t=A===void 0||typeof A=="string";if(!t&&A.textures[this.uuid]!==void 0)return A.textures[this.uuid];const e={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(A).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(e.userData=this.userData),t||(A.textures[this.uuid]=e),e}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(A){if(this.mapping!==Lc)return A;if(A.applyMatrix3(this.matrix),A.x<0||A.x>1)switch(this.wrapS){case Ks:A.x=A.x-Math.floor(A.x);break;case se:A.x=A.x<0?0:1;break;case Tn:Math.abs(Math.floor(A.x)%2)===1?A.x=Math.ceil(A.x)-A.x:A.x=A.x-Math.floor(A.x);break}if(A.y<0||A.y>1)switch(this.wrapT){case Ks:A.y=A.y-Math.floor(A.y);break;case se:A.y=A.y<0?0:1;break;case Tn:Math.abs(Math.floor(A.y)%2)===1?A.y=Math.ceil(A.y)-A.y:A.y=A.y-Math.floor(A.y);break}return this.flipY&&(A.y=1-A.y),A}set needsUpdate(A){A===!0&&(this.version++,this.source.needsUpdate=!0)}}we.DEFAULT_IMAGE=null;we.DEFAULT_MAPPING=Lc;class dt{constructor(A=0,t=0,e=0,n=1){dt.prototype.isVector4=!0,this.x=A,this.y=t,this.z=e,this.w=n}get width(){return this.z}set width(A){this.z=A}get height(){return this.w}set height(A){this.w=A}set(A,t,e,n){return this.x=A,this.y=t,this.z=e,this.w=n,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this.w=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setW(A){return this.w=A,this}setComponent(A,t){switch(A){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this.w=A.w!==void 0?A.w:1,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this.w+=A.w,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this.w+=A,this}addVectors(A,t){return this.x=A.x+t.x,this.y=A.y+t.y,this.z=A.z+t.z,this.w=A.w+t.w,this}addScaledVector(A,t){return this.x+=A.x*t,this.y+=A.y*t,this.z+=A.z*t,this.w+=A.w*t,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this.w-=A.w,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this.w-=A,this}subVectors(A,t){return this.x=A.x-t.x,this.y=A.y-t.y,this.z=A.z-t.z,this.w=A.w-t.w,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this.w*=A.w,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this.w*=A,this}applyMatrix4(A){const t=this.x,e=this.y,n=this.z,a=this.w,o=A.elements;return this.x=o[0]*t+o[4]*e+o[8]*n+o[12]*a,this.y=o[1]*t+o[5]*e+o[9]*n+o[13]*a,this.z=o[2]*t+o[6]*e+o[10]*n+o[14]*a,this.w=o[3]*t+o[7]*e+o[11]*n+o[15]*a,this}divideScalar(A){return this.multiplyScalar(1/A)}setAxisAngleFromQuaternion(A){this.w=2*Math.acos(A.w);const t=Math.sqrt(1-A.w*A.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=A.x/t,this.y=A.y/t,this.z=A.z/t),this}setAxisAngleFromRotationMatrix(A){let t,e,n,a;const I=A.elements,r=I[0],g=I[4],C=I[8],B=I[1],c=I[5],Q=I[9],h=I[2],l=I[6],E=I[10];if(Math.abs(g-B)<.01&&Math.abs(C-h)<.01&&Math.abs(Q-l)<.01){if(Math.abs(g+B)<.1&&Math.abs(C+h)<.1&&Math.abs(Q+l)<.1&&Math.abs(r+c+E-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const u=(r+1)/2,d=(c+1)/2,m=(E+1)/2,S=(g+B)/4,D=(C+h)/4,p=(Q+l)/4;return u>d&&u>m?u<.01?(e=0,n=.707106781,a=.707106781):(e=Math.sqrt(u),n=S/e,a=D/e):d>m?d<.01?(e=.707106781,n=0,a=.707106781):(n=Math.sqrt(d),e=S/n,a=p/n):m<.01?(e=.707106781,n=.707106781,a=0):(a=Math.sqrt(m),e=D/a,n=p/a),this.set(e,n,a,t),this}let f=Math.sqrt((l-Q)*(l-Q)+(C-h)*(C-h)+(B-g)*(B-g));return Math.abs(f)<.001&&(f=1),this.x=(l-Q)/f,this.y=(C-h)/f,this.z=(B-g)/f,this.w=Math.acos((r+c+E-1)/2),this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this.w=Math.min(this.w,A.w),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this.w=Math.max(this.w,A.w),this}clamp(A,t){return this.x=Math.max(A.x,Math.min(t.x,this.x)),this.y=Math.max(A.y,Math.min(t.y,this.y)),this.z=Math.max(A.z,Math.min(t.z,this.z)),this.w=Math.max(A.w,Math.min(t.w,this.w)),this}clampScalar(A,t){return this.x=Math.max(A,Math.min(t,this.x)),this.y=Math.max(A,Math.min(t,this.y)),this.z=Math.max(A,Math.min(t,this.z)),this.w=Math.max(A,Math.min(t,this.w)),this}clampLength(A,t){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(A,Math.min(t,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z+this.w*A.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,t){return this.x+=(A.x-this.x)*t,this.y+=(A.y-this.y)*t,this.z+=(A.z-this.z)*t,this.w+=(A.w-this.w)*t,this}lerpVectors(A,t,e){return this.x=A.x+(t.x-A.x)*e,this.y=A.y+(t.y-A.y)*e,this.z=A.z+(t.z-A.z)*e,this.w=A.w+(t.w-A.w)*e,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z&&A.w===this.w}fromArray(A,t=0){return this.x=A[t],this.y=A[t+1],this.z=A[t+2],this.w=A[t+3],this}toArray(A=[],t=0){return A[t]=this.x,A[t+1]=this.y,A[t+2]=this.z,A[t+3]=this.w,A}fromBufferAttribute(A,t){return this.x=A.getX(t),this.y=A.getY(t),this.z=A.getZ(t),this.w=A.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class qn extends $n{constructor(A,t,e={}){super(),this.isWebGLRenderTarget=!0,this.width=A,this.height=t,this.depth=1,this.scissor=new dt(0,0,A,t),this.scissorTest=!1,this.viewport=new dt(0,0,A,t);const n={width:A,height:t,depth:1};this.texture=new we(n,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.internalFormat=e.internalFormat!==void 0?e.internalFormat:null,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:Wt,this.depthBuffer=e.depthBuffer!==void 0?e.depthBuffer:!0,this.stencilBuffer=e.stencilBuffer!==void 0?e.stencilBuffer:!1,this.depthTexture=e.depthTexture!==void 0?e.depthTexture:null,this.samples=e.samples!==void 0?e.samples:0}setSize(A,t,e=1){(this.width!==A||this.height!==t||this.depth!==e)&&(this.width=A,this.height=t,this.depth=e,this.texture.image.width=A,this.texture.image.height=t,this.texture.image.depth=e,this.dispose()),this.viewport.set(0,0,A,t),this.scissor.set(0,0,A,t)}clone(){return new this.constructor().copy(this)}copy(A){this.width=A.width,this.height=A.height,this.depth=A.depth,this.viewport.copy(A.viewport),this.texture=A.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},A.texture.image);return this.texture.source=new Hc(t),this.depthBuffer=A.depthBuffer,this.stencilBuffer=A.stencilBuffer,A.depthTexture!==null&&(this.depthTexture=A.depthTexture.clone()),this.samples=A.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class qc extends we{constructor(A=null,t=1,e=1,n=1){super(null),this.isDataArrayTexture=!0,this.image={data:A,width:t,height:e,depth:n},this.magFilter=Ae,this.minFilter=Ae,this.wrapR=se,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class md extends we{constructor(A=null,t=1,e=1,n=1){super(null),this.isData3DTexture=!0,this.image={data:A,width:t,height:e,depth:n},this.magFilter=Ae,this.minFilter=Ae,this.wrapR=se,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Jn{constructor(A=0,t=0,e=0,n=1){this.isQuaternion=!0,this._x=A,this._y=t,this._z=e,this._w=n}static slerpFlat(A,t,e,n,a,o,s){let I=e[n+0],r=e[n+1],g=e[n+2],C=e[n+3];const B=a[o+0],c=a[o+1],Q=a[o+2],h=a[o+3];if(s===0){A[t+0]=I,A[t+1]=r,A[t+2]=g,A[t+3]=C;return}if(s===1){A[t+0]=B,A[t+1]=c,A[t+2]=Q,A[t+3]=h;return}if(C!==h||I!==B||r!==c||g!==Q){let l=1-s;const E=I*B+r*c+g*Q+C*h,f=E>=0?1:-1,u=1-E*E;if(u>Number.EPSILON){const m=Math.sqrt(u),S=Math.atan2(m,E*f);l=Math.sin(l*S)/m,s=Math.sin(s*S)/m}const d=s*f;if(I=I*l+B*d,r=r*l+c*d,g=g*l+Q*d,C=C*l+h*d,l===1-s){const m=1/Math.sqrt(I*I+r*r+g*g+C*C);I*=m,r*=m,g*=m,C*=m}}A[t]=I,A[t+1]=r,A[t+2]=g,A[t+3]=C}static multiplyQuaternionsFlat(A,t,e,n,a,o){const s=e[n],I=e[n+1],r=e[n+2],g=e[n+3],C=a[o],B=a[o+1],c=a[o+2],Q=a[o+3];return A[t]=s*Q+g*C+I*c-r*B,A[t+1]=I*Q+g*B+r*C-s*c,A[t+2]=r*Q+g*c+s*B-I*C,A[t+3]=g*Q-s*C-I*B-r*c,A}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get w(){return this._w}set w(A){this._w=A,this._onChangeCallback()}set(A,t,e,n){return this._x=A,this._y=t,this._z=e,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(A){return this._x=A.x,this._y=A.y,this._z=A.z,this._w=A.w,this._onChangeCallback(),this}setFromEuler(A,t){const e=A._x,n=A._y,a=A._z,o=A._order,s=Math.cos,I=Math.sin,r=s(e/2),g=s(n/2),C=s(a/2),B=I(e/2),c=I(n/2),Q=I(a/2);switch(o){case"XYZ":this._x=B*g*C+r*c*Q,this._y=r*c*C-B*g*Q,this._z=r*g*Q+B*c*C,this._w=r*g*C-B*c*Q;break;case"YXZ":this._x=B*g*C+r*c*Q,this._y=r*c*C-B*g*Q,this._z=r*g*Q-B*c*C,this._w=r*g*C+B*c*Q;break;case"ZXY":this._x=B*g*C-r*c*Q,this._y=r*c*C+B*g*Q,this._z=r*g*Q+B*c*C,this._w=r*g*C-B*c*Q;break;case"ZYX":this._x=B*g*C-r*c*Q,this._y=r*c*C+B*g*Q,this._z=r*g*Q-B*c*C,this._w=r*g*C+B*c*Q;break;case"YZX":this._x=B*g*C+r*c*Q,this._y=r*c*C+B*g*Q,this._z=r*g*Q-B*c*C,this._w=r*g*C-B*c*Q;break;case"XZY":this._x=B*g*C-r*c*Q,this._y=r*c*C-B*g*Q,this._z=r*g*Q+B*c*C,this._w=r*g*C+B*c*Q;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(A,t){const e=t/2,n=Math.sin(e);return this._x=A.x*n,this._y=A.y*n,this._z=A.z*n,this._w=Math.cos(e),this._onChangeCallback(),this}setFromRotationMatrix(A){const t=A.elements,e=t[0],n=t[4],a=t[8],o=t[1],s=t[5],I=t[9],r=t[2],g=t[6],C=t[10],B=e+s+C;if(B>0){const c=.5/Math.sqrt(B+1);this._w=.25/c,this._x=(g-I)*c,this._y=(a-r)*c,this._z=(o-n)*c}else if(e>s&&e>C){const c=2*Math.sqrt(1+e-s-C);this._w=(g-I)/c,this._x=.25*c,this._y=(n+o)/c,this._z=(a+r)/c}else if(s>C){const c=2*Math.sqrt(1+s-e-C);this._w=(a-r)/c,this._x=(n+o)/c,this._y=.25*c,this._z=(I+g)/c}else{const c=2*Math.sqrt(1+C-e-s);this._w=(o-n)/c,this._x=(a+r)/c,this._y=(I+g)/c,this._z=.25*c}return this._onChangeCallback(),this}setFromUnitVectors(A,t){let e=A.dot(t)+1;return e<Number.EPSILON?(e=0,Math.abs(A.x)>Math.abs(A.z)?(this._x=-A.y,this._y=A.x,this._z=0,this._w=e):(this._x=0,this._y=-A.z,this._z=A.y,this._w=e)):(this._x=A.y*t.z-A.z*t.y,this._y=A.z*t.x-A.x*t.z,this._z=A.x*t.y-A.y*t.x,this._w=e),this.normalize()}angleTo(A){return 2*Math.acos(Math.abs(ae(this.dot(A),-1,1)))}rotateTowards(A,t){const e=this.angleTo(A);if(e===0)return this;const n=Math.min(1,t/e);return this.slerp(A,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(A){return this._x*A._x+this._y*A._y+this._z*A._z+this._w*A._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let A=this.length();return A===0?(this._x=0,this._y=0,this._z=0,this._w=1):(A=1/A,this._x=this._x*A,this._y=this._y*A,this._z=this._z*A,this._w=this._w*A),this._onChangeCallback(),this}multiply(A){return this.multiplyQuaternions(this,A)}premultiply(A){return this.multiplyQuaternions(A,this)}multiplyQuaternions(A,t){const e=A._x,n=A._y,a=A._z,o=A._w,s=t._x,I=t._y,r=t._z,g=t._w;return this._x=e*g+o*s+n*r-a*I,this._y=n*g+o*I+a*s-e*r,this._z=a*g+o*r+e*I-n*s,this._w=o*g-e*s-n*I-a*r,this._onChangeCallback(),this}slerp(A,t){if(t===0)return this;if(t===1)return this.copy(A);const e=this._x,n=this._y,a=this._z,o=this._w;let s=o*A._w+e*A._x+n*A._y+a*A._z;if(s<0?(this._w=-A._w,this._x=-A._x,this._y=-A._y,this._z=-A._z,s=-s):this.copy(A),s>=1)return this._w=o,this._x=e,this._y=n,this._z=a,this;const I=1-s*s;if(I<=Number.EPSILON){const c=1-t;return this._w=c*o+t*this._w,this._x=c*e+t*this._x,this._y=c*n+t*this._y,this._z=c*a+t*this._z,this.normalize(),this._onChangeCallback(),this}const r=Math.sqrt(I),g=Math.atan2(r,s),C=Math.sin((1-t)*g)/r,B=Math.sin(t*g)/r;return this._w=o*C+this._w*B,this._x=e*C+this._x*B,this._y=n*C+this._y*B,this._z=a*C+this._z*B,this._onChangeCallback(),this}slerpQuaternions(A,t,e){return this.copy(A).slerp(t,e)}random(){const A=Math.random(),t=Math.sqrt(1-A),e=Math.sqrt(A),n=2*Math.PI*Math.random(),a=2*Math.PI*Math.random();return this.set(t*Math.cos(n),e*Math.sin(a),e*Math.cos(a),t*Math.sin(n))}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._w===this._w}fromArray(A,t=0){return this._x=A[t],this._y=A[t+1],this._z=A[t+2],this._w=A[t+3],this._onChangeCallback(),this}toArray(A=[],t=0){return A[t]=this._x,A[t+1]=this._y,A[t+2]=this._z,A[t+3]=this._w,A}fromBufferAttribute(A,t){return this._x=A.getX(t),this._y=A.getY(t),this._z=A.getZ(t),this._w=A.getW(t),this}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class rA{constructor(A=0,t=0,e=0){rA.prototype.isVector3=!0,this.x=A,this.y=t,this.z=e}set(A,t,e){return e===void 0&&(e=this.z),this.x=A,this.y=t,this.z=e,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setComponent(A,t){switch(A){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this}addVectors(A,t){return this.x=A.x+t.x,this.y=A.y+t.y,this.z=A.z+t.z,this}addScaledVector(A,t){return this.x+=A.x*t,this.y+=A.y*t,this.z+=A.z*t,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this}subVectors(A,t){return this.x=A.x-t.x,this.y=A.y-t.y,this.z=A.z-t.z,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this}multiplyVectors(A,t){return this.x=A.x*t.x,this.y=A.y*t.y,this.z=A.z*t.z,this}applyEuler(A){return this.applyQuaternion(uC.setFromEuler(A))}applyAxisAngle(A,t){return this.applyQuaternion(uC.setFromAxisAngle(A,t))}applyMatrix3(A){const t=this.x,e=this.y,n=this.z,a=A.elements;return this.x=a[0]*t+a[3]*e+a[6]*n,this.y=a[1]*t+a[4]*e+a[7]*n,this.z=a[2]*t+a[5]*e+a[8]*n,this}applyNormalMatrix(A){return this.applyMatrix3(A).normalize()}applyMatrix4(A){const t=this.x,e=this.y,n=this.z,a=A.elements,o=1/(a[3]*t+a[7]*e+a[11]*n+a[15]);return this.x=(a[0]*t+a[4]*e+a[8]*n+a[12])*o,this.y=(a[1]*t+a[5]*e+a[9]*n+a[13])*o,this.z=(a[2]*t+a[6]*e+a[10]*n+a[14])*o,this}applyQuaternion(A){const t=this.x,e=this.y,n=this.z,a=A.x,o=A.y,s=A.z,I=A.w,r=I*t+o*n-s*e,g=I*e+s*t-a*n,C=I*n+a*e-o*t,B=-a*t-o*e-s*n;return this.x=r*I+B*-a+g*-s-C*-o,this.y=g*I+B*-o+C*-a-r*-s,this.z=C*I+B*-s+r*-o-g*-a,this}project(A){return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix)}unproject(A){return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld)}transformDirection(A){const t=this.x,e=this.y,n=this.z,a=A.elements;return this.x=a[0]*t+a[4]*e+a[8]*n,this.y=a[1]*t+a[5]*e+a[9]*n,this.z=a[2]*t+a[6]*e+a[10]*n,this.normalize()}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this}divideScalar(A){return this.multiplyScalar(1/A)}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this}clamp(A,t){return this.x=Math.max(A.x,Math.min(t.x,this.x)),this.y=Math.max(A.y,Math.min(t.y,this.y)),this.z=Math.max(A.z,Math.min(t.z,this.z)),this}clampScalar(A,t){return this.x=Math.max(A,Math.min(t,this.x)),this.y=Math.max(A,Math.min(t,this.y)),this.z=Math.max(A,Math.min(t,this.z)),this}clampLength(A,t){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(A,Math.min(t,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,t){return this.x+=(A.x-this.x)*t,this.y+=(A.y-this.y)*t,this.z+=(A.z-this.z)*t,this}lerpVectors(A,t,e){return this.x=A.x+(t.x-A.x)*e,this.y=A.y+(t.y-A.y)*e,this.z=A.z+(t.z-A.z)*e,this}cross(A){return this.crossVectors(this,A)}crossVectors(A,t){const e=A.x,n=A.y,a=A.z,o=t.x,s=t.y,I=t.z;return this.x=n*I-a*s,this.y=a*o-e*I,this.z=e*s-n*o,this}projectOnVector(A){const t=A.lengthSq();if(t===0)return this.set(0,0,0);const e=A.dot(this)/t;return this.copy(A).multiplyScalar(e)}projectOnPlane(A){return ig.copy(this).projectOnVector(A),this.sub(ig)}reflect(A){return this.sub(ig.copy(A).multiplyScalar(2*this.dot(A)))}angleTo(A){const t=Math.sqrt(this.lengthSq()*A.lengthSq());if(t===0)return Math.PI/2;const e=this.dot(A)/t;return Math.acos(ae(e,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const t=this.x-A.x,e=this.y-A.y,n=this.z-A.z;return t*t+e*e+n*n}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)+Math.abs(this.z-A.z)}setFromSpherical(A){return this.setFromSphericalCoords(A.radius,A.phi,A.theta)}setFromSphericalCoords(A,t,e){const n=Math.sin(t)*A;return this.x=n*Math.sin(e),this.y=Math.cos(t)*A,this.z=n*Math.cos(e),this}setFromCylindrical(A){return this.setFromCylindricalCoords(A.radius,A.theta,A.y)}setFromCylindricalCoords(A,t,e){return this.x=A*Math.sin(t),this.y=e,this.z=A*Math.cos(t),this}setFromMatrixPosition(A){const t=A.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(A){const t=this.setFromMatrixColumn(A,0).length(),e=this.setFromMatrixColumn(A,1).length(),n=this.setFromMatrixColumn(A,2).length();return this.x=t,this.y=e,this.z=n,this}setFromMatrixColumn(A,t){return this.fromArray(A.elements,t*4)}setFromMatrix3Column(A,t){return this.fromArray(A.elements,t*3)}setFromEuler(A){return this.x=A._x,this.y=A._y,this.z=A._z,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z}fromArray(A,t=0){return this.x=A[t],this.y=A[t+1],this.z=A[t+2],this}toArray(A=[],t=0){return A[t]=this.x,A[t+1]=this.y,A[t+2]=this.z,A}fromBufferAttribute(A,t){return this.x=A.getX(t),this.y=A.getY(t),this.z=A.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const A=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,e=Math.sqrt(1-A**2);return this.x=e*Math.cos(t),this.y=e*Math.sin(t),this.z=A,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const ig=new rA,uC=new Jn;class ln{constructor(A=new rA(1/0,1/0,1/0),t=new rA(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=A,this.max=t}set(A,t){return this.min.copy(A),this.max.copy(t),this}setFromArray(A){let t=1/0,e=1/0,n=1/0,a=-1/0,o=-1/0,s=-1/0;for(let I=0,r=A.length;I<r;I+=3){const g=A[I],C=A[I+1],B=A[I+2];g<t&&(t=g),C<e&&(e=C),B<n&&(n=B),g>a&&(a=g),C>o&&(o=C),B>s&&(s=B)}return this.min.set(t,e,n),this.max.set(a,o,s),this}setFromBufferAttribute(A){let t=1/0,e=1/0,n=1/0,a=-1/0,o=-1/0,s=-1/0;for(let I=0,r=A.count;I<r;I++){const g=A.getX(I),C=A.getY(I),B=A.getZ(I);g<t&&(t=g),C<e&&(e=C),B<n&&(n=B),g>a&&(a=g),C>o&&(o=C),B>s&&(s=B)}return this.min.set(t,e,n),this.max.set(a,o,s),this}setFromPoints(A){this.makeEmpty();for(let t=0,e=A.length;t<e;t++)this.expandByPoint(A[t]);return this}setFromCenterAndSize(A,t){const e=hn.copy(t).multiplyScalar(.5);return this.min.copy(A).sub(e),this.max.copy(A).add(e),this}setFromObject(A,t=!1){return this.makeEmpty(),this.expandByObject(A,t)}clone(){return new this.constructor().copy(this)}copy(A){return this.min.copy(A.min),this.max.copy(A.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(A){return this.isEmpty()?A.set(0,0,0):A.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(A){return this.isEmpty()?A.set(0,0,0):A.subVectors(this.max,this.min)}expandByPoint(A){return this.min.min(A),this.max.max(A),this}expandByVector(A){return this.min.sub(A),this.max.add(A),this}expandByScalar(A){return this.min.addScalar(-A),this.max.addScalar(A),this}expandByObject(A,t=!1){A.updateWorldMatrix(!1,!1);const e=A.geometry;if(e!==void 0)if(t&&e.attributes!=null&&e.attributes.position!==void 0){const a=e.attributes.position;for(let o=0,s=a.count;o<s;o++)hn.fromBufferAttribute(a,o).applyMatrix4(A.matrixWorld),this.expandByPoint(hn)}else e.boundingBox===null&&e.computeBoundingBox(),ng.copy(e.boundingBox),ng.applyMatrix4(A.matrixWorld),this.union(ng);const n=A.children;for(let a=0,o=n.length;a<o;a++)this.expandByObject(n[a],t);return this}containsPoint(A){return!(A.x<this.min.x||A.x>this.max.x||A.y<this.min.y||A.y>this.max.y||A.z<this.min.z||A.z>this.max.z)}containsBox(A){return this.min.x<=A.min.x&&A.max.x<=this.max.x&&this.min.y<=A.min.y&&A.max.y<=this.max.y&&this.min.z<=A.min.z&&A.max.z<=this.max.z}getParameter(A,t){return t.set((A.x-this.min.x)/(this.max.x-this.min.x),(A.y-this.min.y)/(this.max.y-this.min.y),(A.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(A){return!(A.max.x<this.min.x||A.min.x>this.max.x||A.max.y<this.min.y||A.min.y>this.max.y||A.max.z<this.min.z||A.min.z>this.max.z)}intersectsSphere(A){return this.clampPoint(A.center,hn),hn.distanceToSquared(A.center)<=A.radius*A.radius}intersectsPlane(A){let t,e;return A.normal.x>0?(t=A.normal.x*this.min.x,e=A.normal.x*this.max.x):(t=A.normal.x*this.max.x,e=A.normal.x*this.min.x),A.normal.y>0?(t+=A.normal.y*this.min.y,e+=A.normal.y*this.max.y):(t+=A.normal.y*this.max.y,e+=A.normal.y*this.min.y),A.normal.z>0?(t+=A.normal.z*this.min.z,e+=A.normal.z*this.max.z):(t+=A.normal.z*this.max.z,e+=A.normal.z*this.min.z),t<=-A.constant&&e>=-A.constant}intersectsTriangle(A){if(this.isEmpty())return!1;this.getCenter(Es),po.subVectors(this.max,Es),oa.subVectors(A.a,Es),ra.subVectors(A.b,Es),ga.subVectors(A.c,Es),bi.subVectors(ra,oa),Ui.subVectors(ga,ra),cn.subVectors(oa,ga);let t=[0,-bi.z,bi.y,0,-Ui.z,Ui.y,0,-cn.z,cn.y,bi.z,0,-bi.x,Ui.z,0,-Ui.x,cn.z,0,-cn.x,-bi.y,bi.x,0,-Ui.y,Ui.x,0,-cn.y,cn.x,0];return!ag(t,oa,ra,ga,po)||(t=[1,0,0,0,1,0,0,0,1],!ag(t,oa,ra,ga,po))?!1:(mo.crossVectors(bi,Ui),t=[mo.x,mo.y,mo.z],ag(t,oa,ra,ga,po))}clampPoint(A,t){return t.copy(A).clamp(this.min,this.max)}distanceToPoint(A){return hn.copy(A).clamp(this.min,this.max).sub(A).length()}getBoundingSphere(A){return this.getCenter(A.center),A.radius=this.getSize(hn).length()*.5,A}intersect(A){return this.min.max(A.min),this.max.min(A.max),this.isEmpty()&&this.makeEmpty(),this}union(A){return this.min.min(A.min),this.max.max(A.max),this}applyMatrix4(A){return this.isEmpty()?this:(Ci[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(A),Ci[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(A),Ci[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(A),Ci[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(A),Ci[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(A),Ci[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(A),Ci[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(A),Ci[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(A),this.setFromPoints(Ci),this)}translate(A){return this.min.add(A),this.max.add(A),this}equals(A){return A.min.equals(this.min)&&A.max.equals(this.max)}}const Ci=[new rA,new rA,new rA,new rA,new rA,new rA,new rA,new rA],hn=new rA,ng=new ln,oa=new rA,ra=new rA,ga=new rA,bi=new rA,Ui=new rA,cn=new rA,Es=new rA,po=new rA,mo=new rA,En=new rA;function ag(i,A,t,e,n){for(let a=0,o=i.length-3;a<=o;a+=3){En.fromArray(i,a);const s=n.x*Math.abs(En.x)+n.y*Math.abs(En.y)+n.z*Math.abs(En.z),I=A.dot(En),r=t.dot(En),g=e.dot(En);if(Math.max(-Math.max(I,r,g),Math.min(I,r,g))>s)return!1}return!0}const yd=new ln,pC=new rA,yo=new rA,sg=new rA;class cl{constructor(A=new rA,t=-1){this.center=A,this.radius=t}set(A,t){return this.center.copy(A),this.radius=t,this}setFromPoints(A,t){const e=this.center;t!==void 0?e.copy(t):yd.setFromPoints(A).getCenter(e);let n=0;for(let a=0,o=A.length;a<o;a++)n=Math.max(n,e.distanceToSquared(A[a]));return this.radius=Math.sqrt(n),this}copy(A){return this.center.copy(A.center),this.radius=A.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(A){return A.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(A){return A.distanceTo(this.center)-this.radius}intersectsSphere(A){const t=this.radius+A.radius;return A.center.distanceToSquared(this.center)<=t*t}intersectsBox(A){return A.intersectsSphere(this)}intersectsPlane(A){return Math.abs(A.distanceToPoint(this.center))<=this.radius}clampPoint(A,t){const e=this.center.distanceToSquared(A);return t.copy(A),e>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(A){return this.isEmpty()?(A.makeEmpty(),A):(A.set(this.center,this.center),A.expandByScalar(this.radius),A)}applyMatrix4(A){return this.center.applyMatrix4(A),this.radius=this.radius*A.getMaxScaleOnAxis(),this}translate(A){return this.center.add(A),this}expandByPoint(A){if(this.isEmpty())return this.center.copy(A),this.radius=0,this;sg.subVectors(A,this.center);const t=sg.lengthSq();if(t>this.radius*this.radius){const e=Math.sqrt(t),n=(e-this.radius)*.5;this.center.add(sg.multiplyScalar(n/e)),this.radius+=n}return this}union(A){return A.isEmpty()?this:this.isEmpty()?(this.copy(A),this):(this.center.equals(A.center)===!0?yo.set(0,0,1).multiplyScalar(A.radius):yo.subVectors(A.center,this.center).normalize().multiplyScalar(A.radius),this.expandByPoint(pC.copy(A.center).add(yo)),this.expandByPoint(pC.copy(A.center).sub(yo)),this)}equals(A){return A.center.equals(this.center)&&A.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Bi=new rA,og=new rA,Do=new rA,ki=new rA,rg=new rA,So=new rA,gg=new rA;class Dd{constructor(A=new rA,t=new rA(0,0,-1)){this.origin=A,this.direction=t}set(A,t){return this.origin.copy(A),this.direction.copy(t),this}copy(A){return this.origin.copy(A.origin),this.direction.copy(A.direction),this}at(A,t){return t.copy(this.direction).multiplyScalar(A).add(this.origin)}lookAt(A){return this.direction.copy(A).sub(this.origin).normalize(),this}recast(A){return this.origin.copy(this.at(A,Bi)),this}closestPointToPoint(A,t){t.subVectors(A,this.origin);const e=t.dot(this.direction);return e<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(e).add(this.origin)}distanceToPoint(A){return Math.sqrt(this.distanceSqToPoint(A))}distanceSqToPoint(A){const t=Bi.subVectors(A,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(A):(Bi.copy(this.direction).multiplyScalar(t).add(this.origin),Bi.distanceToSquared(A))}distanceSqToSegment(A,t,e,n){og.copy(A).add(t).multiplyScalar(.5),Do.copy(t).sub(A).normalize(),ki.copy(this.origin).sub(og);const a=A.distanceTo(t)*.5,o=-this.direction.dot(Do),s=ki.dot(this.direction),I=-ki.dot(Do),r=ki.lengthSq(),g=Math.abs(1-o*o);let C,B,c,Q;if(g>0)if(C=o*I-s,B=o*s-I,Q=a*g,C>=0)if(B>=-Q)if(B<=Q){const h=1/g;C*=h,B*=h,c=C*(C+o*B+2*s)+B*(o*C+B+2*I)+r}else B=a,C=Math.max(0,-(o*B+s)),c=-C*C+B*(B+2*I)+r;else B=-a,C=Math.max(0,-(o*B+s)),c=-C*C+B*(B+2*I)+r;else B<=-Q?(C=Math.max(0,-(-o*a+s)),B=C>0?-a:Math.min(Math.max(-a,-I),a),c=-C*C+B*(B+2*I)+r):B<=Q?(C=0,B=Math.min(Math.max(-a,-I),a),c=B*(B+2*I)+r):(C=Math.max(0,-(o*a+s)),B=C>0?a:Math.min(Math.max(-a,-I),a),c=-C*C+B*(B+2*I)+r);else B=o>0?-a:a,C=Math.max(0,-(o*B+s)),c=-C*C+B*(B+2*I)+r;return e&&e.copy(this.direction).multiplyScalar(C).add(this.origin),n&&n.copy(Do).multiplyScalar(B).add(og),c}intersectSphere(A,t){Bi.subVectors(A.center,this.origin);const e=Bi.dot(this.direction),n=Bi.dot(Bi)-e*e,a=A.radius*A.radius;if(n>a)return null;const o=Math.sqrt(a-n),s=e-o,I=e+o;return s<0&&I<0?null:s<0?this.at(I,t):this.at(s,t)}intersectsSphere(A){return this.distanceSqToPoint(A.center)<=A.radius*A.radius}distanceToPlane(A){const t=A.normal.dot(this.direction);if(t===0)return A.distanceToPoint(this.origin)===0?0:null;const e=-(this.origin.dot(A.normal)+A.constant)/t;return e>=0?e:null}intersectPlane(A,t){const e=this.distanceToPlane(A);return e===null?null:this.at(e,t)}intersectsPlane(A){const t=A.distanceToPoint(this.origin);return t===0||A.normal.dot(this.direction)*t<0}intersectBox(A,t){let e,n,a,o,s,I;const r=1/this.direction.x,g=1/this.direction.y,C=1/this.direction.z,B=this.origin;return r>=0?(e=(A.min.x-B.x)*r,n=(A.max.x-B.x)*r):(e=(A.max.x-B.x)*r,n=(A.min.x-B.x)*r),g>=0?(a=(A.min.y-B.y)*g,o=(A.max.y-B.y)*g):(a=(A.max.y-B.y)*g,o=(A.min.y-B.y)*g),e>o||a>n||((a>e||e!==e)&&(e=a),(o<n||n!==n)&&(n=o),C>=0?(s=(A.min.z-B.z)*C,I=(A.max.z-B.z)*C):(s=(A.max.z-B.z)*C,I=(A.min.z-B.z)*C),e>I||s>n)||((s>e||e!==e)&&(e=s),(I<n||n!==n)&&(n=I),n<0)?null:this.at(e>=0?e:n,t)}intersectsBox(A){return this.intersectBox(A,Bi)!==null}intersectTriangle(A,t,e,n,a){rg.subVectors(t,A),So.subVectors(e,A),gg.crossVectors(rg,So);let o=this.direction.dot(gg),s;if(o>0){if(n)return null;s=1}else if(o<0)s=-1,o=-o;else return null;ki.subVectors(this.origin,A);const I=s*this.direction.dot(So.crossVectors(ki,So));if(I<0)return null;const r=s*this.direction.dot(rg.cross(ki));if(r<0||I+r>o)return null;const g=-s*ki.dot(gg);return g<0?null:this.at(g/o,a)}applyMatrix4(A){return this.origin.applyMatrix4(A),this.direction.transformDirection(A),this}equals(A){return A.origin.equals(this.origin)&&A.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class _t{constructor(){_t.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(A,t,e,n,a,o,s,I,r,g,C,B,c,Q,h,l){const E=this.elements;return E[0]=A,E[4]=t,E[8]=e,E[12]=n,E[1]=a,E[5]=o,E[9]=s,E[13]=I,E[2]=r,E[6]=g,E[10]=C,E[14]=B,E[3]=c,E[7]=Q,E[11]=h,E[15]=l,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new _t().fromArray(this.elements)}copy(A){const t=this.elements,e=A.elements;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],this}copyPosition(A){const t=this.elements,e=A.elements;return t[12]=e[12],t[13]=e[13],t[14]=e[14],this}setFromMatrix3(A){const t=A.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(A,t,e){return A.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}makeBasis(A,t,e){return this.set(A.x,t.x,e.x,0,A.y,t.y,e.y,0,A.z,t.z,e.z,0,0,0,0,1),this}extractRotation(A){const t=this.elements,e=A.elements,n=1/Ia.setFromMatrixColumn(A,0).length(),a=1/Ia.setFromMatrixColumn(A,1).length(),o=1/Ia.setFromMatrixColumn(A,2).length();return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=0,t[4]=e[4]*a,t[5]=e[5]*a,t[6]=e[6]*a,t[7]=0,t[8]=e[8]*o,t[9]=e[9]*o,t[10]=e[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(A){const t=this.elements,e=A.x,n=A.y,a=A.z,o=Math.cos(e),s=Math.sin(e),I=Math.cos(n),r=Math.sin(n),g=Math.cos(a),C=Math.sin(a);if(A.order==="XYZ"){const B=o*g,c=o*C,Q=s*g,h=s*C;t[0]=I*g,t[4]=-I*C,t[8]=r,t[1]=c+Q*r,t[5]=B-h*r,t[9]=-s*I,t[2]=h-B*r,t[6]=Q+c*r,t[10]=o*I}else if(A.order==="YXZ"){const B=I*g,c=I*C,Q=r*g,h=r*C;t[0]=B+h*s,t[4]=Q*s-c,t[8]=o*r,t[1]=o*C,t[5]=o*g,t[9]=-s,t[2]=c*s-Q,t[6]=h+B*s,t[10]=o*I}else if(A.order==="ZXY"){const B=I*g,c=I*C,Q=r*g,h=r*C;t[0]=B-h*s,t[4]=-o*C,t[8]=Q+c*s,t[1]=c+Q*s,t[5]=o*g,t[9]=h-B*s,t[2]=-o*r,t[6]=s,t[10]=o*I}else if(A.order==="ZYX"){const B=o*g,c=o*C,Q=s*g,h=s*C;t[0]=I*g,t[4]=Q*r-c,t[8]=B*r+h,t[1]=I*C,t[5]=h*r+B,t[9]=c*r-Q,t[2]=-r,t[6]=s*I,t[10]=o*I}else if(A.order==="YZX"){const B=o*I,c=o*r,Q=s*I,h=s*r;t[0]=I*g,t[4]=h-B*C,t[8]=Q*C+c,t[1]=C,t[5]=o*g,t[9]=-s*g,t[2]=-r*g,t[6]=c*C+Q,t[10]=B-h*C}else if(A.order==="XZY"){const B=o*I,c=o*r,Q=s*I,h=s*r;t[0]=I*g,t[4]=-C,t[8]=r*g,t[1]=B*C+h,t[5]=o*g,t[9]=c*C-Q,t[2]=Q*C-c,t[6]=s*g,t[10]=h*C+B}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(A){return this.compose(Sd,A,wd)}lookAt(A,t,e){const n=this.elements;return de.subVectors(A,t),de.lengthSq()===0&&(de.z=1),de.normalize(),Ti.crossVectors(e,de),Ti.lengthSq()===0&&(Math.abs(e.z)===1?de.x+=1e-4:de.z+=1e-4,de.normalize(),Ti.crossVectors(e,de)),Ti.normalize(),wo.crossVectors(de,Ti),n[0]=Ti.x,n[4]=wo.x,n[8]=de.x,n[1]=Ti.y,n[5]=wo.y,n[9]=de.y,n[2]=Ti.z,n[6]=wo.z,n[10]=de.z,this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,t){const e=A.elements,n=t.elements,a=this.elements,o=e[0],s=e[4],I=e[8],r=e[12],g=e[1],C=e[5],B=e[9],c=e[13],Q=e[2],h=e[6],l=e[10],E=e[14],f=e[3],u=e[7],d=e[11],m=e[15],S=n[0],D=n[4],p=n[8],w=n[12],M=n[1],R=n[5],U=n[9],N=n[13],G=n[2],T=n[6],V=n[10],tA=n[14],z=n[3],W=n[7],Y=n[11],CA=n[15];return a[0]=o*S+s*M+I*G+r*z,a[4]=o*D+s*R+I*T+r*W,a[8]=o*p+s*U+I*V+r*Y,a[12]=o*w+s*N+I*tA+r*CA,a[1]=g*S+C*M+B*G+c*z,a[5]=g*D+C*R+B*T+c*W,a[9]=g*p+C*U+B*V+c*Y,a[13]=g*w+C*N+B*tA+c*CA,a[2]=Q*S+h*M+l*G+E*z,a[6]=Q*D+h*R+l*T+E*W,a[10]=Q*p+h*U+l*V+E*Y,a[14]=Q*w+h*N+l*tA+E*CA,a[3]=f*S+u*M+d*G+m*z,a[7]=f*D+u*R+d*T+m*W,a[11]=f*p+u*U+d*V+m*Y,a[15]=f*w+u*N+d*tA+m*CA,this}multiplyScalar(A){const t=this.elements;return t[0]*=A,t[4]*=A,t[8]*=A,t[12]*=A,t[1]*=A,t[5]*=A,t[9]*=A,t[13]*=A,t[2]*=A,t[6]*=A,t[10]*=A,t[14]*=A,t[3]*=A,t[7]*=A,t[11]*=A,t[15]*=A,this}determinant(){const A=this.elements,t=A[0],e=A[4],n=A[8],a=A[12],o=A[1],s=A[5],I=A[9],r=A[13],g=A[2],C=A[6],B=A[10],c=A[14],Q=A[3],h=A[7],l=A[11],E=A[15];return Q*(+a*I*C-n*r*C-a*s*B+e*r*B+n*s*c-e*I*c)+h*(+t*I*c-t*r*B+a*o*B-n*o*c+n*r*g-a*I*g)+l*(+t*r*C-t*s*c-a*o*C+e*o*c+a*s*g-e*r*g)+E*(-n*s*g-t*I*C+t*s*B+n*o*C-e*o*B+e*I*g)}transpose(){const A=this.elements;let t;return t=A[1],A[1]=A[4],A[4]=t,t=A[2],A[2]=A[8],A[8]=t,t=A[6],A[6]=A[9],A[9]=t,t=A[3],A[3]=A[12],A[12]=t,t=A[7],A[7]=A[13],A[13]=t,t=A[11],A[11]=A[14],A[14]=t,this}setPosition(A,t,e){const n=this.elements;return A.isVector3?(n[12]=A.x,n[13]=A.y,n[14]=A.z):(n[12]=A,n[13]=t,n[14]=e),this}invert(){const A=this.elements,t=A[0],e=A[1],n=A[2],a=A[3],o=A[4],s=A[5],I=A[6],r=A[7],g=A[8],C=A[9],B=A[10],c=A[11],Q=A[12],h=A[13],l=A[14],E=A[15],f=C*l*r-h*B*r+h*I*c-s*l*c-C*I*E+s*B*E,u=Q*B*r-g*l*r-Q*I*c+o*l*c+g*I*E-o*B*E,d=g*h*r-Q*C*r+Q*s*c-o*h*c-g*s*E+o*C*E,m=Q*C*I-g*h*I-Q*s*B+o*h*B+g*s*l-o*C*l,S=t*f+e*u+n*d+a*m;if(S===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const D=1/S;return A[0]=f*D,A[1]=(h*B*a-C*l*a-h*n*c+e*l*c+C*n*E-e*B*E)*D,A[2]=(s*l*a-h*I*a+h*n*r-e*l*r-s*n*E+e*I*E)*D,A[3]=(C*I*a-s*B*a-C*n*r+e*B*r+s*n*c-e*I*c)*D,A[4]=u*D,A[5]=(g*l*a-Q*B*a+Q*n*c-t*l*c-g*n*E+t*B*E)*D,A[6]=(Q*I*a-o*l*a-Q*n*r+t*l*r+o*n*E-t*I*E)*D,A[7]=(o*B*a-g*I*a+g*n*r-t*B*r-o*n*c+t*I*c)*D,A[8]=d*D,A[9]=(Q*C*a-g*h*a-Q*e*c+t*h*c+g*e*E-t*C*E)*D,A[10]=(o*h*a-Q*s*a+Q*e*r-t*h*r-o*e*E+t*s*E)*D,A[11]=(g*s*a-o*C*a-g*e*r+t*C*r+o*e*c-t*s*c)*D,A[12]=m*D,A[13]=(g*h*n-Q*C*n+Q*e*B-t*h*B-g*e*l+t*C*l)*D,A[14]=(Q*s*n-o*h*n-Q*e*I+t*h*I+o*e*l-t*s*l)*D,A[15]=(o*C*n-g*s*n+g*e*I-t*C*I-o*e*B+t*s*B)*D,this}scale(A){const t=this.elements,e=A.x,n=A.y,a=A.z;return t[0]*=e,t[4]*=n,t[8]*=a,t[1]*=e,t[5]*=n,t[9]*=a,t[2]*=e,t[6]*=n,t[10]*=a,t[3]*=e,t[7]*=n,t[11]*=a,this}getMaxScaleOnAxis(){const A=this.elements,t=A[0]*A[0]+A[1]*A[1]+A[2]*A[2],e=A[4]*A[4]+A[5]*A[5]+A[6]*A[6],n=A[8]*A[8]+A[9]*A[9]+A[10]*A[10];return Math.sqrt(Math.max(t,e,n))}makeTranslation(A,t,e){return this.set(1,0,0,A,0,1,0,t,0,0,1,e,0,0,0,1),this}makeRotationX(A){const t=Math.cos(A),e=Math.sin(A);return this.set(1,0,0,0,0,t,-e,0,0,e,t,0,0,0,0,1),this}makeRotationY(A){const t=Math.cos(A),e=Math.sin(A);return this.set(t,0,e,0,0,1,0,0,-e,0,t,0,0,0,0,1),this}makeRotationZ(A){const t=Math.cos(A),e=Math.sin(A);return this.set(t,-e,0,0,e,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(A,t){const e=Math.cos(t),n=Math.sin(t),a=1-e,o=A.x,s=A.y,I=A.z,r=a*o,g=a*s;return this.set(r*o+e,r*s-n*I,r*I+n*s,0,r*s+n*I,g*s+e,g*I-n*o,0,r*I-n*s,g*I+n*o,a*I*I+e,0,0,0,0,1),this}makeScale(A,t,e){return this.set(A,0,0,0,0,t,0,0,0,0,e,0,0,0,0,1),this}makeShear(A,t,e,n,a,o){return this.set(1,e,a,0,A,1,o,0,t,n,1,0,0,0,0,1),this}compose(A,t,e){const n=this.elements,a=t._x,o=t._y,s=t._z,I=t._w,r=a+a,g=o+o,C=s+s,B=a*r,c=a*g,Q=a*C,h=o*g,l=o*C,E=s*C,f=I*r,u=I*g,d=I*C,m=e.x,S=e.y,D=e.z;return n[0]=(1-(h+E))*m,n[1]=(c+d)*m,n[2]=(Q-u)*m,n[3]=0,n[4]=(c-d)*S,n[5]=(1-(B+E))*S,n[6]=(l+f)*S,n[7]=0,n[8]=(Q+u)*D,n[9]=(l-f)*D,n[10]=(1-(B+h))*D,n[11]=0,n[12]=A.x,n[13]=A.y,n[14]=A.z,n[15]=1,this}decompose(A,t,e){const n=this.elements;let a=Ia.set(n[0],n[1],n[2]).length();const o=Ia.set(n[4],n[5],n[6]).length(),s=Ia.set(n[8],n[9],n[10]).length();this.determinant()<0&&(a=-a),A.x=n[12],A.y=n[13],A.z=n[14],ke.copy(this);const r=1/a,g=1/o,C=1/s;return ke.elements[0]*=r,ke.elements[1]*=r,ke.elements[2]*=r,ke.elements[4]*=g,ke.elements[5]*=g,ke.elements[6]*=g,ke.elements[8]*=C,ke.elements[9]*=C,ke.elements[10]*=C,t.setFromRotationMatrix(ke),e.x=a,e.y=o,e.z=s,this}makePerspective(A,t,e,n,a,o){const s=this.elements,I=2*a/(t-A),r=2*a/(e-n),g=(t+A)/(t-A),C=(e+n)/(e-n),B=-(o+a)/(o-a),c=-2*o*a/(o-a);return s[0]=I,s[4]=0,s[8]=g,s[12]=0,s[1]=0,s[5]=r,s[9]=C,s[13]=0,s[2]=0,s[6]=0,s[10]=B,s[14]=c,s[3]=0,s[7]=0,s[11]=-1,s[15]=0,this}makeOrthographic(A,t,e,n,a,o){const s=this.elements,I=1/(t-A),r=1/(e-n),g=1/(o-a),C=(t+A)*I,B=(e+n)*r,c=(o+a)*g;return s[0]=2*I,s[4]=0,s[8]=0,s[12]=-C,s[1]=0,s[5]=2*r,s[9]=0,s[13]=-B,s[2]=0,s[6]=0,s[10]=-2*g,s[14]=-c,s[3]=0,s[7]=0,s[11]=0,s[15]=1,this}equals(A){const t=this.elements,e=A.elements;for(let n=0;n<16;n++)if(t[n]!==e[n])return!1;return!0}fromArray(A,t=0){for(let e=0;e<16;e++)this.elements[e]=A[e+t];return this}toArray(A=[],t=0){const e=this.elements;return A[t]=e[0],A[t+1]=e[1],A[t+2]=e[2],A[t+3]=e[3],A[t+4]=e[4],A[t+5]=e[5],A[t+6]=e[6],A[t+7]=e[7],A[t+8]=e[8],A[t+9]=e[9],A[t+10]=e[10],A[t+11]=e[11],A[t+12]=e[12],A[t+13]=e[13],A[t+14]=e[14],A[t+15]=e[15],A}}const Ia=new rA,ke=new _t,Sd=new rA(0,0,0),wd=new rA(1,1,1),Ti=new rA,wo=new rA,de=new rA,mC=new _t,yC=new Jn;class oo{constructor(A=0,t=0,e=0,n=oo.DefaultOrder){this.isEuler=!0,this._x=A,this._y=t,this._z=e,this._order=n}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get order(){return this._order}set order(A){this._order=A,this._onChangeCallback()}set(A,t,e,n=this._order){return this._x=A,this._y=t,this._z=e,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(A){return this._x=A._x,this._y=A._y,this._z=A._z,this._order=A._order,this._onChangeCallback(),this}setFromRotationMatrix(A,t=this._order,e=!0){const n=A.elements,a=n[0],o=n[4],s=n[8],I=n[1],r=n[5],g=n[9],C=n[2],B=n[6],c=n[10];switch(t){case"XYZ":this._y=Math.asin(ae(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-g,c),this._z=Math.atan2(-o,a)):(this._x=Math.atan2(B,r),this._z=0);break;case"YXZ":this._x=Math.asin(-ae(g,-1,1)),Math.abs(g)<.9999999?(this._y=Math.atan2(s,c),this._z=Math.atan2(I,r)):(this._y=Math.atan2(-C,a),this._z=0);break;case"ZXY":this._x=Math.asin(ae(B,-1,1)),Math.abs(B)<.9999999?(this._y=Math.atan2(-C,c),this._z=Math.atan2(-o,r)):(this._y=0,this._z=Math.atan2(I,a));break;case"ZYX":this._y=Math.asin(-ae(C,-1,1)),Math.abs(C)<.9999999?(this._x=Math.atan2(B,c),this._z=Math.atan2(I,a)):(this._x=0,this._z=Math.atan2(-o,r));break;case"YZX":this._z=Math.asin(ae(I,-1,1)),Math.abs(I)<.9999999?(this._x=Math.atan2(-g,r),this._y=Math.atan2(-C,a)):(this._x=0,this._y=Math.atan2(s,c));break;case"XZY":this._z=Math.asin(-ae(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(B,r),this._y=Math.atan2(s,a)):(this._x=Math.atan2(-g,c),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,e===!0&&this._onChangeCallback(),this}setFromQuaternion(A,t,e){return mC.makeRotationFromQuaternion(A),this.setFromRotationMatrix(mC,t,e)}setFromVector3(A,t=this._order){return this.set(A.x,A.y,A.z,t)}reorder(A){return yC.setFromEuler(this),this.setFromQuaternion(yC,A)}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._order===this._order}fromArray(A){return this._x=A[0],this._y=A[1],this._z=A[2],A[3]!==void 0&&(this._order=A[3]),this._onChangeCallback(),this}toArray(A=[],t=0){return A[t]=this._x,A[t+1]=this._y,A[t+2]=this._z,A[t+3]=this._order,A}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}oo.DefaultOrder="XYZ";oo.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Jc{constructor(){this.mask=1}set(A){this.mask=(1<<A|0)>>>0}enable(A){this.mask|=1<<A|0}enableAll(){this.mask=-1}toggle(A){this.mask^=1<<A|0}disable(A){this.mask&=~(1<<A|0)}disableAll(){this.mask=0}test(A){return(this.mask&A.mask)!==0}isEnabled(A){return(this.mask&(1<<A|0))!==0}}let _d=0;const DC=new rA,la=new Jn,hi=new _t,_o=new rA,Qs=new rA,xd=new rA,Md=new Jn,SC=new rA(1,0,0),wC=new rA(0,1,0),_C=new rA(0,0,1),Fd={type:"added"},xC={type:"removed"};class vt extends $n{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:_d++}),this.uuid=so(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=vt.DefaultUp.clone();const A=new rA,t=new oo,e=new Jn,n=new rA(1,1,1);function a(){e.setFromEuler(t,!1)}function o(){t.setFromQuaternion(e,void 0,!1)}t._onChange(a),e._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:A},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:e},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new _t},normalMatrix:{value:new Re}}),this.matrix=new _t,this.matrixWorld=new _t,this.matrixAutoUpdate=vt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=vt.DefaultMatrixWorldAutoUpdate,this.layers=new Jc,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(A){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(A),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(A){return this.quaternion.premultiply(A),this}setRotationFromAxisAngle(A,t){this.quaternion.setFromAxisAngle(A,t)}setRotationFromEuler(A){this.quaternion.setFromEuler(A,!0)}setRotationFromMatrix(A){this.quaternion.setFromRotationMatrix(A)}setRotationFromQuaternion(A){this.quaternion.copy(A)}rotateOnAxis(A,t){return la.setFromAxisAngle(A,t),this.quaternion.multiply(la),this}rotateOnWorldAxis(A,t){return la.setFromAxisAngle(A,t),this.quaternion.premultiply(la),this}rotateX(A){return this.rotateOnAxis(SC,A)}rotateY(A){return this.rotateOnAxis(wC,A)}rotateZ(A){return this.rotateOnAxis(_C,A)}translateOnAxis(A,t){return DC.copy(A).applyQuaternion(this.quaternion),this.position.add(DC.multiplyScalar(t)),this}translateX(A){return this.translateOnAxis(SC,A)}translateY(A){return this.translateOnAxis(wC,A)}translateZ(A){return this.translateOnAxis(_C,A)}localToWorld(A){return A.applyMatrix4(this.matrixWorld)}worldToLocal(A){return A.applyMatrix4(hi.copy(this.matrixWorld).invert())}lookAt(A,t,e){A.isVector3?_o.copy(A):_o.set(A,t,e);const n=this.parent;this.updateWorldMatrix(!0,!1),Qs.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?hi.lookAt(Qs,_o,this.up):hi.lookAt(_o,Qs,this.up),this.quaternion.setFromRotationMatrix(hi),n&&(hi.extractRotation(n.matrixWorld),la.setFromRotationMatrix(hi),this.quaternion.premultiply(la.invert()))}add(A){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return A===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",A),this):(A&&A.isObject3D?(A.parent!==null&&A.parent.remove(A),A.parent=this,this.children.push(A),A.dispatchEvent(Fd)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",A),this)}remove(A){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(A);return t!==-1&&(A.parent=null,this.children.splice(t,1),A.dispatchEvent(xC)),this}removeFromParent(){const A=this.parent;return A!==null&&A.remove(this),this}clear(){for(let A=0;A<this.children.length;A++){const t=this.children[A];t.parent=null,t.dispatchEvent(xC)}return this.children.length=0,this}attach(A){return this.updateWorldMatrix(!0,!1),hi.copy(this.matrixWorld).invert(),A.parent!==null&&(A.parent.updateWorldMatrix(!0,!1),hi.multiply(A.parent.matrixWorld)),A.applyMatrix4(hi),this.add(A),A.updateWorldMatrix(!1,!0),this}getObjectById(A){return this.getObjectByProperty("id",A)}getObjectByName(A){return this.getObjectByProperty("name",A)}getObjectByProperty(A,t){if(this[A]===t)return this;for(let e=0,n=this.children.length;e<n;e++){const o=this.children[e].getObjectByProperty(A,t);if(o!==void 0)return o}}getWorldPosition(A){return this.updateWorldMatrix(!0,!1),A.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Qs,A,xd),A}getWorldScale(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Qs,Md,A),A}getWorldDirection(A){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return A.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(A){A(this);const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].traverse(A)}traverseVisible(A){if(this.visible===!1)return;A(this);const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].traverseVisible(A)}traverseAncestors(A){const t=this.parent;t!==null&&(A(t),t.traverseAncestors(A))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(A){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||A)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,A=!0);const t=this.children;for(let e=0,n=t.length;e<n;e++){const a=t[e];(a.matrixWorldAutoUpdate===!0||A===!0)&&a.updateMatrixWorld(A)}}updateWorldMatrix(A,t){const e=this.parent;if(A===!0&&e!==null&&e.matrixWorldAutoUpdate===!0&&e.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const n=this.children;for(let a=0,o=n.length;a<o;a++){const s=n[a];s.matrixWorldAutoUpdate===!0&&s.updateWorldMatrix(!1,!0)}}}toJSON(A){const t=A===void 0||typeof A=="string",e={};t&&(A={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},e.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const n={};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.castShadow===!0&&(n.castShadow=!0),this.receiveShadow===!0&&(n.receiveShadow=!0),this.visible===!1&&(n.visible=!1),this.frustumCulled===!1&&(n.frustumCulled=!1),this.renderOrder!==0&&(n.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(n.instanceColor=this.instanceColor.toJSON()));function a(s,I){return s[I.uuid]===void 0&&(s[I.uuid]=I.toJSON(A)),I.uuid}if(this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(A).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(n.environment=this.environment.toJSON(A).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=a(A.geometries,this.geometry);const s=this.geometry.parameters;if(s!==void 0&&s.shapes!==void 0){const I=s.shapes;if(Array.isArray(I))for(let r=0,g=I.length;r<g;r++){const C=I[r];a(A.shapes,C)}else a(A.shapes,I)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(a(A.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const s=[];for(let I=0,r=this.material.length;I<r;I++)s.push(a(A.materials,this.material[I]));n.material=s}else n.material=a(A.materials,this.material);if(this.children.length>0){n.children=[];for(let s=0;s<this.children.length;s++)n.children.push(this.children[s].toJSON(A).object)}if(this.animations.length>0){n.animations=[];for(let s=0;s<this.animations.length;s++){const I=this.animations[s];n.animations.push(a(A.animations,I))}}if(t){const s=o(A.geometries),I=o(A.materials),r=o(A.textures),g=o(A.images),C=o(A.shapes),B=o(A.skeletons),c=o(A.animations),Q=o(A.nodes);s.length>0&&(e.geometries=s),I.length>0&&(e.materials=I),r.length>0&&(e.textures=r),g.length>0&&(e.images=g),C.length>0&&(e.shapes=C),B.length>0&&(e.skeletons=B),c.length>0&&(e.animations=c),Q.length>0&&(e.nodes=Q)}return e.object=n,e;function o(s){const I=[];for(const r in s){const g=s[r];delete g.metadata,I.push(g)}return I}}clone(A){return new this.constructor().copy(this,A)}copy(A,t=!0){if(this.name=A.name,this.up.copy(A.up),this.position.copy(A.position),this.rotation.order=A.rotation.order,this.quaternion.copy(A.quaternion),this.scale.copy(A.scale),this.matrix.copy(A.matrix),this.matrixWorld.copy(A.matrixWorld),this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrixWorldNeedsUpdate=A.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=A.matrixWorldAutoUpdate,this.layers.mask=A.layers.mask,this.visible=A.visible,this.castShadow=A.castShadow,this.receiveShadow=A.receiveShadow,this.frustumCulled=A.frustumCulled,this.renderOrder=A.renderOrder,this.userData=JSON.parse(JSON.stringify(A.userData)),t===!0)for(let e=0;e<A.children.length;e++){const n=A.children[e];this.add(n.clone())}return this}}vt.DefaultUp=new rA(0,1,0);vt.DefaultMatrixAutoUpdate=!0;vt.DefaultMatrixWorldAutoUpdate=!0;const Te=new rA,ci=new rA,Ig=new rA,Ei=new rA,Ca=new rA,Ba=new rA,MC=new rA,lg=new rA,Cg=new rA,Bg=new rA;class xi{constructor(A=new rA,t=new rA,e=new rA){this.a=A,this.b=t,this.c=e}static getNormal(A,t,e,n){n.subVectors(e,t),Te.subVectors(A,t),n.cross(Te);const a=n.lengthSq();return a>0?n.multiplyScalar(1/Math.sqrt(a)):n.set(0,0,0)}static getBarycoord(A,t,e,n,a){Te.subVectors(n,t),ci.subVectors(e,t),Ig.subVectors(A,t);const o=Te.dot(Te),s=Te.dot(ci),I=Te.dot(Ig),r=ci.dot(ci),g=ci.dot(Ig),C=o*r-s*s;if(C===0)return a.set(-2,-1,-1);const B=1/C,c=(r*I-s*g)*B,Q=(o*g-s*I)*B;return a.set(1-c-Q,Q,c)}static containsPoint(A,t,e,n){return this.getBarycoord(A,t,e,n,Ei),Ei.x>=0&&Ei.y>=0&&Ei.x+Ei.y<=1}static getUV(A,t,e,n,a,o,s,I){return this.getBarycoord(A,t,e,n,Ei),I.set(0,0),I.addScaledVector(a,Ei.x),I.addScaledVector(o,Ei.y),I.addScaledVector(s,Ei.z),I}static isFrontFacing(A,t,e,n){return Te.subVectors(e,t),ci.subVectors(A,t),Te.cross(ci).dot(n)<0}set(A,t,e){return this.a.copy(A),this.b.copy(t),this.c.copy(e),this}setFromPointsAndIndices(A,t,e,n){return this.a.copy(A[t]),this.b.copy(A[e]),this.c.copy(A[n]),this}setFromAttributeAndIndices(A,t,e,n){return this.a.fromBufferAttribute(A,t),this.b.fromBufferAttribute(A,e),this.c.fromBufferAttribute(A,n),this}clone(){return new this.constructor().copy(this)}copy(A){return this.a.copy(A.a),this.b.copy(A.b),this.c.copy(A.c),this}getArea(){return Te.subVectors(this.c,this.b),ci.subVectors(this.a,this.b),Te.cross(ci).length()*.5}getMidpoint(A){return A.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(A){return xi.getNormal(this.a,this.b,this.c,A)}getPlane(A){return A.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(A,t){return xi.getBarycoord(A,this.a,this.b,this.c,t)}getUV(A,t,e,n,a){return xi.getUV(A,this.a,this.b,this.c,t,e,n,a)}containsPoint(A){return xi.containsPoint(A,this.a,this.b,this.c)}isFrontFacing(A){return xi.isFrontFacing(this.a,this.b,this.c,A)}intersectsBox(A){return A.intersectsTriangle(this)}closestPointToPoint(A,t){const e=this.a,n=this.b,a=this.c;let o,s;Ca.subVectors(n,e),Ba.subVectors(a,e),lg.subVectors(A,e);const I=Ca.dot(lg),r=Ba.dot(lg);if(I<=0&&r<=0)return t.copy(e);Cg.subVectors(A,n);const g=Ca.dot(Cg),C=Ba.dot(Cg);if(g>=0&&C<=g)return t.copy(n);const B=I*C-g*r;if(B<=0&&I>=0&&g<=0)return o=I/(I-g),t.copy(e).addScaledVector(Ca,o);Bg.subVectors(A,a);const c=Ca.dot(Bg),Q=Ba.dot(Bg);if(Q>=0&&c<=Q)return t.copy(a);const h=c*r-I*Q;if(h<=0&&r>=0&&Q<=0)return s=r/(r-Q),t.copy(e).addScaledVector(Ba,s);const l=g*Q-c*C;if(l<=0&&C-g>=0&&c-Q>=0)return MC.subVectors(a,n),s=(C-g)/(C-g+(c-Q)),t.copy(n).addScaledVector(MC,s);const E=1/(l+h+B);return o=h*E,s=B*E,t.copy(e).addScaledVector(Ca,o).addScaledVector(Ba,s)}equals(A){return A.a.equals(this.a)&&A.b.equals(this.b)&&A.c.equals(this.c)}}let Rd=0;class ss extends $n{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Rd++}),this.uuid=so(),this.name="",this.type="Material",this.blending=Ya,this.side=Za,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=Gc,this.blendDst=Nc,this.blendEquation=Ua,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=MI,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=fd,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Zr,this.stencilZFail=Zr,this.stencilZPass=Zr,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(A){this._alphaTest>0!=A>0&&this.version++,this._alphaTest=A}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(A){if(A!==void 0)for(const t in A){const e=A[t];if(e===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}const n=this[t];if(n===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}n&&n.isColor?n.set(e):n&&n.isVector3&&e&&e.isVector3?n.copy(e):this[t]=e}}toJSON(A){const t=A===void 0||typeof A=="string";t&&(A={textures:{},images:{}});const e={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),this.color&&this.color.isColor&&(e.color=this.color.getHex()),this.roughness!==void 0&&(e.roughness=this.roughness),this.metalness!==void 0&&(e.metalness=this.metalness),this.sheen!==void 0&&(e.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(e.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(e.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(e.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(e.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(e.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(e.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(e.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(e.shininess=this.shininess),this.clearcoat!==void 0&&(e.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(e.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(e.clearcoatMap=this.clearcoatMap.toJSON(A).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(e.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(A).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(e.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(A).uuid,e.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(e.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(e.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(e.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(e.iridescenceMap=this.iridescenceMap.toJSON(A).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(e.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(A).uuid),this.map&&this.map.isTexture&&(e.map=this.map.toJSON(A).uuid),this.matcap&&this.matcap.isTexture&&(e.matcap=this.matcap.toJSON(A).uuid),this.alphaMap&&this.alphaMap.isTexture&&(e.alphaMap=this.alphaMap.toJSON(A).uuid),this.lightMap&&this.lightMap.isTexture&&(e.lightMap=this.lightMap.toJSON(A).uuid,e.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(e.aoMap=this.aoMap.toJSON(A).uuid,e.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(e.bumpMap=this.bumpMap.toJSON(A).uuid,e.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(e.normalMap=this.normalMap.toJSON(A).uuid,e.normalMapType=this.normalMapType,e.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(e.displacementMap=this.displacementMap.toJSON(A).uuid,e.displacementScale=this.displacementScale,e.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(e.roughnessMap=this.roughnessMap.toJSON(A).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(e.metalnessMap=this.metalnessMap.toJSON(A).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(e.emissiveMap=this.emissiveMap.toJSON(A).uuid),this.specularMap&&this.specularMap.isTexture&&(e.specularMap=this.specularMap.toJSON(A).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(e.specularIntensityMap=this.specularIntensityMap.toJSON(A).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(e.specularColorMap=this.specularColorMap.toJSON(A).uuid),this.envMap&&this.envMap.isTexture&&(e.envMap=this.envMap.toJSON(A).uuid,this.combine!==void 0&&(e.combine=this.combine)),this.envMapIntensity!==void 0&&(e.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(e.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(e.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(e.gradientMap=this.gradientMap.toJSON(A).uuid),this.transmission!==void 0&&(e.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(e.transmissionMap=this.transmissionMap.toJSON(A).uuid),this.thickness!==void 0&&(e.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(e.thicknessMap=this.thicknessMap.toJSON(A).uuid),this.attenuationDistance!==void 0&&(e.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(e.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(e.size=this.size),this.shadowSide!==null&&(e.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(e.sizeAttenuation=this.sizeAttenuation),this.blending!==Ya&&(e.blending=this.blending),this.side!==Za&&(e.side=this.side),this.vertexColors&&(e.vertexColors=!0),this.opacity<1&&(e.opacity=this.opacity),this.transparent===!0&&(e.transparent=this.transparent),e.depthFunc=this.depthFunc,e.depthTest=this.depthTest,e.depthWrite=this.depthWrite,e.colorWrite=this.colorWrite,e.stencilWrite=this.stencilWrite,e.stencilWriteMask=this.stencilWriteMask,e.stencilFunc=this.stencilFunc,e.stencilRef=this.stencilRef,e.stencilFuncMask=this.stencilFuncMask,e.stencilFail=this.stencilFail,e.stencilZFail=this.stencilZFail,e.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(e.rotation=this.rotation),this.polygonOffset===!0&&(e.polygonOffset=!0),this.polygonOffsetFactor!==0&&(e.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(e.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(e.linewidth=this.linewidth),this.dashSize!==void 0&&(e.dashSize=this.dashSize),this.gapSize!==void 0&&(e.gapSize=this.gapSize),this.scale!==void 0&&(e.scale=this.scale),this.dithering===!0&&(e.dithering=!0),this.alphaTest>0&&(e.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(e.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(e.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(e.wireframe=this.wireframe),this.wireframeLinewidth>1&&(e.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(e.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(e.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(e.flatShading=this.flatShading),this.visible===!1&&(e.visible=!1),this.toneMapped===!1&&(e.toneMapped=!1),this.fog===!1&&(e.fog=!1),JSON.stringify(this.userData)!=="{}"&&(e.userData=this.userData);function n(a){const o=[];for(const s in a){const I=a[s];delete I.metadata,o.push(I)}return o}if(t){const a=n(A.textures),o=n(A.images);a.length>0&&(e.textures=a),o.length>0&&(e.images=o)}return e}clone(){return new this.constructor().copy(this)}copy(A){this.name=A.name,this.blending=A.blending,this.side=A.side,this.vertexColors=A.vertexColors,this.opacity=A.opacity,this.transparent=A.transparent,this.blendSrc=A.blendSrc,this.blendDst=A.blendDst,this.blendEquation=A.blendEquation,this.blendSrcAlpha=A.blendSrcAlpha,this.blendDstAlpha=A.blendDstAlpha,this.blendEquationAlpha=A.blendEquationAlpha,this.depthFunc=A.depthFunc,this.depthTest=A.depthTest,this.depthWrite=A.depthWrite,this.stencilWriteMask=A.stencilWriteMask,this.stencilFunc=A.stencilFunc,this.stencilRef=A.stencilRef,this.stencilFuncMask=A.stencilFuncMask,this.stencilFail=A.stencilFail,this.stencilZFail=A.stencilZFail,this.stencilZPass=A.stencilZPass,this.stencilWrite=A.stencilWrite;const t=A.clippingPlanes;let e=null;if(t!==null){const n=t.length;e=new Array(n);for(let a=0;a!==n;++a)e[a]=t[a].clone()}return this.clippingPlanes=e,this.clipIntersection=A.clipIntersection,this.clipShadows=A.clipShadows,this.shadowSide=A.shadowSide,this.colorWrite=A.colorWrite,this.precision=A.precision,this.polygonOffset=A.polygonOffset,this.polygonOffsetFactor=A.polygonOffsetFactor,this.polygonOffsetUnits=A.polygonOffsetUnits,this.dithering=A.dithering,this.alphaTest=A.alphaTest,this.alphaToCoverage=A.alphaToCoverage,this.premultipliedAlpha=A.premultipliedAlpha,this.visible=A.visible,this.toneMapped=A.toneMapped,this.userData=JSON.parse(JSON.stringify(A.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(A){A===!0&&this.version++}}class nn extends ss{constructor(A){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new st(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Bl,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.specularMap=A.specularMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.combine=A.combine,this.reflectivity=A.reflectivity,this.refractionRatio=A.refractionRatio,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.fog=A.fog,this}}const Dt=new rA,xo=new XA;class oi{constructor(A,t,e){if(Array.isArray(A))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=A,this.itemSize=t,this.count=A!==void 0?A.length/t:0,this.normalized=e===!0,this.usage=QC,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(A){A===!0&&this.version++}setUsage(A){return this.usage=A,this}copy(A){return this.name=A.name,this.array=new A.array.constructor(A.array),this.itemSize=A.itemSize,this.count=A.count,this.normalized=A.normalized,this.usage=A.usage,this}copyAt(A,t,e){A*=this.itemSize,e*=t.itemSize;for(let n=0,a=this.itemSize;n<a;n++)this.array[A+n]=t.array[e+n];return this}copyArray(A){return this.array.set(A),this}applyMatrix3(A){if(this.itemSize===2)for(let t=0,e=this.count;t<e;t++)xo.fromBufferAttribute(this,t),xo.applyMatrix3(A),this.setXY(t,xo.x,xo.y);else if(this.itemSize===3)for(let t=0,e=this.count;t<e;t++)Dt.fromBufferAttribute(this,t),Dt.applyMatrix3(A),this.setXYZ(t,Dt.x,Dt.y,Dt.z);return this}applyMatrix4(A){for(let t=0,e=this.count;t<e;t++)Dt.fromBufferAttribute(this,t),Dt.applyMatrix4(A),this.setXYZ(t,Dt.x,Dt.y,Dt.z);return this}applyNormalMatrix(A){for(let t=0,e=this.count;t<e;t++)Dt.fromBufferAttribute(this,t),Dt.applyNormalMatrix(A),this.setXYZ(t,Dt.x,Dt.y,Dt.z);return this}transformDirection(A){for(let t=0,e=this.count;t<e;t++)Dt.fromBufferAttribute(this,t),Dt.transformDirection(A),this.setXYZ(t,Dt.x,Dt.y,Dt.z);return this}set(A,t=0){return this.array.set(A,t),this}getX(A){let t=this.array[A*this.itemSize];return this.normalized&&(t=Qo(t,this.array)),t}setX(A,t){return this.normalized&&(t=Qe(t,this.array)),this.array[A*this.itemSize]=t,this}getY(A){let t=this.array[A*this.itemSize+1];return this.normalized&&(t=Qo(t,this.array)),t}setY(A,t){return this.normalized&&(t=Qe(t,this.array)),this.array[A*this.itemSize+1]=t,this}getZ(A){let t=this.array[A*this.itemSize+2];return this.normalized&&(t=Qo(t,this.array)),t}setZ(A,t){return this.normalized&&(t=Qe(t,this.array)),this.array[A*this.itemSize+2]=t,this}getW(A){let t=this.array[A*this.itemSize+3];return this.normalized&&(t=Qo(t,this.array)),t}setW(A,t){return this.normalized&&(t=Qe(t,this.array)),this.array[A*this.itemSize+3]=t,this}setXY(A,t,e){return A*=this.itemSize,this.normalized&&(t=Qe(t,this.array),e=Qe(e,this.array)),this.array[A+0]=t,this.array[A+1]=e,this}setXYZ(A,t,e,n){return A*=this.itemSize,this.normalized&&(t=Qe(t,this.array),e=Qe(e,this.array),n=Qe(n,this.array)),this.array[A+0]=t,this.array[A+1]=e,this.array[A+2]=n,this}setXYZW(A,t,e,n,a){return A*=this.itemSize,this.normalized&&(t=Qe(t,this.array),e=Qe(e,this.array),n=Qe(n,this.array),a=Qe(a,this.array)),this.array[A+0]=t,this.array[A+1]=e,this.array[A+2]=n,this.array[A+3]=a,this}onUpload(A){return this.onUploadCallback=A,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const A={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(A.name=this.name),this.usage!==QC&&(A.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(A.updateRange=this.updateRange),A}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}class Pc extends oi{constructor(A,t,e){super(new Uint16Array(A),t,e)}}class Yc extends oi{constructor(A,t,e){super(new Uint32Array(A),t,e)}}class ri extends oi{constructor(A,t,e){super(new Float32Array(A),t,e)}}let vd=0;const _e=new _t,hg=new vt,ha=new rA,fe=new ln,ds=new ln,Ut=new rA;class Cn extends $n{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:vd++}),this.uuid=so(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(A){return Array.isArray(A)?this.index=new(Uc(A)?Yc:Pc)(A,1):this.index=A,this}getAttribute(A){return this.attributes[A]}setAttribute(A,t){return this.attributes[A]=t,this}deleteAttribute(A){return delete this.attributes[A],this}hasAttribute(A){return this.attributes[A]!==void 0}addGroup(A,t,e=0){this.groups.push({start:A,count:t,materialIndex:e})}clearGroups(){this.groups=[]}setDrawRange(A,t){this.drawRange.start=A,this.drawRange.count=t}applyMatrix4(A){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(A),t.needsUpdate=!0);const e=this.attributes.normal;if(e!==void 0){const a=new Re().getNormalMatrix(A);e.applyNormalMatrix(a),e.needsUpdate=!0}const n=this.attributes.tangent;return n!==void 0&&(n.transformDirection(A),n.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(A){return _e.makeRotationFromQuaternion(A),this.applyMatrix4(_e),this}rotateX(A){return _e.makeRotationX(A),this.applyMatrix4(_e),this}rotateY(A){return _e.makeRotationY(A),this.applyMatrix4(_e),this}rotateZ(A){return _e.makeRotationZ(A),this.applyMatrix4(_e),this}translate(A,t,e){return _e.makeTranslation(A,t,e),this.applyMatrix4(_e),this}scale(A,t,e){return _e.makeScale(A,t,e),this.applyMatrix4(_e),this}lookAt(A){return hg.lookAt(A),hg.updateMatrix(),this.applyMatrix4(hg.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ha).negate(),this.translate(ha.x,ha.y,ha.z),this}setFromPoints(A){const t=[];for(let e=0,n=A.length;e<n;e++){const a=A[e];t.push(a.x,a.y,a.z||0)}return this.setAttribute("position",new ri(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new ln);const A=this.attributes.position,t=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new rA(-1/0,-1/0,-1/0),new rA(1/0,1/0,1/0));return}if(A!==void 0){if(this.boundingBox.setFromBufferAttribute(A),t)for(let e=0,n=t.length;e<n;e++){const a=t[e];fe.setFromBufferAttribute(a),this.morphTargetsRelative?(Ut.addVectors(this.boundingBox.min,fe.min),this.boundingBox.expandByPoint(Ut),Ut.addVectors(this.boundingBox.max,fe.max),this.boundingBox.expandByPoint(Ut)):(this.boundingBox.expandByPoint(fe.min),this.boundingBox.expandByPoint(fe.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new cl);const A=this.attributes.position,t=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new rA,1/0);return}if(A){const e=this.boundingSphere.center;if(fe.setFromBufferAttribute(A),t)for(let a=0,o=t.length;a<o;a++){const s=t[a];ds.setFromBufferAttribute(s),this.morphTargetsRelative?(Ut.addVectors(fe.min,ds.min),fe.expandByPoint(Ut),Ut.addVectors(fe.max,ds.max),fe.expandByPoint(Ut)):(fe.expandByPoint(ds.min),fe.expandByPoint(ds.max))}fe.getCenter(e);let n=0;for(let a=0,o=A.count;a<o;a++)Ut.fromBufferAttribute(A,a),n=Math.max(n,e.distanceToSquared(Ut));if(t)for(let a=0,o=t.length;a<o;a++){const s=t[a],I=this.morphTargetsRelative;for(let r=0,g=s.count;r<g;r++)Ut.fromBufferAttribute(s,r),I&&(ha.fromBufferAttribute(A,r),Ut.add(ha)),n=Math.max(n,e.distanceToSquared(Ut))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const A=this.index,t=this.attributes;if(A===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const e=A.array,n=t.position.array,a=t.normal.array,o=t.uv.array,s=n.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new oi(new Float32Array(4*s),4));const I=this.getAttribute("tangent").array,r=[],g=[];for(let M=0;M<s;M++)r[M]=new rA,g[M]=new rA;const C=new rA,B=new rA,c=new rA,Q=new XA,h=new XA,l=new XA,E=new rA,f=new rA;function u(M,R,U){C.fromArray(n,M*3),B.fromArray(n,R*3),c.fromArray(n,U*3),Q.fromArray(o,M*2),h.fromArray(o,R*2),l.fromArray(o,U*2),B.sub(C),c.sub(C),h.sub(Q),l.sub(Q);const N=1/(h.x*l.y-l.x*h.y);!isFinite(N)||(E.copy(B).multiplyScalar(l.y).addScaledVector(c,-h.y).multiplyScalar(N),f.copy(c).multiplyScalar(h.x).addScaledVector(B,-l.x).multiplyScalar(N),r[M].add(E),r[R].add(E),r[U].add(E),g[M].add(f),g[R].add(f),g[U].add(f))}let d=this.groups;d.length===0&&(d=[{start:0,count:e.length}]);for(let M=0,R=d.length;M<R;++M){const U=d[M],N=U.start,G=U.count;for(let T=N,V=N+G;T<V;T+=3)u(e[T+0],e[T+1],e[T+2])}const m=new rA,S=new rA,D=new rA,p=new rA;function w(M){D.fromArray(a,M*3),p.copy(D);const R=r[M];m.copy(R),m.sub(D.multiplyScalar(D.dot(R))).normalize(),S.crossVectors(p,R);const N=S.dot(g[M])<0?-1:1;I[M*4]=m.x,I[M*4+1]=m.y,I[M*4+2]=m.z,I[M*4+3]=N}for(let M=0,R=d.length;M<R;++M){const U=d[M],N=U.start,G=U.count;for(let T=N,V=N+G;T<V;T+=3)w(e[T+0]),w(e[T+1]),w(e[T+2])}}computeVertexNormals(){const A=this.index,t=this.getAttribute("position");if(t!==void 0){let e=this.getAttribute("normal");if(e===void 0)e=new oi(new Float32Array(t.count*3),3),this.setAttribute("normal",e);else for(let B=0,c=e.count;B<c;B++)e.setXYZ(B,0,0,0);const n=new rA,a=new rA,o=new rA,s=new rA,I=new rA,r=new rA,g=new rA,C=new rA;if(A)for(let B=0,c=A.count;B<c;B+=3){const Q=A.getX(B+0),h=A.getX(B+1),l=A.getX(B+2);n.fromBufferAttribute(t,Q),a.fromBufferAttribute(t,h),o.fromBufferAttribute(t,l),g.subVectors(o,a),C.subVectors(n,a),g.cross(C),s.fromBufferAttribute(e,Q),I.fromBufferAttribute(e,h),r.fromBufferAttribute(e,l),s.add(g),I.add(g),r.add(g),e.setXYZ(Q,s.x,s.y,s.z),e.setXYZ(h,I.x,I.y,I.z),e.setXYZ(l,r.x,r.y,r.z)}else for(let B=0,c=t.count;B<c;B+=3)n.fromBufferAttribute(t,B+0),a.fromBufferAttribute(t,B+1),o.fromBufferAttribute(t,B+2),g.subVectors(o,a),C.subVectors(n,a),g.cross(C),e.setXYZ(B+0,g.x,g.y,g.z),e.setXYZ(B+1,g.x,g.y,g.z),e.setXYZ(B+2,g.x,g.y,g.z);this.normalizeNormals(),e.needsUpdate=!0}}merge(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),this}normalizeNormals(){const A=this.attributes.normal;for(let t=0,e=A.count;t<e;t++)Ut.fromBufferAttribute(A,t),Ut.normalize(),A.setXYZ(t,Ut.x,Ut.y,Ut.z)}toNonIndexed(){function A(s,I){const r=s.array,g=s.itemSize,C=s.normalized,B=new r.constructor(I.length*g);let c=0,Q=0;for(let h=0,l=I.length;h<l;h++){s.isInterleavedBufferAttribute?c=I[h]*s.data.stride+s.offset:c=I[h]*g;for(let E=0;E<g;E++)B[Q++]=r[c++]}return new oi(B,g,C)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Cn,e=this.index.array,n=this.attributes;for(const s in n){const I=n[s],r=A(I,e);t.setAttribute(s,r)}const a=this.morphAttributes;for(const s in a){const I=[],r=a[s];for(let g=0,C=r.length;g<C;g++){const B=r[g],c=A(B,e);I.push(c)}t.morphAttributes[s]=I}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let s=0,I=o.length;s<I;s++){const r=o[s];t.addGroup(r.start,r.count,r.materialIndex)}return t}toJSON(){const A={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(A.uuid=this.uuid,A.type=this.type,this.name!==""&&(A.name=this.name),Object.keys(this.userData).length>0&&(A.userData=this.userData),this.parameters!==void 0){const I=this.parameters;for(const r in I)I[r]!==void 0&&(A[r]=I[r]);return A}A.data={attributes:{}};const t=this.index;t!==null&&(A.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const e=this.attributes;for(const I in e){const r=e[I];A.data.attributes[I]=r.toJSON(A.data)}const n={};let a=!1;for(const I in this.morphAttributes){const r=this.morphAttributes[I],g=[];for(let C=0,B=r.length;C<B;C++){const c=r[C];g.push(c.toJSON(A.data))}g.length>0&&(n[I]=g,a=!0)}a&&(A.data.morphAttributes=n,A.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(A.data.groups=JSON.parse(JSON.stringify(o)));const s=this.boundingSphere;return s!==null&&(A.data.boundingSphere={center:s.center.toArray(),radius:s.radius}),A}clone(){return new this.constructor().copy(this)}copy(A){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=A.name;const e=A.index;e!==null&&this.setIndex(e.clone(t));const n=A.attributes;for(const r in n){const g=n[r];this.setAttribute(r,g.clone(t))}const a=A.morphAttributes;for(const r in a){const g=[],C=a[r];for(let B=0,c=C.length;B<c;B++)g.push(C[B].clone(t));this.morphAttributes[r]=g}this.morphTargetsRelative=A.morphTargetsRelative;const o=A.groups;for(let r=0,g=o.length;r<g;r++){const C=o[r];this.addGroup(C.start,C.count,C.materialIndex)}const s=A.boundingBox;s!==null&&(this.boundingBox=s.clone());const I=A.boundingSphere;return I!==null&&(this.boundingSphere=I.clone()),this.drawRange.start=A.drawRange.start,this.drawRange.count=A.drawRange.count,this.userData=A.userData,A.parameters!==void 0&&(this.parameters=Object.assign({},A.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const FC=new _t,ca=new Dd,cg=new cl,Hi=new rA,qi=new rA,Ji=new rA,Eg=new rA,Qg=new rA,dg=new rA,Mo=new rA,Fo=new rA,Ro=new rA,vo=new XA,Go=new XA,No=new XA,fg=new rA,Lo=new rA;class wt extends vt{constructor(A=new Cn,t=new nn){super(),this.isMesh=!0,this.type="Mesh",this.geometry=A,this.material=t,this.updateMorphTargets()}copy(A,t){return super.copy(A,t),A.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=A.morphTargetInfluences.slice()),A.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},A.morphTargetDictionary)),this.material=A.material,this.geometry=A.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let a=0,o=n.length;a<o;a++){const s=n[a].name||String(a);this.morphTargetInfluences.push(0),this.morphTargetDictionary[s]=a}}}}raycast(A,t){const e=this.geometry,n=this.material,a=this.matrixWorld;if(n===void 0||(e.boundingSphere===null&&e.computeBoundingSphere(),cg.copy(e.boundingSphere),cg.applyMatrix4(a),A.ray.intersectsSphere(cg)===!1)||(FC.copy(a).invert(),ca.copy(A.ray).applyMatrix4(FC),e.boundingBox!==null&&ca.intersectsBox(e.boundingBox)===!1))return;let o;const s=e.index,I=e.attributes.position,r=e.morphAttributes.position,g=e.morphTargetsRelative,C=e.attributes.uv,B=e.attributes.uv2,c=e.groups,Q=e.drawRange;if(s!==null)if(Array.isArray(n))for(let h=0,l=c.length;h<l;h++){const E=c[h],f=n[E.materialIndex],u=Math.max(E.start,Q.start),d=Math.min(s.count,Math.min(E.start+E.count,Q.start+Q.count));for(let m=u,S=d;m<S;m+=3){const D=s.getX(m),p=s.getX(m+1),w=s.getX(m+2);o=bo(this,f,A,ca,I,r,g,C,B,D,p,w),o&&(o.faceIndex=Math.floor(m/3),o.face.materialIndex=E.materialIndex,t.push(o))}}else{const h=Math.max(0,Q.start),l=Math.min(s.count,Q.start+Q.count);for(let E=h,f=l;E<f;E+=3){const u=s.getX(E),d=s.getX(E+1),m=s.getX(E+2);o=bo(this,n,A,ca,I,r,g,C,B,u,d,m),o&&(o.faceIndex=Math.floor(E/3),t.push(o))}}else if(I!==void 0)if(Array.isArray(n))for(let h=0,l=c.length;h<l;h++){const E=c[h],f=n[E.materialIndex],u=Math.max(E.start,Q.start),d=Math.min(I.count,Math.min(E.start+E.count,Q.start+Q.count));for(let m=u,S=d;m<S;m+=3){const D=m,p=m+1,w=m+2;o=bo(this,f,A,ca,I,r,g,C,B,D,p,w),o&&(o.faceIndex=Math.floor(m/3),o.face.materialIndex=E.materialIndex,t.push(o))}}else{const h=Math.max(0,Q.start),l=Math.min(I.count,Q.start+Q.count);for(let E=h,f=l;E<f;E+=3){const u=E,d=E+1,m=E+2;o=bo(this,n,A,ca,I,r,g,C,B,u,d,m),o&&(o.faceIndex=Math.floor(E/3),t.push(o))}}}}function Gd(i,A,t,e,n,a,o,s){let I;if(A.side===ve?I=e.intersectTriangle(o,a,n,!0,s):I=e.intersectTriangle(n,a,o,A.side!==Xi,s),I===null)return null;Lo.copy(s),Lo.applyMatrix4(i.matrixWorld);const r=t.ray.origin.distanceTo(Lo);return r<t.near||r>t.far?null:{distance:r,point:Lo.clone(),object:i}}function bo(i,A,t,e,n,a,o,s,I,r,g,C){Hi.fromBufferAttribute(n,r),qi.fromBufferAttribute(n,g),Ji.fromBufferAttribute(n,C);const B=i.morphTargetInfluences;if(a&&B){Mo.set(0,0,0),Fo.set(0,0,0),Ro.set(0,0,0);for(let Q=0,h=a.length;Q<h;Q++){const l=B[Q],E=a[Q];l!==0&&(Eg.fromBufferAttribute(E,r),Qg.fromBufferAttribute(E,g),dg.fromBufferAttribute(E,C),o?(Mo.addScaledVector(Eg,l),Fo.addScaledVector(Qg,l),Ro.addScaledVector(dg,l)):(Mo.addScaledVector(Eg.sub(Hi),l),Fo.addScaledVector(Qg.sub(qi),l),Ro.addScaledVector(dg.sub(Ji),l)))}Hi.add(Mo),qi.add(Fo),Ji.add(Ro)}i.isSkinnedMesh&&(i.boneTransform(r,Hi),i.boneTransform(g,qi),i.boneTransform(C,Ji));const c=Gd(i,A,t,e,Hi,qi,Ji,fg);if(c){s&&(vo.fromBufferAttribute(s,r),Go.fromBufferAttribute(s,g),No.fromBufferAttribute(s,C),c.uv=xi.getUV(fg,Hi,qi,Ji,vo,Go,No,new XA)),I&&(vo.fromBufferAttribute(I,r),Go.fromBufferAttribute(I,g),No.fromBufferAttribute(I,C),c.uv2=xi.getUV(fg,Hi,qi,Ji,vo,Go,No,new XA));const Q={a:r,b:g,c:C,normal:new rA,materialIndex:0};xi.getNormal(Hi,qi,Ji,Q.normal),c.face=Q}return c}class ro extends Cn{constructor(A=1,t=1,e=1,n=1,a=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:A,height:t,depth:e,widthSegments:n,heightSegments:a,depthSegments:o};const s=this;n=Math.floor(n),a=Math.floor(a),o=Math.floor(o);const I=[],r=[],g=[],C=[];let B=0,c=0;Q("z","y","x",-1,-1,e,t,A,o,a,0),Q("z","y","x",1,-1,e,t,-A,o,a,1),Q("x","z","y",1,1,A,e,t,n,o,2),Q("x","z","y",1,-1,A,e,-t,n,o,3),Q("x","y","z",1,-1,A,t,e,n,a,4),Q("x","y","z",-1,-1,A,t,-e,n,a,5),this.setIndex(I),this.setAttribute("position",new ri(r,3)),this.setAttribute("normal",new ri(g,3)),this.setAttribute("uv",new ri(C,2));function Q(h,l,E,f,u,d,m,S,D,p,w){const M=d/D,R=m/p,U=d/2,N=m/2,G=S/2,T=D+1,V=p+1;let tA=0,z=0;const W=new rA;for(let Y=0;Y<V;Y++){const CA=Y*R-N;for(let K=0;K<T;K++){const AA=K*M-U;W[h]=AA*f,W[l]=CA*u,W[E]=G,r.push(W.x,W.y,W.z),W[h]=0,W[l]=0,W[E]=S>0?1:-1,g.push(W.x,W.y,W.z),C.push(K/D),C.push(1-Y/p),tA+=1}}for(let Y=0;Y<p;Y++)for(let CA=0;CA<D;CA++){const K=B+CA+T*Y,AA=B+CA+T*(Y+1),lA=B+(CA+1)+T*(Y+1),Z=B+(CA+1)+T*Y;I.push(K,AA,Z),I.push(AA,lA,Z),z+=6}s.addGroup(c,z,w),c+=z,B+=tA}}static fromJSON(A){return new ro(A.width,A.height,A.depth,A.widthSegments,A.heightSegments,A.depthSegments)}}function ts(i){const A={};for(const t in i){A[t]={};for(const e in i[t]){const n=i[t][e];n&&(n.isColor||n.isMatrix3||n.isMatrix4||n.isVector2||n.isVector3||n.isVector4||n.isTexture||n.isQuaternion)?A[t][e]=n.clone():Array.isArray(n)?A[t][e]=n.slice():A[t][e]=n}}return A}function $t(i){const A={};for(let t=0;t<i.length;t++){const e=ts(i[t]);for(const n in e)A[n]=e[n]}return A}function Nd(i){const A=[];for(let t=0;t<i.length;t++)A.push(i[t].clone());return A}const Ld={clone:ts,merge:$t};var bd=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Ud=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Pn extends ss{constructor(A){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=bd,this.fragmentShader=Ud,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,A!==void 0&&this.setValues(A)}copy(A){return super.copy(A),this.fragmentShader=A.fragmentShader,this.vertexShader=A.vertexShader,this.uniforms=ts(A.uniforms),this.uniformsGroups=Nd(A.uniformsGroups),this.defines=Object.assign({},A.defines),this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.fog=A.fog,this.lights=A.lights,this.clipping=A.clipping,this.extensions=Object.assign({},A.extensions),this.glslVersion=A.glslVersion,this}toJSON(A){const t=super.toJSON(A);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const o=this.uniforms[n].value;o&&o.isTexture?t.uniforms[n]={type:"t",value:o.toJSON(A).uuid}:o&&o.isColor?t.uniforms[n]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[n]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[n]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[n]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[n]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[n]={type:"m4",value:o.toArray()}:t.uniforms[n]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const e={};for(const n in this.extensions)this.extensions[n]===!0&&(e[n]=!0);return Object.keys(e).length>0&&(t.extensions=e),t}}class Kc extends vt{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new _t,this.projectionMatrix=new _t,this.projectionMatrixInverse=new _t}copy(A,t){return super.copy(A,t),this.matrixWorldInverse.copy(A.matrixWorldInverse),this.projectionMatrix.copy(A.projectionMatrix),this.projectionMatrixInverse.copy(A.projectionMatrixInverse),this}getWorldDirection(A){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return A.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(A){super.updateMatrixWorld(A),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(A,t){super.updateWorldMatrix(A,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class le extends Kc{constructor(A=50,t=1,e=.1,n=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=A,this.zoom=1,this.near=e,this.far=n,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(A,t){return super.copy(A,t),this.fov=A.fov,this.zoom=A.zoom,this.near=A.near,this.far=A.far,this.focus=A.focus,this.aspect=A.aspect,this.view=A.view===null?null:Object.assign({},A.view),this.filmGauge=A.filmGauge,this.filmOffset=A.filmOffset,this}setFocalLength(A){const t=.5*this.getFilmHeight()/A;this.fov=GI*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const A=Math.tan(jr*.5*this.fov);return .5*this.getFilmHeight()/A}getEffectiveFOV(){return GI*2*Math.atan(Math.tan(jr*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(A,t,e,n,a,o){this.aspect=A/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=A,this.view.fullHeight=t,this.view.offsetX=e,this.view.offsetY=n,this.view.width=a,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const A=this.near;let t=A*Math.tan(jr*.5*this.fov)/this.zoom,e=2*t,n=this.aspect*e,a=-.5*n;const o=this.view;if(this.view!==null&&this.view.enabled){const I=o.fullWidth,r=o.fullHeight;a+=o.offsetX*n/I,t-=o.offsetY*e/r,n*=o.width/I,e*=o.height/r}const s=this.filmOffset;s!==0&&(a+=A*s/this.getFilmWidth()),this.projectionMatrix.makePerspective(a,a+n,t,t-e,A,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(A){const t=super.toJSON(A);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Ea=90,Qa=1;class kd extends vt{constructor(A,t,e){super(),this.type="CubeCamera",this.renderTarget=e;const n=new le(Ea,Qa,A,t);n.layers=this.layers,n.up.set(0,-1,0),n.lookAt(new rA(1,0,0)),this.add(n);const a=new le(Ea,Qa,A,t);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new rA(-1,0,0)),this.add(a);const o=new le(Ea,Qa,A,t);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new rA(0,1,0)),this.add(o);const s=new le(Ea,Qa,A,t);s.layers=this.layers,s.up.set(0,0,-1),s.lookAt(new rA(0,-1,0)),this.add(s);const I=new le(Ea,Qa,A,t);I.layers=this.layers,I.up.set(0,-1,0),I.lookAt(new rA(0,0,1)),this.add(I);const r=new le(Ea,Qa,A,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new rA(0,0,-1)),this.add(r)}update(A,t){this.parent===null&&this.updateMatrixWorld();const e=this.renderTarget,[n,a,o,s,I,r]=this.children,g=A.getRenderTarget(),C=A.toneMapping,B=A.xr.enabled;A.toneMapping=Gi,A.xr.enabled=!1;const c=e.texture.generateMipmaps;e.texture.generateMipmaps=!1,A.setRenderTarget(e,0),A.render(t,n),A.setRenderTarget(e,1),A.render(t,a),A.setRenderTarget(e,2),A.render(t,o),A.setRenderTarget(e,3),A.render(t,s),A.setRenderTarget(e,4),A.render(t,I),e.texture.generateMipmaps=c,A.setRenderTarget(e,5),A.render(t,r),A.setRenderTarget(g),A.toneMapping=C,A.xr.enabled=B,e.texture.needsPMREMUpdate=!0}}class Oc extends we{constructor(A,t,e,n,a,o,s,I,r,g){A=A!==void 0?A:[],t=t!==void 0?t:ja,super(A,t,e,n,a,o,s,I,r,g),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(A){this.image=A}}class Td extends qn{constructor(A,t={}){super(A,A,t),this.isWebGLCubeRenderTarget=!0;const e={width:A,height:A,depth:1},n=[e,e,e,e,e,e];this.texture=new Oc(n,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Wt}fromEquirectangularTexture(A,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const e={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},n=new ro(5,5,5),a=new Pn({name:"CubemapFromEquirect",uniforms:ts(e.uniforms),vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,side:ve,blending:en});a.uniforms.tEquirect.value=t;const o=new wt(n,a),s=t.minFilter;return t.minFilter===ao&&(t.minFilter=Wt),new kd(1,10,this).update(A,o),t.minFilter=s,o.geometry.dispose(),o.material.dispose(),this}clear(A,t,e,n){const a=A.getRenderTarget();for(let o=0;o<6;o++)A.setRenderTarget(this,o),A.clear(t,e,n);A.setRenderTarget(a)}}const ug=new rA,Hd=new rA,qd=new Re;class pn{constructor(A=new rA(1,0,0),t=0){this.isPlane=!0,this.normal=A,this.constant=t}set(A,t){return this.normal.copy(A),this.constant=t,this}setComponents(A,t,e,n){return this.normal.set(A,t,e),this.constant=n,this}setFromNormalAndCoplanarPoint(A,t){return this.normal.copy(A),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(A,t,e){const n=ug.subVectors(e,t).cross(Hd.subVectors(A,t)).normalize();return this.setFromNormalAndCoplanarPoint(n,A),this}copy(A){return this.normal.copy(A.normal),this.constant=A.constant,this}normalize(){const A=1/this.normal.length();return this.normal.multiplyScalar(A),this.constant*=A,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(A){return this.normal.dot(A)+this.constant}distanceToSphere(A){return this.distanceToPoint(A.center)-A.radius}projectPoint(A,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(A)).add(A)}intersectLine(A,t){const e=A.delta(ug),n=this.normal.dot(e);if(n===0)return this.distanceToPoint(A.start)===0?t.copy(A.start):null;const a=-(A.start.dot(this.normal)+this.constant)/n;return a<0||a>1?null:t.copy(e).multiplyScalar(a).add(A.start)}intersectsLine(A){const t=this.distanceToPoint(A.start),e=this.distanceToPoint(A.end);return t<0&&e>0||e<0&&t>0}intersectsBox(A){return A.intersectsPlane(this)}intersectsSphere(A){return A.intersectsPlane(this)}coplanarPoint(A){return A.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(A,t){const e=t||qd.getNormalMatrix(A),n=this.coplanarPoint(ug).applyMatrix4(A),a=this.normal.applyMatrix3(e).normalize();return this.constant=-n.dot(a),this}translate(A){return this.constant-=A.dot(this.normal),this}equals(A){return A.normal.equals(this.normal)&&A.constant===this.constant}clone(){return new this.constructor().copy(this)}}const da=new cl,Uo=new rA;class El{constructor(A=new pn,t=new pn,e=new pn,n=new pn,a=new pn,o=new pn){this.planes=[A,t,e,n,a,o]}set(A,t,e,n,a,o){const s=this.planes;return s[0].copy(A),s[1].copy(t),s[2].copy(e),s[3].copy(n),s[4].copy(a),s[5].copy(o),this}copy(A){const t=this.planes;for(let e=0;e<6;e++)t[e].copy(A.planes[e]);return this}setFromProjectionMatrix(A){const t=this.planes,e=A.elements,n=e[0],a=e[1],o=e[2],s=e[3],I=e[4],r=e[5],g=e[6],C=e[7],B=e[8],c=e[9],Q=e[10],h=e[11],l=e[12],E=e[13],f=e[14],u=e[15];return t[0].setComponents(s-n,C-I,h-B,u-l).normalize(),t[1].setComponents(s+n,C+I,h+B,u+l).normalize(),t[2].setComponents(s+a,C+r,h+c,u+E).normalize(),t[3].setComponents(s-a,C-r,h-c,u-E).normalize(),t[4].setComponents(s-o,C-g,h-Q,u-f).normalize(),t[5].setComponents(s+o,C+g,h+Q,u+f).normalize(),this}intersectsObject(A){const t=A.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),da.copy(t.boundingSphere).applyMatrix4(A.matrixWorld),this.intersectsSphere(da)}intersectsSprite(A){return da.center.set(0,0,0),da.radius=.7071067811865476,da.applyMatrix4(A.matrixWorld),this.intersectsSphere(da)}intersectsSphere(A){const t=this.planes,e=A.center,n=-A.radius;for(let a=0;a<6;a++)if(t[a].distanceToPoint(e)<n)return!1;return!0}intersectsBox(A){const t=this.planes;for(let e=0;e<6;e++){const n=t[e];if(Uo.x=n.normal.x>0?A.max.x:A.min.x,Uo.y=n.normal.y>0?A.max.y:A.min.y,Uo.z=n.normal.z>0?A.max.z:A.min.z,n.distanceToPoint(Uo)<0)return!1}return!0}containsPoint(A){const t=this.planes;for(let e=0;e<6;e++)if(t[e].distanceToPoint(A)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Wc(){let i=null,A=!1,t=null,e=null;function n(a,o){t(a,o),e=i.requestAnimationFrame(n)}return{start:function(){A!==!0&&t!==null&&(e=i.requestAnimationFrame(n),A=!0)},stop:function(){i.cancelAnimationFrame(e),A=!1},setAnimationLoop:function(a){t=a},setContext:function(a){i=a}}}function Jd(i,A){const t=A.isWebGL2,e=new WeakMap;function n(r,g){const C=r.array,B=r.usage,c=i.createBuffer();i.bindBuffer(g,c),i.bufferData(g,C,B),r.onUploadCallback();let Q;if(C instanceof Float32Array)Q=5126;else if(C instanceof Uint16Array)if(r.isFloat16BufferAttribute)if(t)Q=5131;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else Q=5123;else if(C instanceof Int16Array)Q=5122;else if(C instanceof Uint32Array)Q=5125;else if(C instanceof Int32Array)Q=5124;else if(C instanceof Int8Array)Q=5120;else if(C instanceof Uint8Array)Q=5121;else if(C instanceof Uint8ClampedArray)Q=5121;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+C);return{buffer:c,type:Q,bytesPerElement:C.BYTES_PER_ELEMENT,version:r.version}}function a(r,g,C){const B=g.array,c=g.updateRange;i.bindBuffer(C,r),c.count===-1?i.bufferSubData(C,0,B):(t?i.bufferSubData(C,c.offset*B.BYTES_PER_ELEMENT,B,c.offset,c.count):i.bufferSubData(C,c.offset*B.BYTES_PER_ELEMENT,B.subarray(c.offset,c.offset+c.count)),c.count=-1)}function o(r){return r.isInterleavedBufferAttribute&&(r=r.data),e.get(r)}function s(r){r.isInterleavedBufferAttribute&&(r=r.data);const g=e.get(r);g&&(i.deleteBuffer(g.buffer),e.delete(r))}function I(r,g){if(r.isGLBufferAttribute){const B=e.get(r);(!B||B.version<r.version)&&e.set(r,{buffer:r.buffer,type:r.type,bytesPerElement:r.elementSize,version:r.version});return}r.isInterleavedBufferAttribute&&(r=r.data);const C=e.get(r);C===void 0?e.set(r,n(r,g)):C.version<r.version&&(a(C.buffer,r,g),C.version=r.version)}return{get:o,remove:s,update:I}}class Ql extends Cn{constructor(A=1,t=1,e=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:A,height:t,widthSegments:e,heightSegments:n};const a=A/2,o=t/2,s=Math.floor(e),I=Math.floor(n),r=s+1,g=I+1,C=A/s,B=t/I,c=[],Q=[],h=[],l=[];for(let E=0;E<g;E++){const f=E*B-o;for(let u=0;u<r;u++){const d=u*C-a;Q.push(d,-f,0),h.push(0,0,1),l.push(u/s),l.push(1-E/I)}}for(let E=0;E<I;E++)for(let f=0;f<s;f++){const u=f+r*E,d=f+r*(E+1),m=f+1+r*(E+1),S=f+1+r*E;c.push(u,d,S),c.push(d,m,S)}this.setIndex(c),this.setAttribute("position",new ri(Q,3)),this.setAttribute("normal",new ri(h,3)),this.setAttribute("uv",new ri(l,2))}static fromJSON(A){return new Ql(A.width,A.height,A.widthSegments,A.heightSegments)}}var Pd=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,Yd=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Kd=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,Od=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,Wd=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,Vd=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,zd="vec3 transformed = vec3( position );",Xd=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,Zd=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,jd=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,$d=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Af=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,tf=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,ef=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,nf=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,af=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,sf=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,of=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,rf=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,gf=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,If=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,lf=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Cf=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Bf=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,hf=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,cf=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Ef="gl_FragColor = linearToOutputTexel( gl_FragColor );",Qf=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,df=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,ff=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,uf=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,pf=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,mf=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,yf=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,Df=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Sf=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,wf=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,_f=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,xf=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,Mf=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Ff=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Rf=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert
#define Material_LightProbeLOD( material )	(0)`,vf=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Gf=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,Nf=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Lf=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,bf=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,Uf=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,kf=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,Tf=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,Hf=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,qf=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,Jf=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,Pf=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,Yf=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Kf=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,Of=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,Wf=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,Vf=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,zf=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,Xf=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Zf=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,jf=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,$f=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,Au=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,tu=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,eu=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,iu=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,nu=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,au=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,su=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,ou=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,ru=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,gu=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,Iu=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,lu=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Cu=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,Bu=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,hu=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,cu=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Eu=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Qu=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,du=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,fu=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,uu=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,pu=`#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,mu=`#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,yu=`#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Du=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Su=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,wu=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,_u=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,xu=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Mu=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Fu=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Ru=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,vu=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Gu=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,Nu=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,Lu=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,bu=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,Uu=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,ku=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,Tu=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,Hu=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,qu=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Ju=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,Pu=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Yu=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Ku=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Ou=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Wu=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,Vu=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,zu=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,Xu=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,Zu=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,ju=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,$u=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Ap=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,tp=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,ep=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,ip=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,np=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,ap=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,sp=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,op=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,rp=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,gp=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ip=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,lp=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Cp=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Bp=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,hp=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,cp=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Ep=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Qp=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,dp=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fp=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,At={alphamap_fragment:Pd,alphamap_pars_fragment:Yd,alphatest_fragment:Kd,alphatest_pars_fragment:Od,aomap_fragment:Wd,aomap_pars_fragment:Vd,begin_vertex:zd,beginnormal_vertex:Xd,bsdfs:Zd,iridescence_fragment:jd,bumpmap_pars_fragment:$d,clipping_planes_fragment:Af,clipping_planes_pars_fragment:tf,clipping_planes_pars_vertex:ef,clipping_planes_vertex:nf,color_fragment:af,color_pars_fragment:sf,color_pars_vertex:of,color_vertex:rf,common:gf,cube_uv_reflection_fragment:If,defaultnormal_vertex:lf,displacementmap_pars_vertex:Cf,displacementmap_vertex:Bf,emissivemap_fragment:hf,emissivemap_pars_fragment:cf,encodings_fragment:Ef,encodings_pars_fragment:Qf,envmap_fragment:df,envmap_common_pars_fragment:ff,envmap_pars_fragment:uf,envmap_pars_vertex:pf,envmap_physical_pars_fragment:Gf,envmap_vertex:mf,fog_vertex:yf,fog_pars_vertex:Df,fog_fragment:Sf,fog_pars_fragment:wf,gradientmap_pars_fragment:_f,lightmap_fragment:xf,lightmap_pars_fragment:Mf,lights_lambert_fragment:Ff,lights_lambert_pars_fragment:Rf,lights_pars_begin:vf,lights_toon_fragment:Nf,lights_toon_pars_fragment:Lf,lights_phong_fragment:bf,lights_phong_pars_fragment:Uf,lights_physical_fragment:kf,lights_physical_pars_fragment:Tf,lights_fragment_begin:Hf,lights_fragment_maps:qf,lights_fragment_end:Jf,logdepthbuf_fragment:Pf,logdepthbuf_pars_fragment:Yf,logdepthbuf_pars_vertex:Kf,logdepthbuf_vertex:Of,map_fragment:Wf,map_pars_fragment:Vf,map_particle_fragment:zf,map_particle_pars_fragment:Xf,metalnessmap_fragment:Zf,metalnessmap_pars_fragment:jf,morphcolor_vertex:$f,morphnormal_vertex:Au,morphtarget_pars_vertex:tu,morphtarget_vertex:eu,normal_fragment_begin:iu,normal_fragment_maps:nu,normal_pars_fragment:au,normal_pars_vertex:su,normal_vertex:ou,normalmap_pars_fragment:ru,clearcoat_normal_fragment_begin:gu,clearcoat_normal_fragment_maps:Iu,clearcoat_pars_fragment:lu,iridescence_pars_fragment:Cu,output_fragment:Bu,packing:hu,premultiplied_alpha_fragment:cu,project_vertex:Eu,dithering_fragment:Qu,dithering_pars_fragment:du,roughnessmap_fragment:fu,roughnessmap_pars_fragment:uu,shadowmap_pars_fragment:pu,shadowmap_pars_vertex:mu,shadowmap_vertex:yu,shadowmask_pars_fragment:Du,skinbase_vertex:Su,skinning_pars_vertex:wu,skinning_vertex:_u,skinnormal_vertex:xu,specularmap_fragment:Mu,specularmap_pars_fragment:Fu,tonemapping_fragment:Ru,tonemapping_pars_fragment:vu,transmission_fragment:Gu,transmission_pars_fragment:Nu,uv_pars_fragment:Lu,uv_pars_vertex:bu,uv_vertex:Uu,uv2_pars_fragment:ku,uv2_pars_vertex:Tu,uv2_vertex:Hu,worldpos_vertex:qu,background_vert:Ju,background_frag:Pu,cube_vert:Yu,cube_frag:Ku,depth_vert:Ou,depth_frag:Wu,distanceRGBA_vert:Vu,distanceRGBA_frag:zu,equirect_vert:Xu,equirect_frag:Zu,linedashed_vert:ju,linedashed_frag:$u,meshbasic_vert:Ap,meshbasic_frag:tp,meshlambert_vert:ep,meshlambert_frag:ip,meshmatcap_vert:np,meshmatcap_frag:ap,meshnormal_vert:sp,meshnormal_frag:op,meshphong_vert:rp,meshphong_frag:gp,meshphysical_vert:Ip,meshphysical_frag:lp,meshtoon_vert:Cp,meshtoon_frag:Bp,points_vert:hp,points_frag:cp,shadow_vert:Ep,shadow_frag:Qp,sprite_vert:dp,sprite_frag:fp},vA={common:{diffuse:{value:new st(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Re},uv2Transform:{value:new Re},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new XA(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new st(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new st(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Re}},sprite:{diffuse:{value:new st(16777215)},opacity:{value:1},center:{value:new XA(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Re}}},Ai={basic:{uniforms:$t([vA.common,vA.specularmap,vA.envmap,vA.aomap,vA.lightmap,vA.fog]),vertexShader:At.meshbasic_vert,fragmentShader:At.meshbasic_frag},lambert:{uniforms:$t([vA.common,vA.specularmap,vA.envmap,vA.aomap,vA.lightmap,vA.emissivemap,vA.bumpmap,vA.normalmap,vA.displacementmap,vA.fog,vA.lights,{emissive:{value:new st(0)}}]),vertexShader:At.meshlambert_vert,fragmentShader:At.meshlambert_frag},phong:{uniforms:$t([vA.common,vA.specularmap,vA.envmap,vA.aomap,vA.lightmap,vA.emissivemap,vA.bumpmap,vA.normalmap,vA.displacementmap,vA.fog,vA.lights,{emissive:{value:new st(0)},specular:{value:new st(1118481)},shininess:{value:30}}]),vertexShader:At.meshphong_vert,fragmentShader:At.meshphong_frag},standard:{uniforms:$t([vA.common,vA.envmap,vA.aomap,vA.lightmap,vA.emissivemap,vA.bumpmap,vA.normalmap,vA.displacementmap,vA.roughnessmap,vA.metalnessmap,vA.fog,vA.lights,{emissive:{value:new st(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:At.meshphysical_vert,fragmentShader:At.meshphysical_frag},toon:{uniforms:$t([vA.common,vA.aomap,vA.lightmap,vA.emissivemap,vA.bumpmap,vA.normalmap,vA.displacementmap,vA.gradientmap,vA.fog,vA.lights,{emissive:{value:new st(0)}}]),vertexShader:At.meshtoon_vert,fragmentShader:At.meshtoon_frag},matcap:{uniforms:$t([vA.common,vA.bumpmap,vA.normalmap,vA.displacementmap,vA.fog,{matcap:{value:null}}]),vertexShader:At.meshmatcap_vert,fragmentShader:At.meshmatcap_frag},points:{uniforms:$t([vA.points,vA.fog]),vertexShader:At.points_vert,fragmentShader:At.points_frag},dashed:{uniforms:$t([vA.common,vA.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:At.linedashed_vert,fragmentShader:At.linedashed_frag},depth:{uniforms:$t([vA.common,vA.displacementmap]),vertexShader:At.depth_vert,fragmentShader:At.depth_frag},normal:{uniforms:$t([vA.common,vA.bumpmap,vA.normalmap,vA.displacementmap,{opacity:{value:1}}]),vertexShader:At.meshnormal_vert,fragmentShader:At.meshnormal_frag},sprite:{uniforms:$t([vA.sprite,vA.fog]),vertexShader:At.sprite_vert,fragmentShader:At.sprite_frag},background:{uniforms:{uvTransform:{value:new Re},t2D:{value:null}},vertexShader:At.background_vert,fragmentShader:At.background_frag},cube:{uniforms:$t([vA.envmap,{opacity:{value:1}}]),vertexShader:At.cube_vert,fragmentShader:At.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:At.equirect_vert,fragmentShader:At.equirect_frag},distanceRGBA:{uniforms:$t([vA.common,vA.displacementmap,{referencePosition:{value:new rA},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:At.distanceRGBA_vert,fragmentShader:At.distanceRGBA_frag},shadow:{uniforms:$t([vA.lights,vA.fog,{color:{value:new st(0)},opacity:{value:1}}]),vertexShader:At.shadow_vert,fragmentShader:At.shadow_frag}};Ai.physical={uniforms:$t([Ai.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new XA(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new st(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new XA},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new st(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new st(1,1,1)},specularColorMap:{value:null}}]),vertexShader:At.meshphysical_vert,fragmentShader:At.meshphysical_frag};function up(i,A,t,e,n,a){const o=new st(0);let s=n===!0?0:1,I,r,g=null,C=0,B=null;function c(h,l){let E=!1,f=l.isScene===!0?l.background:null;f&&f.isTexture&&(f=A.get(f));const u=i.xr,d=u.getSession&&u.getSession();d&&d.environmentBlendMode==="additive"&&(f=null),f===null?Q(o,s):f&&f.isColor&&(Q(f,1),E=!0),(i.autoClear||E)&&i.clear(i.autoClearColor,i.autoClearDepth,i.autoClearStencil),f&&(f.isCubeTexture||f.mapping===br)?(r===void 0&&(r=new wt(new ro(1,1,1),new Pn({name:"BackgroundCubeMaterial",uniforms:ts(Ai.cube.uniforms),vertexShader:Ai.cube.vertexShader,fragmentShader:Ai.cube.fragmentShader,side:ve,depthTest:!1,depthWrite:!1,fog:!1})),r.geometry.deleteAttribute("normal"),r.geometry.deleteAttribute("uv"),r.onBeforeRender=function(m,S,D){this.matrixWorld.copyPosition(D.matrixWorld)},Object.defineProperty(r.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),e.update(r)),r.material.uniforms.envMap.value=f,r.material.uniforms.flipEnvMap.value=f.isCubeTexture&&f.isRenderTargetTexture===!1?-1:1,(g!==f||C!==f.version||B!==i.toneMapping)&&(r.material.needsUpdate=!0,g=f,C=f.version,B=i.toneMapping),r.layers.enableAll(),h.unshift(r,r.geometry,r.material,0,0,null)):f&&f.isTexture&&(I===void 0&&(I=new wt(new Ql(2,2),new Pn({name:"BackgroundMaterial",uniforms:ts(Ai.background.uniforms),vertexShader:Ai.background.vertexShader,fragmentShader:Ai.background.fragmentShader,side:Za,depthTest:!1,depthWrite:!1,fog:!1})),I.geometry.deleteAttribute("normal"),Object.defineProperty(I.material,"map",{get:function(){return this.uniforms.t2D.value}}),e.update(I)),I.material.uniforms.t2D.value=f,f.matrixAutoUpdate===!0&&f.updateMatrix(),I.material.uniforms.uvTransform.value.copy(f.matrix),(g!==f||C!==f.version||B!==i.toneMapping)&&(I.material.needsUpdate=!0,g=f,C=f.version,B=i.toneMapping),I.layers.enableAll(),h.unshift(I,I.geometry,I.material,0,0,null))}function Q(h,l){t.buffers.color.setClear(h.r,h.g,h.b,l,a)}return{getClearColor:function(){return o},setClearColor:function(h,l=1){o.set(h),s=l,Q(o,s)},getClearAlpha:function(){return s},setClearAlpha:function(h){s=h,Q(o,s)},render:c}}function pp(i,A,t,e){const n=i.getParameter(34921),a=e.isWebGL2?null:A.get("OES_vertex_array_object"),o=e.isWebGL2||a!==null,s={},I=l(null);let r=I,g=!1;function C(G,T,V,tA,z){let W=!1;if(o){const Y=h(tA,V,T);r!==Y&&(r=Y,c(r.object)),W=E(G,tA,V,z),W&&f(G,tA,V,z)}else{const Y=T.wireframe===!0;(r.geometry!==tA.id||r.program!==V.id||r.wireframe!==Y)&&(r.geometry=tA.id,r.program=V.id,r.wireframe=Y,W=!0)}z!==null&&t.update(z,34963),(W||g)&&(g=!1,p(G,T,V,tA),z!==null&&i.bindBuffer(34963,t.get(z).buffer))}function B(){return e.isWebGL2?i.createVertexArray():a.createVertexArrayOES()}function c(G){return e.isWebGL2?i.bindVertexArray(G):a.bindVertexArrayOES(G)}function Q(G){return e.isWebGL2?i.deleteVertexArray(G):a.deleteVertexArrayOES(G)}function h(G,T,V){const tA=V.wireframe===!0;let z=s[G.id];z===void 0&&(z={},s[G.id]=z);let W=z[T.id];W===void 0&&(W={},z[T.id]=W);let Y=W[tA];return Y===void 0&&(Y=l(B()),W[tA]=Y),Y}function l(G){const T=[],V=[],tA=[];for(let z=0;z<n;z++)T[z]=0,V[z]=0,tA[z]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:T,enabledAttributes:V,attributeDivisors:tA,object:G,attributes:{},index:null}}function E(G,T,V,tA){const z=r.attributes,W=T.attributes;let Y=0;const CA=V.getAttributes();for(const K in CA)if(CA[K].location>=0){const lA=z[K];let Z=W[K];if(Z===void 0&&(K==="instanceMatrix"&&G.instanceMatrix&&(Z=G.instanceMatrix),K==="instanceColor"&&G.instanceColor&&(Z=G.instanceColor)),lA===void 0||lA.attribute!==Z||Z&&lA.data!==Z.data)return!0;Y++}return r.attributesNum!==Y||r.index!==tA}function f(G,T,V,tA){const z={},W=T.attributes;let Y=0;const CA=V.getAttributes();for(const K in CA)if(CA[K].location>=0){let lA=W[K];lA===void 0&&(K==="instanceMatrix"&&G.instanceMatrix&&(lA=G.instanceMatrix),K==="instanceColor"&&G.instanceColor&&(lA=G.instanceColor));const Z={};Z.attribute=lA,lA&&lA.data&&(Z.data=lA.data),z[K]=Z,Y++}r.attributes=z,r.attributesNum=Y,r.index=tA}function u(){const G=r.newAttributes;for(let T=0,V=G.length;T<V;T++)G[T]=0}function d(G){m(G,0)}function m(G,T){const V=r.newAttributes,tA=r.enabledAttributes,z=r.attributeDivisors;V[G]=1,tA[G]===0&&(i.enableVertexAttribArray(G),tA[G]=1),z[G]!==T&&((e.isWebGL2?i:A.get("ANGLE_instanced_arrays"))[e.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](G,T),z[G]=T)}function S(){const G=r.newAttributes,T=r.enabledAttributes;for(let V=0,tA=T.length;V<tA;V++)T[V]!==G[V]&&(i.disableVertexAttribArray(V),T[V]=0)}function D(G,T,V,tA,z,W){e.isWebGL2===!0&&(V===5124||V===5125)?i.vertexAttribIPointer(G,T,V,z,W):i.vertexAttribPointer(G,T,V,tA,z,W)}function p(G,T,V,tA){if(e.isWebGL2===!1&&(G.isInstancedMesh||tA.isInstancedBufferGeometry)&&A.get("ANGLE_instanced_arrays")===null)return;u();const z=tA.attributes,W=V.getAttributes(),Y=T.defaultAttributeValues;for(const CA in W){const K=W[CA];if(K.location>=0){let AA=z[CA];if(AA===void 0&&(CA==="instanceMatrix"&&G.instanceMatrix&&(AA=G.instanceMatrix),CA==="instanceColor"&&G.instanceColor&&(AA=G.instanceColor)),AA!==void 0){const lA=AA.normalized,Z=AA.itemSize,oA=t.get(AA);if(oA===void 0)continue;const wA=oA.buffer,uA=oA.type,mA=oA.bytesPerElement;if(AA.isInterleavedBufferAttribute){const fA=AA.data,RA=fA.stride,MA=AA.offset;if(fA.isInstancedInterleavedBuffer){for(let SA=0;SA<K.locationSize;SA++)m(K.location+SA,fA.meshPerAttribute);G.isInstancedMesh!==!0&&tA._maxInstanceCount===void 0&&(tA._maxInstanceCount=fA.meshPerAttribute*fA.count)}else for(let SA=0;SA<K.locationSize;SA++)d(K.location+SA);i.bindBuffer(34962,wA);for(let SA=0;SA<K.locationSize;SA++)D(K.location+SA,Z/K.locationSize,uA,lA,RA*mA,(MA+Z/K.locationSize*SA)*mA)}else{if(AA.isInstancedBufferAttribute){for(let fA=0;fA<K.locationSize;fA++)m(K.location+fA,AA.meshPerAttribute);G.isInstancedMesh!==!0&&tA._maxInstanceCount===void 0&&(tA._maxInstanceCount=AA.meshPerAttribute*AA.count)}else for(let fA=0;fA<K.locationSize;fA++)d(K.location+fA);i.bindBuffer(34962,wA);for(let fA=0;fA<K.locationSize;fA++)D(K.location+fA,Z/K.locationSize,uA,lA,Z*mA,Z/K.locationSize*fA*mA)}}else if(Y!==void 0){const lA=Y[CA];if(lA!==void 0)switch(lA.length){case 2:i.vertexAttrib2fv(K.location,lA);break;case 3:i.vertexAttrib3fv(K.location,lA);break;case 4:i.vertexAttrib4fv(K.location,lA);break;default:i.vertexAttrib1fv(K.location,lA)}}}}S()}function w(){U();for(const G in s){const T=s[G];for(const V in T){const tA=T[V];for(const z in tA)Q(tA[z].object),delete tA[z];delete T[V]}delete s[G]}}function M(G){if(s[G.id]===void 0)return;const T=s[G.id];for(const V in T){const tA=T[V];for(const z in tA)Q(tA[z].object),delete tA[z];delete T[V]}delete s[G.id]}function R(G){for(const T in s){const V=s[T];if(V[G.id]===void 0)continue;const tA=V[G.id];for(const z in tA)Q(tA[z].object),delete tA[z];delete V[G.id]}}function U(){N(),g=!0,r!==I&&(r=I,c(r.object))}function N(){I.geometry=null,I.program=null,I.wireframe=!1}return{setup:C,reset:U,resetDefaultState:N,dispose:w,releaseStatesOfGeometry:M,releaseStatesOfProgram:R,initAttributes:u,enableAttribute:d,disableUnusedAttributes:S}}function mp(i,A,t,e){const n=e.isWebGL2;let a;function o(r){a=r}function s(r,g){i.drawArrays(a,r,g),t.update(g,a,1)}function I(r,g,C){if(C===0)return;let B,c;if(n)B=i,c="drawArraysInstanced";else if(B=A.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",B===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}B[c](a,r,g,C),t.update(g,a,C)}this.setMode=o,this.render=s,this.renderInstances=I}function yp(i,A,t){let e;function n(){if(e!==void 0)return e;if(A.has("EXT_texture_filter_anisotropic")===!0){const D=A.get("EXT_texture_filter_anisotropic");e=i.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else e=0;return e}function a(D){if(D==="highp"){if(i.getShaderPrecisionFormat(35633,36338).precision>0&&i.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";D="mediump"}return D==="mediump"&&i.getShaderPrecisionFormat(35633,36337).precision>0&&i.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&i instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&i instanceof WebGL2ComputeRenderingContext;let s=t.precision!==void 0?t.precision:"highp";const I=a(s);I!==s&&(console.warn("THREE.WebGLRenderer:",s,"not supported, using",I,"instead."),s=I);const r=o||A.has("WEBGL_draw_buffers"),g=t.logarithmicDepthBuffer===!0,C=i.getParameter(34930),B=i.getParameter(35660),c=i.getParameter(3379),Q=i.getParameter(34076),h=i.getParameter(34921),l=i.getParameter(36347),E=i.getParameter(36348),f=i.getParameter(36349),u=B>0,d=o||A.has("OES_texture_float"),m=u&&d,S=o?i.getParameter(36183):0;return{isWebGL2:o,drawBuffers:r,getMaxAnisotropy:n,getMaxPrecision:a,precision:s,logarithmicDepthBuffer:g,maxTextures:C,maxVertexTextures:B,maxTextureSize:c,maxCubemapSize:Q,maxAttributes:h,maxVertexUniforms:l,maxVaryings:E,maxFragmentUniforms:f,vertexTextures:u,floatFragmentTextures:d,floatVertexTextures:m,maxSamples:S}}function Dp(i){const A=this;let t=null,e=0,n=!1,a=!1;const o=new pn,s=new Re,I={value:null,needsUpdate:!1};this.uniform=I,this.numPlanes=0,this.numIntersection=0,this.init=function(C,B,c){const Q=C.length!==0||B||e!==0||n;return n=B,t=g(C,c,0),e=C.length,Q},this.beginShadows=function(){a=!0,g(null)},this.endShadows=function(){a=!1,r()},this.setState=function(C,B,c){const Q=C.clippingPlanes,h=C.clipIntersection,l=C.clipShadows,E=i.get(C);if(!n||Q===null||Q.length===0||a&&!l)a?g(null):r();else{const f=a?0:e,u=f*4;let d=E.clippingState||null;I.value=d,d=g(Q,B,u,c);for(let m=0;m!==u;++m)d[m]=t[m];E.clippingState=d,this.numIntersection=h?this.numPlanes:0,this.numPlanes+=f}};function r(){I.value!==t&&(I.value=t,I.needsUpdate=e>0),A.numPlanes=e,A.numIntersection=0}function g(C,B,c,Q){const h=C!==null?C.length:0;let l=null;if(h!==0){if(l=I.value,Q!==!0||l===null){const E=c+h*4,f=B.matrixWorldInverse;s.getNormalMatrix(f),(l===null||l.length<E)&&(l=new Float32Array(E));for(let u=0,d=c;u!==h;++u,d+=4)o.copy(C[u]).applyMatrix4(f,s),o.normal.toArray(l,d),l[d+3]=o.constant}I.value=l,I.needsUpdate=!0}return A.numPlanes=h,A.numIntersection=0,l}}function Sp(i){let A=new WeakMap;function t(o,s){return s===FI?o.mapping=ja:s===RI&&(o.mapping=$a),o}function e(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const s=o.mapping;if(s===FI||s===RI)if(A.has(o)){const I=A.get(o).texture;return t(I,o.mapping)}else{const I=o.image;if(I&&I.height>0){const r=new Td(I.height/2);return r.fromEquirectangularTexture(i,o),A.set(o,r),o.addEventListener("dispose",n),t(r.texture,o.mapping)}else return null}}return o}function n(o){const s=o.target;s.removeEventListener("dispose",n);const I=A.get(s);I!==void 0&&(A.delete(s),I.dispose())}function a(){A=new WeakMap}return{get:e,dispose:a}}class Vc extends Kc{constructor(A=-1,t=1,e=1,n=-1,a=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=A,this.right=t,this.top=e,this.bottom=n,this.near=a,this.far=o,this.updateProjectionMatrix()}copy(A,t){return super.copy(A,t),this.left=A.left,this.right=A.right,this.top=A.top,this.bottom=A.bottom,this.near=A.near,this.far=A.far,this.zoom=A.zoom,this.view=A.view===null?null:Object.assign({},A.view),this}setViewOffset(A,t,e,n,a,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=A,this.view.fullHeight=t,this.view.offsetX=e,this.view.offsetY=n,this.view.width=a,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const A=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),e=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let a=e-A,o=e+A,s=n+t,I=n-t;if(this.view!==null&&this.view.enabled){const r=(this.right-this.left)/this.view.fullWidth/this.zoom,g=(this.top-this.bottom)/this.view.fullHeight/this.zoom;a+=r*this.view.offsetX,o=a+r*this.view.width,s-=g*this.view.offsetY,I=s-g*this.view.height}this.projectionMatrix.makeOrthographic(a,o,s,I,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(A){const t=super.toJSON(A);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const Ha=4,RC=[.125,.215,.35,.446,.526,.582],_n=20,pg=new Vc,vC=new st;let mg=null;const mn=(1+Math.sqrt(5))/2,fa=1/mn,GC=[new rA(1,1,1),new rA(-1,1,1),new rA(1,1,-1),new rA(-1,1,-1),new rA(0,mn,fa),new rA(0,mn,-fa),new rA(fa,0,mn),new rA(-fa,0,mn),new rA(mn,fa,0),new rA(-mn,fa,0)];class NC{constructor(A){this._renderer=A,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(A,t=0,e=.1,n=100){mg=this._renderer.getRenderTarget(),this._setSize(256);const a=this._allocateTargets();return a.depthBuffer=!0,this._sceneToCubeUV(A,e,n,a),t>0&&this._blur(a,0,0,t),this._applyPMREM(a),this._cleanup(a),a}fromEquirectangular(A,t=null){return this._fromTexture(A,t)}fromCubemap(A,t=null){return this._fromTexture(A,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=UC(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=bC(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(A){this._lodMax=Math.floor(Math.log2(A)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let A=0;A<this._lodPlanes.length;A++)this._lodPlanes[A].dispose()}_cleanup(A){this._renderer.setRenderTarget(mg),A.scissorTest=!1,ko(A,0,0,A.width,A.height)}_fromTexture(A,t){A.mapping===ja||A.mapping===$a?this._setSize(A.image.length===0?16:A.image[0].width||A.image[0].image.width):this._setSize(A.image.width/4),mg=this._renderer.getRenderTarget();const e=t||this._allocateTargets();return this._textureToCubeUV(A,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(){const A=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,e={magFilter:Wt,minFilter:Wt,generateMipmaps:!1,type:Ri,format:ai,encoding:gn,depthBuffer:!1},n=LC(A,t,e);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==A){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=LC(A,t,e);const{_lodMax:a}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=wp(a)),this._blurMaterial=_p(a,A,t)}return n}_compileMaterial(A){const t=new wt(this._lodPlanes[0],A);this._renderer.compile(t,pg)}_sceneToCubeUV(A,t,e,n){const s=new le(90,1,t,e),I=[1,-1,1,1,1,1],r=[1,1,1,-1,-1,-1],g=this._renderer,C=g.autoClear,B=g.toneMapping;g.getClearColor(vC),g.toneMapping=Gi,g.autoClear=!1;const c=new nn({name:"PMREM.Background",side:ve,depthWrite:!1,depthTest:!1}),Q=new wt(new ro,c);let h=!1;const l=A.background;l?l.isColor&&(c.color.copy(l),A.background=null,h=!0):(c.color.copy(vC),h=!0);for(let E=0;E<6;E++){const f=E%3;f===0?(s.up.set(0,I[E],0),s.lookAt(r[E],0,0)):f===1?(s.up.set(0,0,I[E]),s.lookAt(0,r[E],0)):(s.up.set(0,I[E],0),s.lookAt(0,0,r[E]));const u=this._cubeSize;ko(n,f*u,E>2?u:0,u,u),g.setRenderTarget(n),h&&g.render(Q,s),g.render(A,s)}Q.geometry.dispose(),Q.material.dispose(),g.toneMapping=B,g.autoClear=C,A.background=l}_textureToCubeUV(A,t){const e=this._renderer,n=A.mapping===ja||A.mapping===$a;n?(this._cubemapMaterial===null&&(this._cubemapMaterial=UC()),this._cubemapMaterial.uniforms.flipEnvMap.value=A.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=bC());const a=n?this._cubemapMaterial:this._equirectMaterial,o=new wt(this._lodPlanes[0],a),s=a.uniforms;s.envMap.value=A;const I=this._cubeSize;ko(t,0,0,3*I,2*I),e.setRenderTarget(t),e.render(o,pg)}_applyPMREM(A){const t=this._renderer,e=t.autoClear;t.autoClear=!1;for(let n=1;n<this._lodPlanes.length;n++){const a=Math.sqrt(this._sigmas[n]*this._sigmas[n]-this._sigmas[n-1]*this._sigmas[n-1]),o=GC[(n-1)%GC.length];this._blur(A,n-1,n,a,o)}t.autoClear=e}_blur(A,t,e,n,a){const o=this._pingPongRenderTarget;this._halfBlur(A,o,t,e,n,"latitudinal",a),this._halfBlur(o,A,e,e,n,"longitudinal",a)}_halfBlur(A,t,e,n,a,o,s){const I=this._renderer,r=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const g=3,C=new wt(this._lodPlanes[n],r),B=r.uniforms,c=this._sizeLods[e]-1,Q=isFinite(a)?Math.PI/(2*c):2*Math.PI/(2*_n-1),h=a/Q,l=isFinite(a)?1+Math.floor(g*h):_n;l>_n&&console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${l} samples when the maximum is set to ${_n}`);const E=[];let f=0;for(let D=0;D<_n;++D){const p=D/h,w=Math.exp(-p*p/2);E.push(w),D===0?f+=w:D<l&&(f+=2*w)}for(let D=0;D<E.length;D++)E[D]=E[D]/f;B.envMap.value=A.texture,B.samples.value=l,B.weights.value=E,B.latitudinal.value=o==="latitudinal",s&&(B.poleAxis.value=s);const{_lodMax:u}=this;B.dTheta.value=Q,B.mipInt.value=u-e;const d=this._sizeLods[n],m=3*d*(n>u-Ha?n-u+Ha:0),S=4*(this._cubeSize-d);ko(t,m,S,3*d,2*d),I.setRenderTarget(t),I.render(C,pg)}}function wp(i){const A=[],t=[],e=[];let n=i;const a=i-Ha+1+RC.length;for(let o=0;o<a;o++){const s=Math.pow(2,n);t.push(s);let I=1/s;o>i-Ha?I=RC[o-i+Ha-1]:o===0&&(I=0),e.push(I);const r=1/(s-2),g=-r,C=1+r,B=[g,g,C,g,C,C,g,g,C,C,g,C],c=6,Q=6,h=3,l=2,E=1,f=new Float32Array(h*Q*c),u=new Float32Array(l*Q*c),d=new Float32Array(E*Q*c);for(let S=0;S<c;S++){const D=S%3*2/3-1,p=S>2?0:-1,w=[D,p,0,D+2/3,p,0,D+2/3,p+1,0,D,p,0,D+2/3,p+1,0,D,p+1,0];f.set(w,h*Q*S),u.set(B,l*Q*S);const M=[S,S,S,S,S,S];d.set(M,E*Q*S)}const m=new Cn;m.setAttribute("position",new oi(f,h)),m.setAttribute("uv",new oi(u,l)),m.setAttribute("faceIndex",new oi(d,E)),A.push(m),n>Ha&&n--}return{lodPlanes:A,sizeLods:t,sigmas:e}}function LC(i,A,t){const e=new qn(i,A,t);return e.texture.mapping=br,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function ko(i,A,t,e,n){i.viewport.set(A,t,e,n),i.scissor.set(A,t,e,n)}function _p(i,A,t){const e=new Float32Array(_n),n=new rA(0,1,0);return new Pn({name:"SphericalGaussianBlur",defines:{n:_n,CUBEUV_TEXEL_WIDTH:1/A,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${i}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n}},vertexShader:dl(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:en,depthTest:!1,depthWrite:!1})}function bC(){return new Pn({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:dl(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:en,depthTest:!1,depthWrite:!1})}function UC(){return new Pn({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:dl(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:en,depthTest:!1,depthWrite:!1})}function dl(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function xp(i){let A=new WeakMap,t=null;function e(s){if(s&&s.isTexture){const I=s.mapping,r=I===FI||I===RI,g=I===ja||I===$a;if(r||g)if(s.isRenderTargetTexture&&s.needsPMREMUpdate===!0){s.needsPMREMUpdate=!1;let C=A.get(s);return t===null&&(t=new NC(i)),C=r?t.fromEquirectangular(s,C):t.fromCubemap(s,C),A.set(s,C),C.texture}else{if(A.has(s))return A.get(s).texture;{const C=s.image;if(r&&C&&C.height>0||g&&C&&n(C)){t===null&&(t=new NC(i));const B=r?t.fromEquirectangular(s):t.fromCubemap(s);return A.set(s,B),s.addEventListener("dispose",a),B.texture}else return null}}}return s}function n(s){let I=0;const r=6;for(let g=0;g<r;g++)s[g]!==void 0&&I++;return I===r}function a(s){const I=s.target;I.removeEventListener("dispose",a);const r=A.get(I);r!==void 0&&(A.delete(I),r.dispose())}function o(){A=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:e,dispose:o}}function Mp(i){const A={};function t(e){if(A[e]!==void 0)return A[e];let n;switch(e){case"WEBGL_depth_texture":n=i.getExtension("WEBGL_depth_texture")||i.getExtension("MOZ_WEBGL_depth_texture")||i.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=i.getExtension("EXT_texture_filter_anisotropic")||i.getExtension("MOZ_EXT_texture_filter_anisotropic")||i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=i.getExtension("WEBGL_compressed_texture_s3tc")||i.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=i.getExtension("WEBGL_compressed_texture_pvrtc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=i.getExtension(e)}return A[e]=n,n}return{has:function(e){return t(e)!==null},init:function(e){e.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(e){const n=t(e);return n===null&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),n}}}function Fp(i,A,t,e){const n={},a=new WeakMap;function o(C){const B=C.target;B.index!==null&&A.remove(B.index);for(const Q in B.attributes)A.remove(B.attributes[Q]);B.removeEventListener("dispose",o),delete n[B.id];const c=a.get(B);c&&(A.remove(c),a.delete(B)),e.releaseStatesOfGeometry(B),B.isInstancedBufferGeometry===!0&&delete B._maxInstanceCount,t.memory.geometries--}function s(C,B){return n[B.id]===!0||(B.addEventListener("dispose",o),n[B.id]=!0,t.memory.geometries++),B}function I(C){const B=C.attributes;for(const Q in B)A.update(B[Q],34962);const c=C.morphAttributes;for(const Q in c){const h=c[Q];for(let l=0,E=h.length;l<E;l++)A.update(h[l],34962)}}function r(C){const B=[],c=C.index,Q=C.attributes.position;let h=0;if(c!==null){const f=c.array;h=c.version;for(let u=0,d=f.length;u<d;u+=3){const m=f[u+0],S=f[u+1],D=f[u+2];B.push(m,S,S,D,D,m)}}else{const f=Q.array;h=Q.version;for(let u=0,d=f.length/3-1;u<d;u+=3){const m=u+0,S=u+1,D=u+2;B.push(m,S,S,D,D,m)}}const l=new(Uc(B)?Yc:Pc)(B,1);l.version=h;const E=a.get(C);E&&A.remove(E),a.set(C,l)}function g(C){const B=a.get(C);if(B){const c=C.index;c!==null&&B.version<c.version&&r(C)}else r(C);return a.get(C)}return{get:s,update:I,getWireframeAttribute:g}}function Rp(i,A,t,e){const n=e.isWebGL2;let a;function o(B){a=B}let s,I;function r(B){s=B.type,I=B.bytesPerElement}function g(B,c){i.drawElements(a,c,s,B*I),t.update(c,a,1)}function C(B,c,Q){if(Q===0)return;let h,l;if(n)h=i,l="drawElementsInstanced";else if(h=A.get("ANGLE_instanced_arrays"),l="drawElementsInstancedANGLE",h===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}h[l](a,c,s,B*I,Q),t.update(c,a,Q)}this.setMode=o,this.setIndex=r,this.render=g,this.renderInstances=C}function vp(i){const A={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function e(a,o,s){switch(t.calls++,o){case 4:t.triangles+=s*(a/3);break;case 1:t.lines+=s*(a/2);break;case 3:t.lines+=s*(a-1);break;case 2:t.lines+=s*a;break;case 0:t.points+=s*a;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function n(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:A,render:t,programs:null,autoReset:!0,reset:n,update:e}}function Gp(i,A){return i[0]-A[0]}function Np(i,A){return Math.abs(A[1])-Math.abs(i[1])}function Lp(i,A,t){const e={},n=new Float32Array(8),a=new WeakMap,o=new dt,s=[];for(let r=0;r<8;r++)s[r]=[r,0];function I(r,g,C,B){const c=r.morphTargetInfluences;if(A.isWebGL2===!0){const h=g.morphAttributes.position||g.morphAttributes.normal||g.morphAttributes.color,l=h!==void 0?h.length:0;let E=a.get(g);if(E===void 0||E.count!==l){let V=function(){G.dispose(),a.delete(g),g.removeEventListener("dispose",V)};var Q=V;E!==void 0&&E.texture.dispose();const d=g.morphAttributes.position!==void 0,m=g.morphAttributes.normal!==void 0,S=g.morphAttributes.color!==void 0,D=g.morphAttributes.position||[],p=g.morphAttributes.normal||[],w=g.morphAttributes.color||[];let M=0;d===!0&&(M=1),m===!0&&(M=2),S===!0&&(M=3);let R=g.attributes.position.count*M,U=1;R>A.maxTextureSize&&(U=Math.ceil(R/A.maxTextureSize),R=A.maxTextureSize);const N=new Float32Array(R*U*4*l),G=new qc(N,R,U,l);G.type=ni,G.needsUpdate=!0;const T=M*4;for(let tA=0;tA<l;tA++){const z=D[tA],W=p[tA],Y=w[tA],CA=R*U*4*tA;for(let K=0;K<z.count;K++){const AA=K*T;d===!0&&(o.fromBufferAttribute(z,K),N[CA+AA+0]=o.x,N[CA+AA+1]=o.y,N[CA+AA+2]=o.z,N[CA+AA+3]=0),m===!0&&(o.fromBufferAttribute(W,K),N[CA+AA+4]=o.x,N[CA+AA+5]=o.y,N[CA+AA+6]=o.z,N[CA+AA+7]=0),S===!0&&(o.fromBufferAttribute(Y,K),N[CA+AA+8]=o.x,N[CA+AA+9]=o.y,N[CA+AA+10]=o.z,N[CA+AA+11]=Y.itemSize===4?o.w:1)}}E={count:l,texture:G,size:new XA(R,U)},a.set(g,E),g.addEventListener("dispose",V)}let f=0;for(let d=0;d<c.length;d++)f+=c[d];const u=g.morphTargetsRelative?1:1-f;B.getUniforms().setValue(i,"morphTargetBaseInfluence",u),B.getUniforms().setValue(i,"morphTargetInfluences",c),B.getUniforms().setValue(i,"morphTargetsTexture",E.texture,t),B.getUniforms().setValue(i,"morphTargetsTextureSize",E.size)}else{const h=c===void 0?0:c.length;let l=e[g.id];if(l===void 0||l.length!==h){l=[];for(let m=0;m<h;m++)l[m]=[m,0];e[g.id]=l}for(let m=0;m<h;m++){const S=l[m];S[0]=m,S[1]=c[m]}l.sort(Np);for(let m=0;m<8;m++)m<h&&l[m][1]?(s[m][0]=l[m][0],s[m][1]=l[m][1]):(s[m][0]=Number.MAX_SAFE_INTEGER,s[m][1]=0);s.sort(Gp);const E=g.morphAttributes.position,f=g.morphAttributes.normal;let u=0;for(let m=0;m<8;m++){const S=s[m],D=S[0],p=S[1];D!==Number.MAX_SAFE_INTEGER&&p?(E&&g.getAttribute("morphTarget"+m)!==E[D]&&g.setAttribute("morphTarget"+m,E[D]),f&&g.getAttribute("morphNormal"+m)!==f[D]&&g.setAttribute("morphNormal"+m,f[D]),n[m]=p,u+=p):(E&&g.hasAttribute("morphTarget"+m)===!0&&g.deleteAttribute("morphTarget"+m),f&&g.hasAttribute("morphNormal"+m)===!0&&g.deleteAttribute("morphNormal"+m),n[m]=0)}const d=g.morphTargetsRelative?1:1-u;B.getUniforms().setValue(i,"morphTargetBaseInfluence",d),B.getUniforms().setValue(i,"morphTargetInfluences",n)}}return{update:I}}function bp(i,A,t,e){let n=new WeakMap;function a(I){const r=e.render.frame,g=I.geometry,C=A.get(I,g);return n.get(C)!==r&&(A.update(C),n.set(C,r)),I.isInstancedMesh&&(I.hasEventListener("dispose",s)===!1&&I.addEventListener("dispose",s),t.update(I.instanceMatrix,34962),I.instanceColor!==null&&t.update(I.instanceColor,34962)),C}function o(){n=new WeakMap}function s(I){const r=I.target;r.removeEventListener("dispose",s),t.remove(r.instanceMatrix),r.instanceColor!==null&&t.remove(r.instanceColor)}return{update:a,dispose:o}}const zc=new we,Xc=new qc,Zc=new md,jc=new Oc,kC=[],TC=[],HC=new Float32Array(16),qC=new Float32Array(9),JC=new Float32Array(4);function os(i,A,t){const e=i[0];if(e<=0||e>0)return i;const n=A*t;let a=kC[n];if(a===void 0&&(a=new Float32Array(n),kC[n]=a),A!==0){e.toArray(a,0);for(let o=1,s=0;o!==A;++o)s+=t,i[o].toArray(a,s)}return a}function Gt(i,A){if(i.length!==A.length)return!1;for(let t=0,e=i.length;t<e;t++)if(i[t]!==A[t])return!1;return!0}function Nt(i,A){for(let t=0,e=A.length;t<e;t++)i[t]=A[t]}function Ur(i,A){let t=TC[A];t===void 0&&(t=new Int32Array(A),TC[A]=t);for(let e=0;e!==A;++e)t[e]=i.allocateTextureUnit();return t}function Up(i,A){const t=this.cache;t[0]!==A&&(i.uniform1f(this.addr,A),t[0]=A)}function kp(i,A){const t=this.cache;if(A.x!==void 0)(t[0]!==A.x||t[1]!==A.y)&&(i.uniform2f(this.addr,A.x,A.y),t[0]=A.x,t[1]=A.y);else{if(Gt(t,A))return;i.uniform2fv(this.addr,A),Nt(t,A)}}function Tp(i,A){const t=this.cache;if(A.x!==void 0)(t[0]!==A.x||t[1]!==A.y||t[2]!==A.z)&&(i.uniform3f(this.addr,A.x,A.y,A.z),t[0]=A.x,t[1]=A.y,t[2]=A.z);else if(A.r!==void 0)(t[0]!==A.r||t[1]!==A.g||t[2]!==A.b)&&(i.uniform3f(this.addr,A.r,A.g,A.b),t[0]=A.r,t[1]=A.g,t[2]=A.b);else{if(Gt(t,A))return;i.uniform3fv(this.addr,A),Nt(t,A)}}function Hp(i,A){const t=this.cache;if(A.x!==void 0)(t[0]!==A.x||t[1]!==A.y||t[2]!==A.z||t[3]!==A.w)&&(i.uniform4f(this.addr,A.x,A.y,A.z,A.w),t[0]=A.x,t[1]=A.y,t[2]=A.z,t[3]=A.w);else{if(Gt(t,A))return;i.uniform4fv(this.addr,A),Nt(t,A)}}function qp(i,A){const t=this.cache,e=A.elements;if(e===void 0){if(Gt(t,A))return;i.uniformMatrix2fv(this.addr,!1,A),Nt(t,A)}else{if(Gt(t,e))return;JC.set(e),i.uniformMatrix2fv(this.addr,!1,JC),Nt(t,e)}}function Jp(i,A){const t=this.cache,e=A.elements;if(e===void 0){if(Gt(t,A))return;i.uniformMatrix3fv(this.addr,!1,A),Nt(t,A)}else{if(Gt(t,e))return;qC.set(e),i.uniformMatrix3fv(this.addr,!1,qC),Nt(t,e)}}function Pp(i,A){const t=this.cache,e=A.elements;if(e===void 0){if(Gt(t,A))return;i.uniformMatrix4fv(this.addr,!1,A),Nt(t,A)}else{if(Gt(t,e))return;HC.set(e),i.uniformMatrix4fv(this.addr,!1,HC),Nt(t,e)}}function Yp(i,A){const t=this.cache;t[0]!==A&&(i.uniform1i(this.addr,A),t[0]=A)}function Kp(i,A){const t=this.cache;Gt(t,A)||(i.uniform2iv(this.addr,A),Nt(t,A))}function Op(i,A){const t=this.cache;Gt(t,A)||(i.uniform3iv(this.addr,A),Nt(t,A))}function Wp(i,A){const t=this.cache;Gt(t,A)||(i.uniform4iv(this.addr,A),Nt(t,A))}function Vp(i,A){const t=this.cache;t[0]!==A&&(i.uniform1ui(this.addr,A),t[0]=A)}function zp(i,A){const t=this.cache;Gt(t,A)||(i.uniform2uiv(this.addr,A),Nt(t,A))}function Xp(i,A){const t=this.cache;Gt(t,A)||(i.uniform3uiv(this.addr,A),Nt(t,A))}function Zp(i,A){const t=this.cache;Gt(t,A)||(i.uniform4uiv(this.addr,A),Nt(t,A))}function jp(i,A,t){const e=this.cache,n=t.allocateTextureUnit();e[0]!==n&&(i.uniform1i(this.addr,n),e[0]=n),t.setTexture2D(A||zc,n)}function $p(i,A,t){const e=this.cache,n=t.allocateTextureUnit();e[0]!==n&&(i.uniform1i(this.addr,n),e[0]=n),t.setTexture3D(A||Zc,n)}function A0(i,A,t){const e=this.cache,n=t.allocateTextureUnit();e[0]!==n&&(i.uniform1i(this.addr,n),e[0]=n),t.setTextureCube(A||jc,n)}function t0(i,A,t){const e=this.cache,n=t.allocateTextureUnit();e[0]!==n&&(i.uniform1i(this.addr,n),e[0]=n),t.setTexture2DArray(A||Xc,n)}function e0(i){switch(i){case 5126:return Up;case 35664:return kp;case 35665:return Tp;case 35666:return Hp;case 35674:return qp;case 35675:return Jp;case 35676:return Pp;case 5124:case 35670:return Yp;case 35667:case 35671:return Kp;case 35668:case 35672:return Op;case 35669:case 35673:return Wp;case 5125:return Vp;case 36294:return zp;case 36295:return Xp;case 36296:return Zp;case 35678:case 36198:case 36298:case 36306:case 35682:return jp;case 35679:case 36299:case 36307:return $p;case 35680:case 36300:case 36308:case 36293:return A0;case 36289:case 36303:case 36311:case 36292:return t0}}function i0(i,A){i.uniform1fv(this.addr,A)}function n0(i,A){const t=os(A,this.size,2);i.uniform2fv(this.addr,t)}function a0(i,A){const t=os(A,this.size,3);i.uniform3fv(this.addr,t)}function s0(i,A){const t=os(A,this.size,4);i.uniform4fv(this.addr,t)}function o0(i,A){const t=os(A,this.size,4);i.uniformMatrix2fv(this.addr,!1,t)}function r0(i,A){const t=os(A,this.size,9);i.uniformMatrix3fv(this.addr,!1,t)}function g0(i,A){const t=os(A,this.size,16);i.uniformMatrix4fv(this.addr,!1,t)}function I0(i,A){i.uniform1iv(this.addr,A)}function l0(i,A){i.uniform2iv(this.addr,A)}function C0(i,A){i.uniform3iv(this.addr,A)}function B0(i,A){i.uniform4iv(this.addr,A)}function h0(i,A){i.uniform1uiv(this.addr,A)}function c0(i,A){i.uniform2uiv(this.addr,A)}function E0(i,A){i.uniform3uiv(this.addr,A)}function Q0(i,A){i.uniform4uiv(this.addr,A)}function d0(i,A,t){const e=this.cache,n=A.length,a=Ur(t,n);Gt(e,a)||(i.uniform1iv(this.addr,a),Nt(e,a));for(let o=0;o!==n;++o)t.setTexture2D(A[o]||zc,a[o])}function f0(i,A,t){const e=this.cache,n=A.length,a=Ur(t,n);Gt(e,a)||(i.uniform1iv(this.addr,a),Nt(e,a));for(let o=0;o!==n;++o)t.setTexture3D(A[o]||Zc,a[o])}function u0(i,A,t){const e=this.cache,n=A.length,a=Ur(t,n);Gt(e,a)||(i.uniform1iv(this.addr,a),Nt(e,a));for(let o=0;o!==n;++o)t.setTextureCube(A[o]||jc,a[o])}function p0(i,A,t){const e=this.cache,n=A.length,a=Ur(t,n);Gt(e,a)||(i.uniform1iv(this.addr,a),Nt(e,a));for(let o=0;o!==n;++o)t.setTexture2DArray(A[o]||Xc,a[o])}function m0(i){switch(i){case 5126:return i0;case 35664:return n0;case 35665:return a0;case 35666:return s0;case 35674:return o0;case 35675:return r0;case 35676:return g0;case 5124:case 35670:return I0;case 35667:case 35671:return l0;case 35668:case 35672:return C0;case 35669:case 35673:return B0;case 5125:return h0;case 36294:return c0;case 36295:return E0;case 36296:return Q0;case 35678:case 36198:case 36298:case 36306:case 35682:return d0;case 35679:case 36299:case 36307:return f0;case 35680:case 36300:case 36308:case 36293:return u0;case 36289:case 36303:case 36311:case 36292:return p0}}class y0{constructor(A,t,e){this.id=A,this.addr=e,this.cache=[],this.setValue=e0(t.type)}}class D0{constructor(A,t,e){this.id=A,this.addr=e,this.cache=[],this.size=t.size,this.setValue=m0(t.type)}}class S0{constructor(A){this.id=A,this.seq=[],this.map={}}setValue(A,t,e){const n=this.seq;for(let a=0,o=n.length;a!==o;++a){const s=n[a];s.setValue(A,t[s.id],e)}}}const yg=/(\w+)(\])?(\[|\.)?/g;function PC(i,A){i.seq.push(A),i.map[A.id]=A}function w0(i,A,t){const e=i.name,n=e.length;for(yg.lastIndex=0;;){const a=yg.exec(e),o=yg.lastIndex;let s=a[1];const I=a[2]==="]",r=a[3];if(I&&(s=s|0),r===void 0||r==="["&&o+2===n){PC(t,r===void 0?new y0(s,i,A):new D0(s,i,A));break}else{let C=t.map[s];C===void 0&&(C=new S0(s),PC(t,C)),t=C}}}class hr{constructor(A,t){this.seq=[],this.map={};const e=A.getProgramParameter(t,35718);for(let n=0;n<e;++n){const a=A.getActiveUniform(t,n),o=A.getUniformLocation(t,a.name);w0(a,o,this)}}setValue(A,t,e,n){const a=this.map[t];a!==void 0&&a.setValue(A,e,n)}setOptional(A,t,e){const n=t[e];n!==void 0&&this.setValue(A,e,n)}static upload(A,t,e,n){for(let a=0,o=t.length;a!==o;++a){const s=t[a],I=e[s.id];I.needsUpdate!==!1&&s.setValue(A,I.value,n)}}static seqWithValue(A,t){const e=[];for(let n=0,a=A.length;n!==a;++n){const o=A[n];o.id in t&&e.push(o)}return e}}function YC(i,A,t){const e=i.createShader(A);return i.shaderSource(e,t),i.compileShader(e),e}let _0=0;function x0(i,A){const t=i.split(`
`),e=[],n=Math.max(A-6,0),a=Math.min(A+6,t.length);for(let o=n;o<a;o++){const s=o+1;e.push(`${s===A?">":" "} ${s}: ${t[o]}`)}return e.join(`
`)}function M0(i){switch(i){case gn:return["Linear","( value )"];case ut:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",i),["Linear","( value )"]}}function KC(i,A,t){const e=i.getShaderParameter(A,35713),n=i.getShaderInfoLog(A).trim();if(e&&n==="")return"";const a=/ERROR: 0:(\d+)/.exec(n);if(a){const o=parseInt(a[1]);return t.toUpperCase()+`

`+n+`

`+x0(i.getShaderSource(A),o)}else return n}function F0(i,A){const t=M0(A);return"vec4 "+i+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function R0(i,A){let t;switch(A){case zQ:t="Linear";break;case XQ:t="Reinhard";break;case ZQ:t="OptimizedCineon";break;case jQ:t="ACESFilmic";break;case $Q:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",A),t="Linear"}return"vec3 "+i+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function v0(i){return[i.extensionDerivatives||!!i.envMapCubeUVHeight||i.bumpMap||i.tangentSpaceNormalMap||i.clearcoatNormalMap||i.flatShading||i.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(i.extensionFragDepth||i.logarithmicDepthBuffer)&&i.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",i.extensionDrawBuffers&&i.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(i.extensionShaderTextureLOD||i.envMap||i.transmission)&&i.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(vs).join(`
`)}function G0(i){const A=[];for(const t in i){const e=i[t];e!==!1&&A.push("#define "+t+" "+e)}return A.join(`
`)}function N0(i,A){const t={},e=i.getProgramParameter(A,35721);for(let n=0;n<e;n++){const a=i.getActiveAttrib(A,n),o=a.name;let s=1;a.type===35674&&(s=2),a.type===35675&&(s=3),a.type===35676&&(s=4),t[o]={type:a.type,location:i.getAttribLocation(A,o),locationSize:s}}return t}function vs(i){return i!==""}function OC(i,A){const t=A.numSpotLightShadows+A.numSpotLightMaps-A.numSpotLightShadowsWithMaps;return i.replace(/NUM_DIR_LIGHTS/g,A.numDirLights).replace(/NUM_SPOT_LIGHTS/g,A.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,A.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,A.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,A.numPointLights).replace(/NUM_HEMI_LIGHTS/g,A.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,A.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,A.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,A.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,A.numPointLightShadows)}function WC(i,A){return i.replace(/NUM_CLIPPING_PLANES/g,A.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,A.numClippingPlanes-A.numClipIntersection)}const L0=/^[ \t]*#include +<([\w\d./]+)>/gm;function LI(i){return i.replace(L0,b0)}function b0(i,A){const t=At[A];if(t===void 0)throw new Error("Can not resolve #include <"+A+">");return LI(t)}const U0=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function VC(i){return i.replace(U0,k0)}function k0(i,A,t,e){let n="";for(let a=parseInt(A);a<parseInt(t);a++)n+=e.replace(/\[\s*i\s*\]/g,"[ "+a+" ]").replace(/UNROLLED_LOOP_INDEX/g,a);return n}function zC(i){let A="precision "+i.precision+` float;
precision `+i.precision+" int;";return i.precision==="highp"?A+=`
#define HIGH_PRECISION`:i.precision==="mediump"?A+=`
#define MEDIUM_PRECISION`:i.precision==="lowp"&&(A+=`
#define LOW_PRECISION`),A}function T0(i){let A="SHADOWMAP_TYPE_BASIC";return i.shadowMapType===vc?A="SHADOWMAP_TYPE_PCF":i.shadowMapType===_Q?A="SHADOWMAP_TYPE_PCF_SOFT":i.shadowMapType===Rs&&(A="SHADOWMAP_TYPE_VSM"),A}function H0(i){let A="ENVMAP_TYPE_CUBE";if(i.envMap)switch(i.envMapMode){case ja:case $a:A="ENVMAP_TYPE_CUBE";break;case br:A="ENVMAP_TYPE_CUBE_UV";break}return A}function q0(i){let A="ENVMAP_MODE_REFLECTION";if(i.envMap)switch(i.envMapMode){case $a:A="ENVMAP_MODE_REFRACTION";break}return A}function J0(i){let A="ENVMAP_BLENDING_NONE";if(i.envMap)switch(i.combine){case Bl:A="ENVMAP_BLENDING_MULTIPLY";break;case WQ:A="ENVMAP_BLENDING_MIX";break;case VQ:A="ENVMAP_BLENDING_ADD";break}return A}function P0(i){const A=i.envMapCubeUVHeight;if(A===null)return null;const t=Math.log2(A)-2,e=1/A;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:e,maxMip:t}}function Y0(i,A,t,e){const n=i.getContext(),a=t.defines;let o=t.vertexShader,s=t.fragmentShader;const I=T0(t),r=H0(t),g=q0(t),C=J0(t),B=P0(t),c=t.isWebGL2?"":v0(t),Q=G0(a),h=n.createProgram();let l,E,f=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(l=[Q].filter(vs).join(`
`),l.length>0&&(l+=`
`),E=[c,Q].filter(vs).join(`
`),E.length>0&&(E+=`
`)):(l=[zC(t),"#define SHADER_NAME "+t.shaderName,Q,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+g:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+I:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(vs).join(`
`),E=[c,zC(t),"#define SHADER_NAME "+t.shaderName,Q,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+r:"",t.envMap?"#define "+g:"",t.envMap?"#define "+C:"",B?"#define CUBEUV_TEXEL_WIDTH "+B.texelWidth:"",B?"#define CUBEUV_TEXEL_HEIGHT "+B.texelHeight:"",B?"#define CUBEUV_MAX_MIP "+B.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+I:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Gi?"#define TONE_MAPPING":"",t.toneMapping!==Gi?At.tonemapping_pars_fragment:"",t.toneMapping!==Gi?R0("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",At.encodings_pars_fragment,F0("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(vs).join(`
`)),o=LI(o),o=OC(o,t),o=WC(o,t),s=LI(s),s=OC(s,t),s=WC(s,t),o=VC(o),s=VC(s),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(f=`#version 300 es
`,l=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+l,E=["#define varying in",t.glslVersion===dC?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===dC?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+E);const u=f+l+o,d=f+E+s,m=YC(n,35633,u),S=YC(n,35632,d);if(n.attachShader(h,m),n.attachShader(h,S),t.index0AttributeName!==void 0?n.bindAttribLocation(h,0,t.index0AttributeName):t.morphTargets===!0&&n.bindAttribLocation(h,0,"position"),n.linkProgram(h),i.debug.checkShaderErrors){const w=n.getProgramInfoLog(h).trim(),M=n.getShaderInfoLog(m).trim(),R=n.getShaderInfoLog(S).trim();let U=!0,N=!0;if(n.getProgramParameter(h,35714)===!1){U=!1;const G=KC(n,m,"vertex"),T=KC(n,S,"fragment");console.error("THREE.WebGLProgram: Shader Error "+n.getError()+" - VALIDATE_STATUS "+n.getProgramParameter(h,35715)+`

Program Info Log: `+w+`
`+G+`
`+T)}else w!==""?console.warn("THREE.WebGLProgram: Program Info Log:",w):(M===""||R==="")&&(N=!1);N&&(this.diagnostics={runnable:U,programLog:w,vertexShader:{log:M,prefix:l},fragmentShader:{log:R,prefix:E}})}n.deleteShader(m),n.deleteShader(S);let D;this.getUniforms=function(){return D===void 0&&(D=new hr(n,h)),D};let p;return this.getAttributes=function(){return p===void 0&&(p=N0(n,h)),p},this.destroy=function(){e.releaseStatesOfProgram(this),n.deleteProgram(h),this.program=void 0},this.name=t.shaderName,this.id=_0++,this.cacheKey=A,this.usedTimes=1,this.program=h,this.vertexShader=m,this.fragmentShader=S,this}let K0=0;class O0{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(A){const t=A.vertexShader,e=A.fragmentShader,n=this._getShaderStage(t),a=this._getShaderStage(e),o=this._getShaderCacheForMaterial(A);return o.has(n)===!1&&(o.add(n),n.usedTimes++),o.has(a)===!1&&(o.add(a),a.usedTimes++),this}remove(A){const t=this.materialCache.get(A);for(const e of t)e.usedTimes--,e.usedTimes===0&&this.shaderCache.delete(e.code);return this.materialCache.delete(A),this}getVertexShaderID(A){return this._getShaderStage(A.vertexShader).id}getFragmentShaderID(A){return this._getShaderStage(A.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(A){const t=this.materialCache;let e=t.get(A);return e===void 0&&(e=new Set,t.set(A,e)),e}_getShaderStage(A){const t=this.shaderCache;let e=t.get(A);return e===void 0&&(e=new W0(A),t.set(A,e)),e}}class W0{constructor(A){this.id=K0++,this.code=A,this.usedTimes=0}}function V0(i,A,t,e,n,a,o){const s=new Jc,I=new O0,r=[],g=n.isWebGL2,C=n.logarithmicDepthBuffer,B=n.vertexTextures;let c=n.precision;const Q={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function h(p,w,M,R,U){const N=R.fog,G=U.geometry,T=p.isMeshStandardMaterial?R.environment:null,V=(p.isMeshStandardMaterial?t:A).get(p.envMap||T),tA=!!V&&V.mapping===br?V.image.height:null,z=Q[p.type];p.precision!==null&&(c=n.getMaxPrecision(p.precision),c!==p.precision&&console.warn("THREE.WebGLProgram.getParameters:",p.precision,"not supported, using",c,"instead."));const W=G.morphAttributes.position||G.morphAttributes.normal||G.morphAttributes.color,Y=W!==void 0?W.length:0;let CA=0;G.morphAttributes.position!==void 0&&(CA=1),G.morphAttributes.normal!==void 0&&(CA=2),G.morphAttributes.color!==void 0&&(CA=3);let K,AA,lA,Z;if(z){const RA=Ai[z];K=RA.vertexShader,AA=RA.fragmentShader}else K=p.vertexShader,AA=p.fragmentShader,I.update(p),lA=I.getVertexShaderID(p),Z=I.getFragmentShaderID(p);const oA=i.getRenderTarget(),wA=p.alphaTest>0,uA=p.clearcoat>0,mA=p.iridescence>0;return{isWebGL2:g,shaderID:z,shaderName:p.type,vertexShader:K,fragmentShader:AA,defines:p.defines,customVertexShaderID:lA,customFragmentShaderID:Z,isRawShaderMaterial:p.isRawShaderMaterial===!0,glslVersion:p.glslVersion,precision:c,instancing:U.isInstancedMesh===!0,instancingColor:U.isInstancedMesh===!0&&U.instanceColor!==null,supportsVertexTextures:B,outputEncoding:oA===null?i.outputEncoding:oA.isXRRenderTarget===!0?oA.texture.encoding:gn,map:!!p.map,matcap:!!p.matcap,envMap:!!V,envMapMode:V&&V.mapping,envMapCubeUVHeight:tA,lightMap:!!p.lightMap,aoMap:!!p.aoMap,emissiveMap:!!p.emissiveMap,bumpMap:!!p.bumpMap,normalMap:!!p.normalMap,objectSpaceNormalMap:p.normalMapType===dd,tangentSpaceNormalMap:p.normalMapType===hl,decodeVideoTexture:!!p.map&&p.map.isVideoTexture===!0&&p.map.encoding===ut,clearcoat:uA,clearcoatMap:uA&&!!p.clearcoatMap,clearcoatRoughnessMap:uA&&!!p.clearcoatRoughnessMap,clearcoatNormalMap:uA&&!!p.clearcoatNormalMap,iridescence:mA,iridescenceMap:mA&&!!p.iridescenceMap,iridescenceThicknessMap:mA&&!!p.iridescenceThicknessMap,displacementMap:!!p.displacementMap,roughnessMap:!!p.roughnessMap,metalnessMap:!!p.metalnessMap,specularMap:!!p.specularMap,specularIntensityMap:!!p.specularIntensityMap,specularColorMap:!!p.specularColorMap,opaque:p.transparent===!1&&p.blending===Ya,alphaMap:!!p.alphaMap,alphaTest:wA,gradientMap:!!p.gradientMap,sheen:p.sheen>0,sheenColorMap:!!p.sheenColorMap,sheenRoughnessMap:!!p.sheenRoughnessMap,transmission:p.transmission>0,transmissionMap:!!p.transmissionMap,thicknessMap:!!p.thicknessMap,combine:p.combine,vertexTangents:!!p.normalMap&&!!G.attributes.tangent,vertexColors:p.vertexColors,vertexAlphas:p.vertexColors===!0&&!!G.attributes.color&&G.attributes.color.itemSize===4,vertexUvs:!!p.map||!!p.bumpMap||!!p.normalMap||!!p.specularMap||!!p.alphaMap||!!p.emissiveMap||!!p.roughnessMap||!!p.metalnessMap||!!p.clearcoatMap||!!p.clearcoatRoughnessMap||!!p.clearcoatNormalMap||!!p.iridescenceMap||!!p.iridescenceThicknessMap||!!p.displacementMap||!!p.transmissionMap||!!p.thicknessMap||!!p.specularIntensityMap||!!p.specularColorMap||!!p.sheenColorMap||!!p.sheenRoughnessMap,uvsVertexOnly:!(!!p.map||!!p.bumpMap||!!p.normalMap||!!p.specularMap||!!p.alphaMap||!!p.emissiveMap||!!p.roughnessMap||!!p.metalnessMap||!!p.clearcoatNormalMap||!!p.iridescenceMap||!!p.iridescenceThicknessMap||p.transmission>0||!!p.transmissionMap||!!p.thicknessMap||!!p.specularIntensityMap||!!p.specularColorMap||p.sheen>0||!!p.sheenColorMap||!!p.sheenRoughnessMap)&&!!p.displacementMap,fog:!!N,useFog:p.fog===!0,fogExp2:N&&N.isFogExp2,flatShading:!!p.flatShading,sizeAttenuation:p.sizeAttenuation,logarithmicDepthBuffer:C,skinning:U.isSkinnedMesh===!0,morphTargets:G.morphAttributes.position!==void 0,morphNormals:G.morphAttributes.normal!==void 0,morphColors:G.morphAttributes.color!==void 0,morphTargetsCount:Y,morphTextureStride:CA,numDirLights:w.directional.length,numPointLights:w.point.length,numSpotLights:w.spot.length,numSpotLightMaps:w.spotLightMap.length,numRectAreaLights:w.rectArea.length,numHemiLights:w.hemi.length,numDirLightShadows:w.directionalShadowMap.length,numPointLightShadows:w.pointShadowMap.length,numSpotLightShadows:w.spotShadowMap.length,numSpotLightShadowsWithMaps:w.numSpotLightShadowsWithMaps,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:p.dithering,shadowMapEnabled:i.shadowMap.enabled&&M.length>0,shadowMapType:i.shadowMap.type,toneMapping:p.toneMapped?i.toneMapping:Gi,physicallyCorrectLights:i.physicallyCorrectLights,premultipliedAlpha:p.premultipliedAlpha,doubleSided:p.side===Xi,flipSided:p.side===ve,useDepthPacking:!!p.depthPacking,depthPacking:p.depthPacking||0,index0AttributeName:p.index0AttributeName,extensionDerivatives:p.extensions&&p.extensions.derivatives,extensionFragDepth:p.extensions&&p.extensions.fragDepth,extensionDrawBuffers:p.extensions&&p.extensions.drawBuffers,extensionShaderTextureLOD:p.extensions&&p.extensions.shaderTextureLOD,rendererExtensionFragDepth:g||e.has("EXT_frag_depth"),rendererExtensionDrawBuffers:g||e.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:g||e.has("EXT_shader_texture_lod"),customProgramCacheKey:p.customProgramCacheKey()}}function l(p){const w=[];if(p.shaderID?w.push(p.shaderID):(w.push(p.customVertexShaderID),w.push(p.customFragmentShaderID)),p.defines!==void 0)for(const M in p.defines)w.push(M),w.push(p.defines[M]);return p.isRawShaderMaterial===!1&&(E(w,p),f(w,p),w.push(i.outputEncoding)),w.push(p.customProgramCacheKey),w.join()}function E(p,w){p.push(w.precision),p.push(w.outputEncoding),p.push(w.envMapMode),p.push(w.envMapCubeUVHeight),p.push(w.combine),p.push(w.vertexUvs),p.push(w.fogExp2),p.push(w.sizeAttenuation),p.push(w.morphTargetsCount),p.push(w.morphAttributeCount),p.push(w.numDirLights),p.push(w.numPointLights),p.push(w.numSpotLights),p.push(w.numSpotLightMaps),p.push(w.numHemiLights),p.push(w.numRectAreaLights),p.push(w.numDirLightShadows),p.push(w.numPointLightShadows),p.push(w.numSpotLightShadows),p.push(w.numSpotLightShadowsWithMaps),p.push(w.shadowMapType),p.push(w.toneMapping),p.push(w.numClippingPlanes),p.push(w.numClipIntersection),p.push(w.depthPacking)}function f(p,w){s.disableAll(),w.isWebGL2&&s.enable(0),w.supportsVertexTextures&&s.enable(1),w.instancing&&s.enable(2),w.instancingColor&&s.enable(3),w.map&&s.enable(4),w.matcap&&s.enable(5),w.envMap&&s.enable(6),w.lightMap&&s.enable(7),w.aoMap&&s.enable(8),w.emissiveMap&&s.enable(9),w.bumpMap&&s.enable(10),w.normalMap&&s.enable(11),w.objectSpaceNormalMap&&s.enable(12),w.tangentSpaceNormalMap&&s.enable(13),w.clearcoat&&s.enable(14),w.clearcoatMap&&s.enable(15),w.clearcoatRoughnessMap&&s.enable(16),w.clearcoatNormalMap&&s.enable(17),w.iridescence&&s.enable(18),w.iridescenceMap&&s.enable(19),w.iridescenceThicknessMap&&s.enable(20),w.displacementMap&&s.enable(21),w.specularMap&&s.enable(22),w.roughnessMap&&s.enable(23),w.metalnessMap&&s.enable(24),w.gradientMap&&s.enable(25),w.alphaMap&&s.enable(26),w.alphaTest&&s.enable(27),w.vertexColors&&s.enable(28),w.vertexAlphas&&s.enable(29),w.vertexUvs&&s.enable(30),w.vertexTangents&&s.enable(31),w.uvsVertexOnly&&s.enable(32),p.push(s.mask),s.disableAll(),w.fog&&s.enable(0),w.useFog&&s.enable(1),w.flatShading&&s.enable(2),w.logarithmicDepthBuffer&&s.enable(3),w.skinning&&s.enable(4),w.morphTargets&&s.enable(5),w.morphNormals&&s.enable(6),w.morphColors&&s.enable(7),w.premultipliedAlpha&&s.enable(8),w.shadowMapEnabled&&s.enable(9),w.physicallyCorrectLights&&s.enable(10),w.doubleSided&&s.enable(11),w.flipSided&&s.enable(12),w.useDepthPacking&&s.enable(13),w.dithering&&s.enable(14),w.specularIntensityMap&&s.enable(15),w.specularColorMap&&s.enable(16),w.transmission&&s.enable(17),w.transmissionMap&&s.enable(18),w.thicknessMap&&s.enable(19),w.sheen&&s.enable(20),w.sheenColorMap&&s.enable(21),w.sheenRoughnessMap&&s.enable(22),w.decodeVideoTexture&&s.enable(23),w.opaque&&s.enable(24),p.push(s.mask)}function u(p){const w=Q[p.type];let M;if(w){const R=Ai[w];M=Ld.clone(R.uniforms)}else M=p.uniforms;return M}function d(p,w){let M;for(let R=0,U=r.length;R<U;R++){const N=r[R];if(N.cacheKey===w){M=N,++M.usedTimes;break}}return M===void 0&&(M=new Y0(i,w,p,a),r.push(M)),M}function m(p){if(--p.usedTimes===0){const w=r.indexOf(p);r[w]=r[r.length-1],r.pop(),p.destroy()}}function S(p){I.remove(p)}function D(){I.dispose()}return{getParameters:h,getProgramCacheKey:l,getUniforms:u,acquireProgram:d,releaseProgram:m,releaseShaderCache:S,programs:r,dispose:D}}function z0(){let i=new WeakMap;function A(a){let o=i.get(a);return o===void 0&&(o={},i.set(a,o)),o}function t(a){i.delete(a)}function e(a,o,s){i.get(a)[o]=s}function n(){i=new WeakMap}return{get:A,remove:t,update:e,dispose:n}}function X0(i,A){return i.groupOrder!==A.groupOrder?i.groupOrder-A.groupOrder:i.renderOrder!==A.renderOrder?i.renderOrder-A.renderOrder:i.material.id!==A.material.id?i.material.id-A.material.id:i.z!==A.z?i.z-A.z:i.id-A.id}function XC(i,A){return i.groupOrder!==A.groupOrder?i.groupOrder-A.groupOrder:i.renderOrder!==A.renderOrder?i.renderOrder-A.renderOrder:i.z!==A.z?A.z-i.z:i.id-A.id}function ZC(){const i=[];let A=0;const t=[],e=[],n=[];function a(){A=0,t.length=0,e.length=0,n.length=0}function o(C,B,c,Q,h,l){let E=i[A];return E===void 0?(E={id:C.id,object:C,geometry:B,material:c,groupOrder:Q,renderOrder:C.renderOrder,z:h,group:l},i[A]=E):(E.id=C.id,E.object=C,E.geometry=B,E.material=c,E.groupOrder=Q,E.renderOrder=C.renderOrder,E.z=h,E.group=l),A++,E}function s(C,B,c,Q,h,l){const E=o(C,B,c,Q,h,l);c.transmission>0?e.push(E):c.transparent===!0?n.push(E):t.push(E)}function I(C,B,c,Q,h,l){const E=o(C,B,c,Q,h,l);c.transmission>0?e.unshift(E):c.transparent===!0?n.unshift(E):t.unshift(E)}function r(C,B){t.length>1&&t.sort(C||X0),e.length>1&&e.sort(B||XC),n.length>1&&n.sort(B||XC)}function g(){for(let C=A,B=i.length;C<B;C++){const c=i[C];if(c.id===null)break;c.id=null,c.object=null,c.geometry=null,c.material=null,c.group=null}}return{opaque:t,transmissive:e,transparent:n,init:a,push:s,unshift:I,finish:g,sort:r}}function Z0(){let i=new WeakMap;function A(e,n){const a=i.get(e);let o;return a===void 0?(o=new ZC,i.set(e,[o])):n>=a.length?(o=new ZC,a.push(o)):o=a[n],o}function t(){i=new WeakMap}return{get:A,dispose:t}}function j0(){const i={};return{get:function(A){if(i[A.id]!==void 0)return i[A.id];let t;switch(A.type){case"DirectionalLight":t={direction:new rA,color:new st};break;case"SpotLight":t={position:new rA,direction:new rA,color:new st,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new rA,color:new st,distance:0,decay:0};break;case"HemisphereLight":t={direction:new rA,skyColor:new st,groundColor:new st};break;case"RectAreaLight":t={color:new st,position:new rA,halfWidth:new rA,halfHeight:new rA};break}return i[A.id]=t,t}}}function $0(){const i={};return{get:function(A){if(i[A.id]!==void 0)return i[A.id];let t;switch(A.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new XA};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new XA};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new XA,shadowCameraNear:1,shadowCameraFar:1e3};break}return i[A.id]=t,t}}}let Am=0;function tm(i,A){return(A.castShadow?2:0)-(i.castShadow?2:0)+(A.map?1:0)-(i.map?1:0)}function em(i,A){const t=new j0,e=$0(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let g=0;g<9;g++)n.probe.push(new rA);const a=new rA,o=new _t,s=new _t;function I(g,C){let B=0,c=0,Q=0;for(let R=0;R<9;R++)n.probe[R].set(0,0,0);let h=0,l=0,E=0,f=0,u=0,d=0,m=0,S=0,D=0,p=0;g.sort(tm);const w=C!==!0?Math.PI:1;for(let R=0,U=g.length;R<U;R++){const N=g[R],G=N.color,T=N.intensity,V=N.distance,tA=N.shadow&&N.shadow.map?N.shadow.map.texture:null;if(N.isAmbientLight)B+=G.r*T*w,c+=G.g*T*w,Q+=G.b*T*w;else if(N.isLightProbe)for(let z=0;z<9;z++)n.probe[z].addScaledVector(N.sh.coefficients[z],T);else if(N.isDirectionalLight){const z=t.get(N);if(z.color.copy(N.color).multiplyScalar(N.intensity*w),N.castShadow){const W=N.shadow,Y=e.get(N);Y.shadowBias=W.bias,Y.shadowNormalBias=W.normalBias,Y.shadowRadius=W.radius,Y.shadowMapSize=W.mapSize,n.directionalShadow[h]=Y,n.directionalShadowMap[h]=tA,n.directionalShadowMatrix[h]=N.shadow.matrix,d++}n.directional[h]=z,h++}else if(N.isSpotLight){const z=t.get(N);z.position.setFromMatrixPosition(N.matrixWorld),z.color.copy(G).multiplyScalar(T*w),z.distance=V,z.coneCos=Math.cos(N.angle),z.penumbraCos=Math.cos(N.angle*(1-N.penumbra)),z.decay=N.decay,n.spot[E]=z;const W=N.shadow;if(N.map&&(n.spotLightMap[D]=N.map,D++,W.updateMatrices(N),N.castShadow&&p++),n.spotLightMatrix[E]=W.matrix,N.castShadow){const Y=e.get(N);Y.shadowBias=W.bias,Y.shadowNormalBias=W.normalBias,Y.shadowRadius=W.radius,Y.shadowMapSize=W.mapSize,n.spotShadow[E]=Y,n.spotShadowMap[E]=tA,S++}E++}else if(N.isRectAreaLight){const z=t.get(N);z.color.copy(G).multiplyScalar(T),z.halfWidth.set(N.width*.5,0,0),z.halfHeight.set(0,N.height*.5,0),n.rectArea[f]=z,f++}else if(N.isPointLight){const z=t.get(N);if(z.color.copy(N.color).multiplyScalar(N.intensity*w),z.distance=N.distance,z.decay=N.decay,N.castShadow){const W=N.shadow,Y=e.get(N);Y.shadowBias=W.bias,Y.shadowNormalBias=W.normalBias,Y.shadowRadius=W.radius,Y.shadowMapSize=W.mapSize,Y.shadowCameraNear=W.camera.near,Y.shadowCameraFar=W.camera.far,n.pointShadow[l]=Y,n.pointShadowMap[l]=tA,n.pointShadowMatrix[l]=N.shadow.matrix,m++}n.point[l]=z,l++}else if(N.isHemisphereLight){const z=t.get(N);z.skyColor.copy(N.color).multiplyScalar(T*w),z.groundColor.copy(N.groundColor).multiplyScalar(T*w),n.hemi[u]=z,u++}}f>0&&(A.isWebGL2||i.has("OES_texture_float_linear")===!0?(n.rectAreaLTC1=vA.LTC_FLOAT_1,n.rectAreaLTC2=vA.LTC_FLOAT_2):i.has("OES_texture_half_float_linear")===!0?(n.rectAreaLTC1=vA.LTC_HALF_1,n.rectAreaLTC2=vA.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),n.ambient[0]=B,n.ambient[1]=c,n.ambient[2]=Q;const M=n.hash;(M.directionalLength!==h||M.pointLength!==l||M.spotLength!==E||M.rectAreaLength!==f||M.hemiLength!==u||M.numDirectionalShadows!==d||M.numPointShadows!==m||M.numSpotShadows!==S||M.numSpotMaps!==D)&&(n.directional.length=h,n.spot.length=E,n.rectArea.length=f,n.point.length=l,n.hemi.length=u,n.directionalShadow.length=d,n.directionalShadowMap.length=d,n.pointShadow.length=m,n.pointShadowMap.length=m,n.spotShadow.length=S,n.spotShadowMap.length=S,n.directionalShadowMatrix.length=d,n.pointShadowMatrix.length=m,n.spotLightMatrix.length=S+D-p,n.spotLightMap.length=D,n.numSpotLightShadowsWithMaps=p,M.directionalLength=h,M.pointLength=l,M.spotLength=E,M.rectAreaLength=f,M.hemiLength=u,M.numDirectionalShadows=d,M.numPointShadows=m,M.numSpotShadows=S,M.numSpotMaps=D,n.version=Am++)}function r(g,C){let B=0,c=0,Q=0,h=0,l=0;const E=C.matrixWorldInverse;for(let f=0,u=g.length;f<u;f++){const d=g[f];if(d.isDirectionalLight){const m=n.directional[B];m.direction.setFromMatrixPosition(d.matrixWorld),a.setFromMatrixPosition(d.target.matrixWorld),m.direction.sub(a),m.direction.transformDirection(E),B++}else if(d.isSpotLight){const m=n.spot[Q];m.position.setFromMatrixPosition(d.matrixWorld),m.position.applyMatrix4(E),m.direction.setFromMatrixPosition(d.matrixWorld),a.setFromMatrixPosition(d.target.matrixWorld),m.direction.sub(a),m.direction.transformDirection(E),Q++}else if(d.isRectAreaLight){const m=n.rectArea[h];m.position.setFromMatrixPosition(d.matrixWorld),m.position.applyMatrix4(E),s.identity(),o.copy(d.matrixWorld),o.premultiply(E),s.extractRotation(o),m.halfWidth.set(d.width*.5,0,0),m.halfHeight.set(0,d.height*.5,0),m.halfWidth.applyMatrix4(s),m.halfHeight.applyMatrix4(s),h++}else if(d.isPointLight){const m=n.point[c];m.position.setFromMatrixPosition(d.matrixWorld),m.position.applyMatrix4(E),c++}else if(d.isHemisphereLight){const m=n.hemi[l];m.direction.setFromMatrixPosition(d.matrixWorld),m.direction.transformDirection(E),l++}}}return{setup:I,setupView:r,state:n}}function jC(i,A){const t=new em(i,A),e=[],n=[];function a(){e.length=0,n.length=0}function o(C){e.push(C)}function s(C){n.push(C)}function I(C){t.setup(e,C)}function r(C){t.setupView(e,C)}return{init:a,state:{lightsArray:e,shadowsArray:n,lights:t},setupLights:I,setupLightsView:r,pushLight:o,pushShadow:s}}function im(i,A){let t=new WeakMap;function e(a,o=0){const s=t.get(a);let I;return s===void 0?(I=new jC(i,A),t.set(a,[I])):o>=s.length?(I=new jC(i,A),s.push(I)):I=s[o],I}function n(){t=new WeakMap}return{get:e,dispose:n}}class nm extends ss{constructor(A){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=Ed,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(A)}copy(A){return super.copy(A),this.depthPacking=A.depthPacking,this.map=A.map,this.alphaMap=A.alphaMap,this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this}}class am extends ss{constructor(A){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new rA,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(A)}copy(A){return super.copy(A),this.referencePosition.copy(A.referencePosition),this.nearDistance=A.nearDistance,this.farDistance=A.farDistance,this.map=A.map,this.alphaMap=A.alphaMap,this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this}}const sm=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,om=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function rm(i,A,t){let e=new El;const n=new XA,a=new XA,o=new dt,s=new nm({depthPacking:Qd}),I=new am,r={},g=t.maxTextureSize,C={0:ve,1:Za,2:Xi},B=new Pn({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new XA},radius:{value:4}},vertexShader:sm,fragmentShader:om}),c=B.clone();c.defines.HORIZONTAL_PASS=1;const Q=new Cn;Q.setAttribute("position",new oi(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const h=new wt(Q,B),l=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=vc,this.render=function(d,m,S){if(l.enabled===!1||l.autoUpdate===!1&&l.needsUpdate===!1||d.length===0)return;const D=i.getRenderTarget(),p=i.getActiveCubeFace(),w=i.getActiveMipmapLevel(),M=i.state;M.setBlending(en),M.buffers.color.setClear(1,1,1,1),M.buffers.depth.setTest(!0),M.setScissorTest(!1);for(let R=0,U=d.length;R<U;R++){const N=d[R],G=N.shadow;if(G===void 0){console.warn("THREE.WebGLShadowMap:",N,"has no shadow.");continue}if(G.autoUpdate===!1&&G.needsUpdate===!1)continue;n.copy(G.mapSize);const T=G.getFrameExtents();if(n.multiply(T),a.copy(G.mapSize),(n.x>g||n.y>g)&&(n.x>g&&(a.x=Math.floor(g/T.x),n.x=a.x*T.x,G.mapSize.x=a.x),n.y>g&&(a.y=Math.floor(g/T.y),n.y=a.y*T.y,G.mapSize.y=a.y)),G.map===null){const tA=this.type!==Rs?{minFilter:Ae,magFilter:Ae}:{};G.map=new qn(n.x,n.y,tA),G.map.texture.name=N.name+".shadowMap",G.camera.updateProjectionMatrix()}i.setRenderTarget(G.map),i.clear();const V=G.getViewportCount();for(let tA=0;tA<V;tA++){const z=G.getViewport(tA);o.set(a.x*z.x,a.y*z.y,a.x*z.z,a.y*z.w),M.viewport(o),G.updateMatrices(N,tA),e=G.getFrustum(),u(m,S,G.camera,N,this.type)}G.isPointLightShadow!==!0&&this.type===Rs&&E(G,S),G.needsUpdate=!1}l.needsUpdate=!1,i.setRenderTarget(D,p,w)};function E(d,m){const S=A.update(h);B.defines.VSM_SAMPLES!==d.blurSamples&&(B.defines.VSM_SAMPLES=d.blurSamples,c.defines.VSM_SAMPLES=d.blurSamples,B.needsUpdate=!0,c.needsUpdate=!0),d.mapPass===null&&(d.mapPass=new qn(n.x,n.y)),B.uniforms.shadow_pass.value=d.map.texture,B.uniforms.resolution.value=d.mapSize,B.uniforms.radius.value=d.radius,i.setRenderTarget(d.mapPass),i.clear(),i.renderBufferDirect(m,null,S,B,h,null),c.uniforms.shadow_pass.value=d.mapPass.texture,c.uniforms.resolution.value=d.mapSize,c.uniforms.radius.value=d.radius,i.setRenderTarget(d.map),i.clear(),i.renderBufferDirect(m,null,S,c,h,null)}function f(d,m,S,D,p,w){let M=null;const R=S.isPointLight===!0?d.customDistanceMaterial:d.customDepthMaterial;if(R!==void 0?M=R:M=S.isPointLight===!0?I:s,i.localClippingEnabled&&m.clipShadows===!0&&Array.isArray(m.clippingPlanes)&&m.clippingPlanes.length!==0||m.displacementMap&&m.displacementScale!==0||m.alphaMap&&m.alphaTest>0){const U=M.uuid,N=m.uuid;let G=r[U];G===void 0&&(G={},r[U]=G);let T=G[N];T===void 0&&(T=M.clone(),G[N]=T),M=T}return M.visible=m.visible,M.wireframe=m.wireframe,w===Rs?M.side=m.shadowSide!==null?m.shadowSide:m.side:M.side=m.shadowSide!==null?m.shadowSide:C[m.side],M.alphaMap=m.alphaMap,M.alphaTest=m.alphaTest,M.clipShadows=m.clipShadows,M.clippingPlanes=m.clippingPlanes,M.clipIntersection=m.clipIntersection,M.displacementMap=m.displacementMap,M.displacementScale=m.displacementScale,M.displacementBias=m.displacementBias,M.wireframeLinewidth=m.wireframeLinewidth,M.linewidth=m.linewidth,S.isPointLight===!0&&M.isMeshDistanceMaterial===!0&&(M.referencePosition.setFromMatrixPosition(S.matrixWorld),M.nearDistance=D,M.farDistance=p),M}function u(d,m,S,D,p){if(d.visible===!1)return;if(d.layers.test(m.layers)&&(d.isMesh||d.isLine||d.isPoints)&&(d.castShadow||d.receiveShadow&&p===Rs)&&(!d.frustumCulled||e.intersectsObject(d))){d.modelViewMatrix.multiplyMatrices(S.matrixWorldInverse,d.matrixWorld);const R=A.update(d),U=d.material;if(Array.isArray(U)){const N=R.groups;for(let G=0,T=N.length;G<T;G++){const V=N[G],tA=U[V.materialIndex];if(tA&&tA.visible){const z=f(d,tA,D,S.near,S.far,p);i.renderBufferDirect(S,null,R,z,d,V)}}}else if(U.visible){const N=f(d,U,D,S.near,S.far,p);i.renderBufferDirect(S,null,R,N,d,null)}}const M=d.children;for(let R=0,U=M.length;R<U;R++)u(M[R],m,S,D,p)}}function gm(i,A,t){const e=t.isWebGL2;function n(){let nA=!1;const xA=new dt;let O=null;const $=new dt(0,0,0,0);return{setMask:function(gA){O!==gA&&!nA&&(i.colorMask(gA,gA,gA,gA),O=gA)},setLocked:function(gA){nA=gA},setClear:function(gA,pA,FA,PA,ot){ot===!0&&(gA*=PA,pA*=PA,FA*=PA),xA.set(gA,pA,FA,PA),$.equals(xA)===!1&&(i.clearColor(gA,pA,FA,PA),$.copy(xA))},reset:function(){nA=!1,O=null,$.set(-1,0,0,0)}}}function a(){let nA=!1,xA=null,O=null,$=null;return{setTest:function(gA){gA?wA(2929):uA(2929)},setMask:function(gA){xA!==gA&&!nA&&(i.depthMask(gA),xA=gA)},setFunc:function(gA){if(O!==gA){switch(gA){case HQ:i.depthFunc(512);break;case qQ:i.depthFunc(519);break;case JQ:i.depthFunc(513);break;case MI:i.depthFunc(515);break;case PQ:i.depthFunc(514);break;case YQ:i.depthFunc(518);break;case KQ:i.depthFunc(516);break;case OQ:i.depthFunc(517);break;default:i.depthFunc(515)}O=gA}},setLocked:function(gA){nA=gA},setClear:function(gA){$!==gA&&(i.clearDepth(gA),$=gA)},reset:function(){nA=!1,xA=null,O=null,$=null}}}function o(){let nA=!1,xA=null,O=null,$=null,gA=null,pA=null,FA=null,PA=null,ot=null;return{setTest:function(zA){nA||(zA?wA(2960):uA(2960))},setMask:function(zA){xA!==zA&&!nA&&(i.stencilMask(zA),xA=zA)},setFunc:function(zA,Et,tt){(O!==zA||$!==Et||gA!==tt)&&(i.stencilFunc(zA,Et,tt),O=zA,$=Et,gA=tt)},setOp:function(zA,Et,tt){(pA!==zA||FA!==Et||PA!==tt)&&(i.stencilOp(zA,Et,tt),pA=zA,FA=Et,PA=tt)},setLocked:function(zA){nA=zA},setClear:function(zA){ot!==zA&&(i.clearStencil(zA),ot=zA)},reset:function(){nA=!1,xA=null,O=null,$=null,gA=null,pA=null,FA=null,PA=null,ot=null}}}const s=new n,I=new a,r=new o,g=new WeakMap,C=new WeakMap;let B={},c={},Q=new WeakMap,h=[],l=null,E=!1,f=null,u=null,d=null,m=null,S=null,D=null,p=null,w=!1,M=null,R=null,U=null,N=null,G=null;const T=i.getParameter(35661);let V=!1,tA=0;const z=i.getParameter(7938);z.indexOf("WebGL")!==-1?(tA=parseFloat(/^WebGL (\d)/.exec(z)[1]),V=tA>=1):z.indexOf("OpenGL ES")!==-1&&(tA=parseFloat(/^OpenGL ES (\d)/.exec(z)[1]),V=tA>=2);let W=null,Y={};const CA=i.getParameter(3088),K=i.getParameter(2978),AA=new dt().fromArray(CA),lA=new dt().fromArray(K);function Z(nA,xA,O){const $=new Uint8Array(4),gA=i.createTexture();i.bindTexture(nA,gA),i.texParameteri(nA,10241,9728),i.texParameteri(nA,10240,9728);for(let pA=0;pA<O;pA++)i.texImage2D(xA+pA,0,6408,1,1,0,6408,5121,$);return gA}const oA={};oA[3553]=Z(3553,3553,1),oA[34067]=Z(34067,34069,6),s.setClear(0,0,0,1),I.setClear(1),r.setClear(0),wA(2929),I.setFunc(MI),JA(!1),YA(Jl),wA(2884),TA(en);function wA(nA){B[nA]!==!0&&(i.enable(nA),B[nA]=!0)}function uA(nA){B[nA]!==!1&&(i.disable(nA),B[nA]=!1)}function mA(nA,xA){return c[nA]!==xA?(i.bindFramebuffer(nA,xA),c[nA]=xA,e&&(nA===36009&&(c[36160]=xA),nA===36160&&(c[36009]=xA)),!0):!1}function fA(nA,xA){let O=h,$=!1;if(nA)if(O=Q.get(xA),O===void 0&&(O=[],Q.set(xA,O)),nA.isWebGLMultipleRenderTargets){const gA=nA.texture;if(O.length!==gA.length||O[0]!==36064){for(let pA=0,FA=gA.length;pA<FA;pA++)O[pA]=36064+pA;O.length=gA.length,$=!0}}else O[0]!==36064&&(O[0]=36064,$=!0);else O[0]!==1029&&(O[0]=1029,$=!0);$&&(t.isWebGL2?i.drawBuffers(O):A.get("WEBGL_draw_buffers").drawBuffersWEBGL(O))}function RA(nA){return l!==nA?(i.useProgram(nA),l=nA,!0):!1}const MA={[Ua]:32774,[MQ]:32778,[FQ]:32779};if(e)MA[Ol]=32775,MA[Wl]=32776;else{const nA=A.get("EXT_blend_minmax");nA!==null&&(MA[Ol]=nA.MIN_EXT,MA[Wl]=nA.MAX_EXT)}const SA={[RQ]:0,[vQ]:1,[GQ]:768,[Gc]:770,[TQ]:776,[UQ]:774,[LQ]:772,[NQ]:769,[Nc]:771,[kQ]:775,[bQ]:773};function TA(nA,xA,O,$,gA,pA,FA,PA){if(nA===en){E===!0&&(uA(3042),E=!1);return}if(E===!1&&(wA(3042),E=!0),nA!==xQ){if(nA!==f||PA!==w){if((u!==Ua||S!==Ua)&&(i.blendEquation(32774),u=Ua,S=Ua),PA)switch(nA){case Ya:i.blendFuncSeparate(1,771,1,771);break;case Pl:i.blendFunc(1,1);break;case Yl:i.blendFuncSeparate(0,769,0,1);break;case Kl:i.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",nA);break}else switch(nA){case Ya:i.blendFuncSeparate(770,771,1,771);break;case Pl:i.blendFunc(770,1);break;case Yl:i.blendFuncSeparate(0,769,0,1);break;case Kl:i.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",nA);break}d=null,m=null,D=null,p=null,f=nA,w=PA}return}gA=gA||xA,pA=pA||O,FA=FA||$,(xA!==u||gA!==S)&&(i.blendEquationSeparate(MA[xA],MA[gA]),u=xA,S=gA),(O!==d||$!==m||pA!==D||FA!==p)&&(i.blendFuncSeparate(SA[O],SA[$],SA[pA],SA[FA]),d=O,m=$,D=pA,p=FA),f=nA,w=null}function OA(nA,xA){nA.side===Xi?uA(2884):wA(2884);let O=nA.side===ve;xA&&(O=!O),JA(O),nA.blending===Ya&&nA.transparent===!1?TA(en):TA(nA.blending,nA.blendEquation,nA.blendSrc,nA.blendDst,nA.blendEquationAlpha,nA.blendSrcAlpha,nA.blendDstAlpha,nA.premultipliedAlpha),I.setFunc(nA.depthFunc),I.setTest(nA.depthTest),I.setMask(nA.depthWrite),s.setMask(nA.colorWrite);const $=nA.stencilWrite;r.setTest($),$&&(r.setMask(nA.stencilWriteMask),r.setFunc(nA.stencilFunc,nA.stencilRef,nA.stencilFuncMask),r.setOp(nA.stencilFail,nA.stencilZFail,nA.stencilZPass)),kA(nA.polygonOffset,nA.polygonOffsetFactor,nA.polygonOffsetUnits),nA.alphaToCoverage===!0?wA(32926):uA(32926)}function JA(nA){M!==nA&&(nA?i.frontFace(2304):i.frontFace(2305),M=nA)}function YA(nA){nA!==SQ?(wA(2884),nA!==R&&(nA===Jl?i.cullFace(1029):nA===wQ?i.cullFace(1028):i.cullFace(1032))):uA(2884),R=nA}function HA(nA){nA!==U&&(V&&i.lineWidth(nA),U=nA)}function kA(nA,xA,O){nA?(wA(32823),(N!==xA||G!==O)&&(i.polygonOffset(xA,O),N=xA,G=O)):uA(32823)}function rt(nA){nA?wA(3089):uA(3089)}function $A(nA){nA===void 0&&(nA=33984+T-1),W!==nA&&(i.activeTexture(nA),W=nA)}function x(nA,xA,O){O===void 0&&(W===null?O=33984+T-1:O=W);let $=Y[O];$===void 0&&($={type:void 0,texture:void 0},Y[O]=$),($.type!==nA||$.texture!==xA)&&(W!==O&&(i.activeTexture(O),W=O),i.bindTexture(nA,xA||oA[nA]),$.type=nA,$.texture=xA)}function y(){const nA=Y[W];nA!==void 0&&nA.type!==void 0&&(i.bindTexture(nA.type,null),nA.type=void 0,nA.texture=void 0)}function b(){try{i.compressedTexImage2D.apply(i,arguments)}catch(nA){console.error("THREE.WebGLState:",nA)}}function X(){try{i.texSubImage2D.apply(i,arguments)}catch(nA){console.error("THREE.WebGLState:",nA)}}function j(){try{i.texSubImage3D.apply(i,arguments)}catch(nA){console.error("THREE.WebGLState:",nA)}}function eA(){try{i.compressedTexSubImage2D.apply(i,arguments)}catch(nA){console.error("THREE.WebGLState:",nA)}}function sA(){try{i.texStorage2D.apply(i,arguments)}catch(nA){console.error("THREE.WebGLState:",nA)}}function L(){try{i.texStorage3D.apply(i,arguments)}catch(nA){console.error("THREE.WebGLState:",nA)}}function k(){try{i.texImage2D.apply(i,arguments)}catch(nA){console.error("THREE.WebGLState:",nA)}}function hA(){try{i.texImage3D.apply(i,arguments)}catch(nA){console.error("THREE.WebGLState:",nA)}}function BA(nA){AA.equals(nA)===!1&&(i.scissor(nA.x,nA.y,nA.z,nA.w),AA.copy(nA))}function EA(nA){lA.equals(nA)===!1&&(i.viewport(nA.x,nA.y,nA.z,nA.w),lA.copy(nA))}function dA(nA,xA){let O=C.get(xA);O===void 0&&(O=new WeakMap,C.set(xA,O));let $=O.get(nA);$===void 0&&($=i.getUniformBlockIndex(xA,nA.name),O.set(nA,$))}function yA(nA,xA){const $=C.get(xA).get(nA);g.get(nA)!==$&&(i.uniformBlockBinding(xA,$,nA.__bindingPointIndex),g.set(nA,$))}function bA(){i.disable(3042),i.disable(2884),i.disable(2929),i.disable(32823),i.disable(3089),i.disable(2960),i.disable(32926),i.blendEquation(32774),i.blendFunc(1,0),i.blendFuncSeparate(1,0,1,0),i.colorMask(!0,!0,!0,!0),i.clearColor(0,0,0,0),i.depthMask(!0),i.depthFunc(513),i.clearDepth(1),i.stencilMask(4294967295),i.stencilFunc(519,0,4294967295),i.stencilOp(7680,7680,7680),i.clearStencil(0),i.cullFace(1029),i.frontFace(2305),i.polygonOffset(0,0),i.activeTexture(33984),i.bindFramebuffer(36160,null),e===!0&&(i.bindFramebuffer(36009,null),i.bindFramebuffer(36008,null)),i.useProgram(null),i.lineWidth(1),i.scissor(0,0,i.canvas.width,i.canvas.height),i.viewport(0,0,i.canvas.width,i.canvas.height),B={},W=null,Y={},c={},Q=new WeakMap,h=[],l=null,E=!1,f=null,u=null,d=null,m=null,S=null,D=null,p=null,w=!1,M=null,R=null,U=null,N=null,G=null,AA.set(0,0,i.canvas.width,i.canvas.height),lA.set(0,0,i.canvas.width,i.canvas.height),s.reset(),I.reset(),r.reset()}return{buffers:{color:s,depth:I,stencil:r},enable:wA,disable:uA,bindFramebuffer:mA,drawBuffers:fA,useProgram:RA,setBlending:TA,setMaterial:OA,setFlipSided:JA,setCullFace:YA,setLineWidth:HA,setPolygonOffset:kA,setScissorTest:rt,activeTexture:$A,bindTexture:x,unbindTexture:y,compressedTexImage2D:b,texImage2D:k,texImage3D:hA,updateUBOMapping:dA,uniformBlockBinding:yA,texStorage2D:sA,texStorage3D:L,texSubImage2D:X,texSubImage3D:j,compressedTexSubImage2D:eA,scissor:BA,viewport:EA,reset:bA}}function Im(i,A,t,e,n,a,o){const s=n.isWebGL2,I=n.maxTextures,r=n.maxCubemapSize,g=n.maxTextureSize,C=n.maxSamples,B=A.has("WEBGL_multisampled_render_to_texture")?A.get("WEBGL_multisampled_render_to_texture"):null,c=/OculusBrowser/g.test(navigator.userAgent),Q=new WeakMap;let h;const l=new WeakMap;let E=!1;try{E=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function f(x,y){return E?new OffscreenCanvas(x,y):Os("canvas")}function u(x,y,b,X){let j=1;if((x.width>X||x.height>X)&&(j=X/Math.max(x.width,x.height)),j<1||y===!0)if(typeof HTMLImageElement<"u"&&x instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&x instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&x instanceof ImageBitmap){const eA=y?NI:Math.floor,sA=eA(j*x.width),L=eA(j*x.height);h===void 0&&(h=f(sA,L));const k=b?f(sA,L):h;return k.width=sA,k.height=L,k.getContext("2d").drawImage(x,0,0,sA,L),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+x.width+"x"+x.height+") to ("+sA+"x"+L+")."),k}else return"data"in x&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+x.width+"x"+x.height+")."),x;return x}function d(x){return fC(x.width)&&fC(x.height)}function m(x){return s?!1:x.wrapS!==se||x.wrapT!==se||x.minFilter!==Ae&&x.minFilter!==Wt}function S(x,y){return x.generateMipmaps&&y&&x.minFilter!==Ae&&x.minFilter!==Wt}function D(x){i.generateMipmap(x)}function p(x,y,b,X,j=!1){if(s===!1)return y;if(x!==null){if(i[x]!==void 0)return i[x];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+x+"'")}let eA=y;return y===6403&&(b===5126&&(eA=33326),b===5131&&(eA=33325),b===5121&&(eA=33321)),y===33319&&(b===5126&&(eA=33328),b===5131&&(eA=33327),b===5121&&(eA=33323)),y===6408&&(b===5126&&(eA=34836),b===5131&&(eA=34842),b===5121&&(eA=X===ut&&j===!1?35907:32856),b===32819&&(eA=32854),b===32820&&(eA=32855)),(eA===33325||eA===33326||eA===33327||eA===33328||eA===34842||eA===34836)&&A.get("EXT_color_buffer_float"),eA}function w(x,y,b){return S(x,b)===!0||x.isFramebufferTexture&&x.minFilter!==Ae&&x.minFilter!==Wt?Math.log2(Math.max(y.width,y.height))+1:x.mipmaps!==void 0&&x.mipmaps.length>0?x.mipmaps.length:x.isCompressedTexture&&Array.isArray(x.image)?y.mipmaps.length:1}function M(x){return x===Ae||x===Vl||x===zl?9728:9729}function R(x){const y=x.target;y.removeEventListener("dispose",R),N(y),y.isVideoTexture&&Q.delete(y)}function U(x){const y=x.target;y.removeEventListener("dispose",U),T(y)}function N(x){const y=e.get(x);if(y.__webglInit===void 0)return;const b=x.source,X=l.get(b);if(X){const j=X[y.__cacheKey];j.usedTimes--,j.usedTimes===0&&G(x),Object.keys(X).length===0&&l.delete(b)}e.remove(x)}function G(x){const y=e.get(x);i.deleteTexture(y.__webglTexture);const b=x.source,X=l.get(b);delete X[y.__cacheKey],o.memory.textures--}function T(x){const y=x.texture,b=e.get(x),X=e.get(y);if(X.__webglTexture!==void 0&&(i.deleteTexture(X.__webglTexture),o.memory.textures--),x.depthTexture&&x.depthTexture.dispose(),x.isWebGLCubeRenderTarget)for(let j=0;j<6;j++)i.deleteFramebuffer(b.__webglFramebuffer[j]),b.__webglDepthbuffer&&i.deleteRenderbuffer(b.__webglDepthbuffer[j]);else{if(i.deleteFramebuffer(b.__webglFramebuffer),b.__webglDepthbuffer&&i.deleteRenderbuffer(b.__webglDepthbuffer),b.__webglMultisampledFramebuffer&&i.deleteFramebuffer(b.__webglMultisampledFramebuffer),b.__webglColorRenderbuffer)for(let j=0;j<b.__webglColorRenderbuffer.length;j++)b.__webglColorRenderbuffer[j]&&i.deleteRenderbuffer(b.__webglColorRenderbuffer[j]);b.__webglDepthRenderbuffer&&i.deleteRenderbuffer(b.__webglDepthRenderbuffer)}if(x.isWebGLMultipleRenderTargets)for(let j=0,eA=y.length;j<eA;j++){const sA=e.get(y[j]);sA.__webglTexture&&(i.deleteTexture(sA.__webglTexture),o.memory.textures--),e.remove(y[j])}e.remove(y),e.remove(x)}let V=0;function tA(){V=0}function z(){const x=V;return x>=I&&console.warn("THREE.WebGLTextures: Trying to use "+x+" texture units while this GPU supports only "+I),V+=1,x}function W(x){const y=[];return y.push(x.wrapS),y.push(x.wrapT),y.push(x.magFilter),y.push(x.minFilter),y.push(x.anisotropy),y.push(x.internalFormat),y.push(x.format),y.push(x.type),y.push(x.generateMipmaps),y.push(x.premultiplyAlpha),y.push(x.flipY),y.push(x.unpackAlignment),y.push(x.encoding),y.join()}function Y(x,y){const b=e.get(x);if(x.isVideoTexture&&rt(x),x.isRenderTargetTexture===!1&&x.version>0&&b.__version!==x.version){const X=x.image;if(X===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(X.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{uA(b,x,y);return}}t.bindTexture(3553,b.__webglTexture,33984+y)}function CA(x,y){const b=e.get(x);if(x.version>0&&b.__version!==x.version){uA(b,x,y);return}t.bindTexture(35866,b.__webglTexture,33984+y)}function K(x,y){const b=e.get(x);if(x.version>0&&b.__version!==x.version){uA(b,x,y);return}t.bindTexture(32879,b.__webglTexture,33984+y)}function AA(x,y){const b=e.get(x);if(x.version>0&&b.__version!==x.version){mA(b,x,y);return}t.bindTexture(34067,b.__webglTexture,33984+y)}const lA={[Ks]:10497,[se]:33071,[Tn]:33648},Z={[Ae]:9728,[Vl]:9984,[zl]:9986,[Wt]:9729,[Ad]:9985,[ao]:9987};function oA(x,y,b){if(b?(i.texParameteri(x,10242,lA[y.wrapS]),i.texParameteri(x,10243,lA[y.wrapT]),(x===32879||x===35866)&&i.texParameteri(x,32882,lA[y.wrapR]),i.texParameteri(x,10240,Z[y.magFilter]),i.texParameteri(x,10241,Z[y.minFilter])):(i.texParameteri(x,10242,33071),i.texParameteri(x,10243,33071),(x===32879||x===35866)&&i.texParameteri(x,32882,33071),(y.wrapS!==se||y.wrapT!==se)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),i.texParameteri(x,10240,M(y.magFilter)),i.texParameteri(x,10241,M(y.minFilter)),y.minFilter!==Ae&&y.minFilter!==Wt&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),A.has("EXT_texture_filter_anisotropic")===!0){const X=A.get("EXT_texture_filter_anisotropic");if(y.type===ni&&A.has("OES_texture_float_linear")===!1||s===!1&&y.type===Ri&&A.has("OES_texture_half_float_linear")===!1)return;(y.anisotropy>1||e.get(y).__currentAnisotropy)&&(i.texParameterf(x,X.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(y.anisotropy,n.getMaxAnisotropy())),e.get(y).__currentAnisotropy=y.anisotropy)}}function wA(x,y){let b=!1;x.__webglInit===void 0&&(x.__webglInit=!0,y.addEventListener("dispose",R));const X=y.source;let j=l.get(X);j===void 0&&(j={},l.set(X,j));const eA=W(y);if(eA!==x.__cacheKey){j[eA]===void 0&&(j[eA]={texture:i.createTexture(),usedTimes:0},o.memory.textures++,b=!0),j[eA].usedTimes++;const sA=j[x.__cacheKey];sA!==void 0&&(j[x.__cacheKey].usedTimes--,sA.usedTimes===0&&G(y)),x.__cacheKey=eA,x.__webglTexture=j[eA].texture}return b}function uA(x,y,b){let X=3553;y.isDataArrayTexture&&(X=35866),y.isData3DTexture&&(X=32879);const j=wA(x,y),eA=y.source;t.bindTexture(X,x.__webglTexture,33984+b);const sA=e.get(eA);if(eA.version!==sA.__version||j===!0){t.activeTexture(33984+b),i.pixelStorei(37440,y.flipY),i.pixelStorei(37441,y.premultiplyAlpha),i.pixelStorei(3317,y.unpackAlignment),i.pixelStorei(37443,0);const L=m(y)&&d(y.image)===!1;let k=u(y.image,L,!1,g);k=$A(y,k);const hA=d(k)||s,BA=a.convert(y.format,y.encoding);let EA=a.convert(y.type),dA=p(y.internalFormat,BA,EA,y.encoding,y.isVideoTexture);oA(X,y,hA);let yA;const bA=y.mipmaps,nA=s&&y.isVideoTexture!==!0,xA=sA.__version===void 0||j===!0,O=w(y,k,hA);if(y.isDepthTexture)dA=6402,s?y.type===ni?dA=36012:y.type===Mn?dA=33190:y.type===Ka?dA=35056:dA=33189:y.type===ni&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),y.format===Ln&&dA===6402&&y.type!==bc&&y.type!==Mn&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),y.type=Mn,EA=a.convert(y.type)),y.format===As&&dA===6402&&(dA=34041,y.type!==Ka&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),y.type=Ka,EA=a.convert(y.type))),xA&&(nA?t.texStorage2D(3553,1,dA,k.width,k.height):t.texImage2D(3553,0,dA,k.width,k.height,0,BA,EA,null));else if(y.isDataTexture)if(bA.length>0&&hA){nA&&xA&&t.texStorage2D(3553,O,dA,bA[0].width,bA[0].height);for(let $=0,gA=bA.length;$<gA;$++)yA=bA[$],nA?t.texSubImage2D(3553,$,0,0,yA.width,yA.height,BA,EA,yA.data):t.texImage2D(3553,$,dA,yA.width,yA.height,0,BA,EA,yA.data);y.generateMipmaps=!1}else nA?(xA&&t.texStorage2D(3553,O,dA,k.width,k.height),t.texSubImage2D(3553,0,0,0,k.width,k.height,BA,EA,k.data)):t.texImage2D(3553,0,dA,k.width,k.height,0,BA,EA,k.data);else if(y.isCompressedTexture){nA&&xA&&t.texStorage2D(3553,O,dA,bA[0].width,bA[0].height);for(let $=0,gA=bA.length;$<gA;$++)yA=bA[$],y.format!==ai?BA!==null?nA?t.compressedTexSubImage2D(3553,$,0,0,yA.width,yA.height,BA,yA.data):t.compressedTexImage2D(3553,$,dA,yA.width,yA.height,0,yA.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):nA?t.texSubImage2D(3553,$,0,0,yA.width,yA.height,BA,EA,yA.data):t.texImage2D(3553,$,dA,yA.width,yA.height,0,BA,EA,yA.data)}else if(y.isDataArrayTexture)nA?(xA&&t.texStorage3D(35866,O,dA,k.width,k.height,k.depth),t.texSubImage3D(35866,0,0,0,0,k.width,k.height,k.depth,BA,EA,k.data)):t.texImage3D(35866,0,dA,k.width,k.height,k.depth,0,BA,EA,k.data);else if(y.isData3DTexture)nA?(xA&&t.texStorage3D(32879,O,dA,k.width,k.height,k.depth),t.texSubImage3D(32879,0,0,0,0,k.width,k.height,k.depth,BA,EA,k.data)):t.texImage3D(32879,0,dA,k.width,k.height,k.depth,0,BA,EA,k.data);else if(y.isFramebufferTexture){if(xA)if(nA)t.texStorage2D(3553,O,dA,k.width,k.height);else{let $=k.width,gA=k.height;for(let pA=0;pA<O;pA++)t.texImage2D(3553,pA,dA,$,gA,0,BA,EA,null),$>>=1,gA>>=1}}else if(bA.length>0&&hA){nA&&xA&&t.texStorage2D(3553,O,dA,bA[0].width,bA[0].height);for(let $=0,gA=bA.length;$<gA;$++)yA=bA[$],nA?t.texSubImage2D(3553,$,0,0,BA,EA,yA):t.texImage2D(3553,$,dA,BA,EA,yA);y.generateMipmaps=!1}else nA?(xA&&t.texStorage2D(3553,O,dA,k.width,k.height),t.texSubImage2D(3553,0,0,0,BA,EA,k)):t.texImage2D(3553,0,dA,BA,EA,k);S(y,hA)&&D(X),sA.__version=eA.version,y.onUpdate&&y.onUpdate(y)}x.__version=y.version}function mA(x,y,b){if(y.image.length!==6)return;const X=wA(x,y),j=y.source;t.bindTexture(34067,x.__webglTexture,33984+b);const eA=e.get(j);if(j.version!==eA.__version||X===!0){t.activeTexture(33984+b),i.pixelStorei(37440,y.flipY),i.pixelStorei(37441,y.premultiplyAlpha),i.pixelStorei(3317,y.unpackAlignment),i.pixelStorei(37443,0);const sA=y.isCompressedTexture||y.image[0].isCompressedTexture,L=y.image[0]&&y.image[0].isDataTexture,k=[];for(let $=0;$<6;$++)!sA&&!L?k[$]=u(y.image[$],!1,!0,r):k[$]=L?y.image[$].image:y.image[$],k[$]=$A(y,k[$]);const hA=k[0],BA=d(hA)||s,EA=a.convert(y.format,y.encoding),dA=a.convert(y.type),yA=p(y.internalFormat,EA,dA,y.encoding),bA=s&&y.isVideoTexture!==!0,nA=eA.__version===void 0||X===!0;let xA=w(y,hA,BA);oA(34067,y,BA);let O;if(sA){bA&&nA&&t.texStorage2D(34067,xA,yA,hA.width,hA.height);for(let $=0;$<6;$++){O=k[$].mipmaps;for(let gA=0;gA<O.length;gA++){const pA=O[gA];y.format!==ai?EA!==null?bA?t.compressedTexSubImage2D(34069+$,gA,0,0,pA.width,pA.height,EA,pA.data):t.compressedTexImage2D(34069+$,gA,yA,pA.width,pA.height,0,pA.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):bA?t.texSubImage2D(34069+$,gA,0,0,pA.width,pA.height,EA,dA,pA.data):t.texImage2D(34069+$,gA,yA,pA.width,pA.height,0,EA,dA,pA.data)}}}else{O=y.mipmaps,bA&&nA&&(O.length>0&&xA++,t.texStorage2D(34067,xA,yA,k[0].width,k[0].height));for(let $=0;$<6;$++)if(L){bA?t.texSubImage2D(34069+$,0,0,0,k[$].width,k[$].height,EA,dA,k[$].data):t.texImage2D(34069+$,0,yA,k[$].width,k[$].height,0,EA,dA,k[$].data);for(let gA=0;gA<O.length;gA++){const FA=O[gA].image[$].image;bA?t.texSubImage2D(34069+$,gA+1,0,0,FA.width,FA.height,EA,dA,FA.data):t.texImage2D(34069+$,gA+1,yA,FA.width,FA.height,0,EA,dA,FA.data)}}else{bA?t.texSubImage2D(34069+$,0,0,0,EA,dA,k[$]):t.texImage2D(34069+$,0,yA,EA,dA,k[$]);for(let gA=0;gA<O.length;gA++){const pA=O[gA];bA?t.texSubImage2D(34069+$,gA+1,0,0,EA,dA,pA.image[$]):t.texImage2D(34069+$,gA+1,yA,EA,dA,pA.image[$])}}}S(y,BA)&&D(34067),eA.__version=j.version,y.onUpdate&&y.onUpdate(y)}x.__version=y.version}function fA(x,y,b,X,j){const eA=a.convert(b.format,b.encoding),sA=a.convert(b.type),L=p(b.internalFormat,eA,sA,b.encoding);e.get(y).__hasExternalTextures||(j===32879||j===35866?t.texImage3D(j,0,L,y.width,y.height,y.depth,0,eA,sA,null):t.texImage2D(j,0,L,y.width,y.height,0,eA,sA,null)),t.bindFramebuffer(36160,x),kA(y)?B.framebufferTexture2DMultisampleEXT(36160,X,j,e.get(b).__webglTexture,0,HA(y)):i.framebufferTexture2D(36160,X,j,e.get(b).__webglTexture,0),t.bindFramebuffer(36160,null)}function RA(x,y,b){if(i.bindRenderbuffer(36161,x),y.depthBuffer&&!y.stencilBuffer){let X=33189;if(b||kA(y)){const j=y.depthTexture;j&&j.isDepthTexture&&(j.type===ni?X=36012:j.type===Mn&&(X=33190));const eA=HA(y);kA(y)?B.renderbufferStorageMultisampleEXT(36161,eA,X,y.width,y.height):i.renderbufferStorageMultisample(36161,eA,X,y.width,y.height)}else i.renderbufferStorage(36161,X,y.width,y.height);i.framebufferRenderbuffer(36160,36096,36161,x)}else if(y.depthBuffer&&y.stencilBuffer){const X=HA(y);b&&kA(y)===!1?i.renderbufferStorageMultisample(36161,X,35056,y.width,y.height):kA(y)?B.renderbufferStorageMultisampleEXT(36161,X,35056,y.width,y.height):i.renderbufferStorage(36161,34041,y.width,y.height),i.framebufferRenderbuffer(36160,33306,36161,x)}else{const X=y.isWebGLMultipleRenderTargets===!0?y.texture:[y.texture];for(let j=0;j<X.length;j++){const eA=X[j],sA=a.convert(eA.format,eA.encoding),L=a.convert(eA.type),k=p(eA.internalFormat,sA,L,eA.encoding),hA=HA(y);b&&kA(y)===!1?i.renderbufferStorageMultisample(36161,hA,k,y.width,y.height):kA(y)?B.renderbufferStorageMultisampleEXT(36161,hA,k,y.width,y.height):i.renderbufferStorage(36161,k,y.width,y.height)}}i.bindRenderbuffer(36161,null)}function MA(x,y){if(y&&y.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,x),!(y.depthTexture&&y.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!e.get(y.depthTexture).__webglTexture||y.depthTexture.image.width!==y.width||y.depthTexture.image.height!==y.height)&&(y.depthTexture.image.width=y.width,y.depthTexture.image.height=y.height,y.depthTexture.needsUpdate=!0),Y(y.depthTexture,0);const X=e.get(y.depthTexture).__webglTexture,j=HA(y);if(y.depthTexture.format===Ln)kA(y)?B.framebufferTexture2DMultisampleEXT(36160,36096,3553,X,0,j):i.framebufferTexture2D(36160,36096,3553,X,0);else if(y.depthTexture.format===As)kA(y)?B.framebufferTexture2DMultisampleEXT(36160,33306,3553,X,0,j):i.framebufferTexture2D(36160,33306,3553,X,0);else throw new Error("Unknown depthTexture format")}function SA(x){const y=e.get(x),b=x.isWebGLCubeRenderTarget===!0;if(x.depthTexture&&!y.__autoAllocateDepthBuffer){if(b)throw new Error("target.depthTexture not supported in Cube render targets");MA(y.__webglFramebuffer,x)}else if(b){y.__webglDepthbuffer=[];for(let X=0;X<6;X++)t.bindFramebuffer(36160,y.__webglFramebuffer[X]),y.__webglDepthbuffer[X]=i.createRenderbuffer(),RA(y.__webglDepthbuffer[X],x,!1)}else t.bindFramebuffer(36160,y.__webglFramebuffer),y.__webglDepthbuffer=i.createRenderbuffer(),RA(y.__webglDepthbuffer,x,!1);t.bindFramebuffer(36160,null)}function TA(x,y,b){const X=e.get(x);y!==void 0&&fA(X.__webglFramebuffer,x,x.texture,36064,3553),b!==void 0&&SA(x)}function OA(x){const y=x.texture,b=e.get(x),X=e.get(y);x.addEventListener("dispose",U),x.isWebGLMultipleRenderTargets!==!0&&(X.__webglTexture===void 0&&(X.__webglTexture=i.createTexture()),X.__version=y.version,o.memory.textures++);const j=x.isWebGLCubeRenderTarget===!0,eA=x.isWebGLMultipleRenderTargets===!0,sA=d(x)||s;if(j){b.__webglFramebuffer=[];for(let L=0;L<6;L++)b.__webglFramebuffer[L]=i.createFramebuffer()}else{if(b.__webglFramebuffer=i.createFramebuffer(),eA)if(n.drawBuffers){const L=x.texture;for(let k=0,hA=L.length;k<hA;k++){const BA=e.get(L[k]);BA.__webglTexture===void 0&&(BA.__webglTexture=i.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(s&&x.samples>0&&kA(x)===!1){const L=eA?y:[y];b.__webglMultisampledFramebuffer=i.createFramebuffer(),b.__webglColorRenderbuffer=[],t.bindFramebuffer(36160,b.__webglMultisampledFramebuffer);for(let k=0;k<L.length;k++){const hA=L[k];b.__webglColorRenderbuffer[k]=i.createRenderbuffer(),i.bindRenderbuffer(36161,b.__webglColorRenderbuffer[k]);const BA=a.convert(hA.format,hA.encoding),EA=a.convert(hA.type),dA=p(hA.internalFormat,BA,EA,hA.encoding,x.isXRRenderTarget===!0),yA=HA(x);i.renderbufferStorageMultisample(36161,yA,dA,x.width,x.height),i.framebufferRenderbuffer(36160,36064+k,36161,b.__webglColorRenderbuffer[k])}i.bindRenderbuffer(36161,null),x.depthBuffer&&(b.__webglDepthRenderbuffer=i.createRenderbuffer(),RA(b.__webglDepthRenderbuffer,x,!0)),t.bindFramebuffer(36160,null)}}if(j){t.bindTexture(34067,X.__webglTexture),oA(34067,y,sA);for(let L=0;L<6;L++)fA(b.__webglFramebuffer[L],x,y,36064,34069+L);S(y,sA)&&D(34067),t.unbindTexture()}else if(eA){const L=x.texture;for(let k=0,hA=L.length;k<hA;k++){const BA=L[k],EA=e.get(BA);t.bindTexture(3553,EA.__webglTexture),oA(3553,BA,sA),fA(b.__webglFramebuffer,x,BA,36064+k,3553),S(BA,sA)&&D(3553)}t.unbindTexture()}else{let L=3553;(x.isWebGL3DRenderTarget||x.isWebGLArrayRenderTarget)&&(s?L=x.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(L,X.__webglTexture),oA(L,y,sA),fA(b.__webglFramebuffer,x,y,36064,L),S(y,sA)&&D(L),t.unbindTexture()}x.depthBuffer&&SA(x)}function JA(x){const y=d(x)||s,b=x.isWebGLMultipleRenderTargets===!0?x.texture:[x.texture];for(let X=0,j=b.length;X<j;X++){const eA=b[X];if(S(eA,y)){const sA=x.isWebGLCubeRenderTarget?34067:3553,L=e.get(eA).__webglTexture;t.bindTexture(sA,L),D(sA),t.unbindTexture()}}}function YA(x){if(s&&x.samples>0&&kA(x)===!1){const y=x.isWebGLMultipleRenderTargets?x.texture:[x.texture],b=x.width,X=x.height;let j=16384;const eA=[],sA=x.stencilBuffer?33306:36096,L=e.get(x),k=x.isWebGLMultipleRenderTargets===!0;if(k)for(let hA=0;hA<y.length;hA++)t.bindFramebuffer(36160,L.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(36160,36064+hA,36161,null),t.bindFramebuffer(36160,L.__webglFramebuffer),i.framebufferTexture2D(36009,36064+hA,3553,null,0);t.bindFramebuffer(36008,L.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,L.__webglFramebuffer);for(let hA=0;hA<y.length;hA++){eA.push(36064+hA),x.depthBuffer&&eA.push(sA);const BA=L.__ignoreDepthValues!==void 0?L.__ignoreDepthValues:!1;if(BA===!1&&(x.depthBuffer&&(j|=256),x.stencilBuffer&&(j|=1024)),k&&i.framebufferRenderbuffer(36008,36064,36161,L.__webglColorRenderbuffer[hA]),BA===!0&&(i.invalidateFramebuffer(36008,[sA]),i.invalidateFramebuffer(36009,[sA])),k){const EA=e.get(y[hA]).__webglTexture;i.framebufferTexture2D(36009,36064,3553,EA,0)}i.blitFramebuffer(0,0,b,X,0,0,b,X,j,9728),c&&i.invalidateFramebuffer(36008,eA)}if(t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,null),k)for(let hA=0;hA<y.length;hA++){t.bindFramebuffer(36160,L.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(36160,36064+hA,36161,L.__webglColorRenderbuffer[hA]);const BA=e.get(y[hA]).__webglTexture;t.bindFramebuffer(36160,L.__webglFramebuffer),i.framebufferTexture2D(36009,36064+hA,3553,BA,0)}t.bindFramebuffer(36009,L.__webglMultisampledFramebuffer)}}function HA(x){return Math.min(C,x.samples)}function kA(x){const y=e.get(x);return s&&x.samples>0&&A.has("WEBGL_multisampled_render_to_texture")===!0&&y.__useRenderToTexture!==!1}function rt(x){const y=o.render.frame;Q.get(x)!==y&&(Q.set(x,y),x.update())}function $A(x,y){const b=x.encoding,X=x.format,j=x.type;return x.isCompressedTexture===!0||x.isVideoTexture===!0||x.format===vI||b!==gn&&(b===ut?s===!1?A.has("EXT_sRGB")===!0&&X===ai?(x.format=vI,x.minFilter=Wt,x.generateMipmaps=!1):y=Tc.sRGBToLinear(y):(X!==ai||j!==Hn)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",b)),y}this.allocateTextureUnit=z,this.resetTextureUnits=tA,this.setTexture2D=Y,this.setTexture2DArray=CA,this.setTexture3D=K,this.setTextureCube=AA,this.rebindTextures=TA,this.setupRenderTarget=OA,this.updateRenderTargetMipmap=JA,this.updateMultisampleRenderTarget=YA,this.setupDepthRenderbuffer=SA,this.setupFrameBufferTexture=fA,this.useMultisampledRTT=kA}function lm(i,A,t){const e=t.isWebGL2;function n(a,o=null){let s;if(a===Hn)return 5121;if(a===nd)return 32819;if(a===ad)return 32820;if(a===td)return 5120;if(a===ed)return 5122;if(a===bc)return 5123;if(a===id)return 5124;if(a===Mn)return 5125;if(a===ni)return 5126;if(a===Ri)return e?5131:(s=A.get("OES_texture_half_float"),s!==null?s.HALF_FLOAT_OES:null);if(a===sd)return 6406;if(a===ai)return 6408;if(a===rd)return 6409;if(a===gd)return 6410;if(a===Ln)return 6402;if(a===As)return 34041;if(a===Id)return 6403;if(a===od)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(a===vI)return s=A.get("EXT_sRGB"),s!==null?s.SRGB_ALPHA_EXT:null;if(a===ld)return 36244;if(a===Cd)return 33319;if(a===Bd)return 33320;if(a===hd)return 36249;if(a===Wr||a===Vr||a===zr||a===Xr)if(o===ut)if(s=A.get("WEBGL_compressed_texture_s3tc_srgb"),s!==null){if(a===Wr)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(a===Vr)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(a===zr)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(a===Xr)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(s=A.get("WEBGL_compressed_texture_s3tc"),s!==null){if(a===Wr)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(a===Vr)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(a===zr)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(a===Xr)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(a===Xl||a===Zl||a===jl||a===$l)if(s=A.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(a===Xl)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(a===Zl)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(a===jl)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(a===$l)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(a===cd)return s=A.get("WEBGL_compressed_texture_etc1"),s!==null?s.COMPRESSED_RGB_ETC1_WEBGL:null;if(a===AC||a===tC)if(s=A.get("WEBGL_compressed_texture_etc"),s!==null){if(a===AC)return o===ut?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(a===tC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(a===eC||a===iC||a===nC||a===aC||a===sC||a===oC||a===rC||a===gC||a===IC||a===lC||a===CC||a===BC||a===hC||a===cC)if(s=A.get("WEBGL_compressed_texture_astc"),s!==null){if(a===eC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(a===iC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(a===nC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(a===aC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(a===sC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(a===oC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(a===rC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(a===gC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(a===IC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(a===lC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(a===CC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(a===BC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(a===hC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(a===cC)return o===ut?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(a===EC)if(s=A.get("EXT_texture_compression_bptc"),s!==null){if(a===EC)return o===ut?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;return a===Ka?e?34042:(s=A.get("WEBGL_depth_texture"),s!==null?s.UNSIGNED_INT_24_8_WEBGL:null):i[a]!==void 0?i[a]:null}return{convert:n}}class Cm extends le{constructor(A=[]){super(),this.isArrayCamera=!0,this.cameras=A}}class Zi extends vt{constructor(){super(),this.isGroup=!0,this.type="Group"}}const Bm={type:"move"};class Dg{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Zi,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Zi,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new rA,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new rA),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Zi,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new rA,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new rA),this._grip}dispatchEvent(A){return this._targetRay!==null&&this._targetRay.dispatchEvent(A),this._grip!==null&&this._grip.dispatchEvent(A),this._hand!==null&&this._hand.dispatchEvent(A),this}disconnect(A){return this.dispatchEvent({type:"disconnected",data:A}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(A,t,e){let n=null,a=null,o=null;const s=this._targetRay,I=this._grip,r=this._hand;if(A&&t.session.visibilityState!=="visible-blurred"){if(r&&A.hand){o=!0;for(const h of A.hand.values()){const l=t.getJointPose(h,e);if(r.joints[h.jointName]===void 0){const f=new Zi;f.matrixAutoUpdate=!1,f.visible=!1,r.joints[h.jointName]=f,r.add(f)}const E=r.joints[h.jointName];l!==null&&(E.matrix.fromArray(l.transform.matrix),E.matrix.decompose(E.position,E.rotation,E.scale),E.jointRadius=l.radius),E.visible=l!==null}const g=r.joints["index-finger-tip"],C=r.joints["thumb-tip"],B=g.position.distanceTo(C.position),c=.02,Q=.005;r.inputState.pinching&&B>c+Q?(r.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:A.handedness,target:this})):!r.inputState.pinching&&B<=c-Q&&(r.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:A.handedness,target:this}))}else I!==null&&A.gripSpace&&(a=t.getPose(A.gripSpace,e),a!==null&&(I.matrix.fromArray(a.transform.matrix),I.matrix.decompose(I.position,I.rotation,I.scale),a.linearVelocity?(I.hasLinearVelocity=!0,I.linearVelocity.copy(a.linearVelocity)):I.hasLinearVelocity=!1,a.angularVelocity?(I.hasAngularVelocity=!0,I.angularVelocity.copy(a.angularVelocity)):I.hasAngularVelocity=!1));s!==null&&(n=t.getPose(A.targetRaySpace,e),n===null&&a!==null&&(n=a),n!==null&&(s.matrix.fromArray(n.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),n.linearVelocity?(s.hasLinearVelocity=!0,s.linearVelocity.copy(n.linearVelocity)):s.hasLinearVelocity=!1,n.angularVelocity?(s.hasAngularVelocity=!0,s.angularVelocity.copy(n.angularVelocity)):s.hasAngularVelocity=!1,this.dispatchEvent(Bm)))}return s!==null&&(s.visible=n!==null),I!==null&&(I.visible=a!==null),r!==null&&(r.visible=o!==null),this}}class hm extends we{constructor(A,t,e,n,a,o,s,I,r,g){if(g=g!==void 0?g:Ln,g!==Ln&&g!==As)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");e===void 0&&g===Ln&&(e=Mn),e===void 0&&g===As&&(e=Ka),super(null,n,a,o,s,I,g,e,r),this.isDepthTexture=!0,this.image={width:A,height:t},this.magFilter=s!==void 0?s:Ae,this.minFilter=I!==void 0?I:Ae,this.flipY=!1,this.generateMipmaps=!1}}class cm extends $n{constructor(A,t){super();const e=this;let n=null,a=1,o=null,s="local-floor",I=null,r=null,g=null,C=null,B=null,c=null;const Q=t.getContextAttributes();let h=null,l=null;const E=[],f=[],u=new le;u.layers.enable(1),u.viewport=new dt;const d=new le;d.layers.enable(2),d.viewport=new dt;const m=[u,d],S=new Cm;S.layers.enable(1),S.layers.enable(2);let D=null,p=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(W){let Y=E[W];return Y===void 0&&(Y=new Dg,E[W]=Y),Y.getTargetRaySpace()},this.getControllerGrip=function(W){let Y=E[W];return Y===void 0&&(Y=new Dg,E[W]=Y),Y.getGripSpace()},this.getHand=function(W){let Y=E[W];return Y===void 0&&(Y=new Dg,E[W]=Y),Y.getHandSpace()};function w(W){const Y=f.indexOf(W.inputSource);if(Y===-1)return;const CA=E[Y];CA!==void 0&&CA.dispatchEvent({type:W.type,data:W.inputSource})}function M(){n.removeEventListener("select",w),n.removeEventListener("selectstart",w),n.removeEventListener("selectend",w),n.removeEventListener("squeeze",w),n.removeEventListener("squeezestart",w),n.removeEventListener("squeezeend",w),n.removeEventListener("end",M),n.removeEventListener("inputsourceschange",R);for(let W=0;W<E.length;W++){const Y=f[W];Y!==null&&(f[W]=null,E[W].disconnect(Y))}D=null,p=null,A.setRenderTarget(h),B=null,C=null,g=null,n=null,l=null,z.stop(),e.isPresenting=!1,e.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(W){a=W,e.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(W){s=W,e.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return I||o},this.setReferenceSpace=function(W){I=W},this.getBaseLayer=function(){return C!==null?C:B},this.getBinding=function(){return g},this.getFrame=function(){return c},this.getSession=function(){return n},this.setSession=async function(W){if(n=W,n!==null){if(h=A.getRenderTarget(),n.addEventListener("select",w),n.addEventListener("selectstart",w),n.addEventListener("selectend",w),n.addEventListener("squeeze",w),n.addEventListener("squeezestart",w),n.addEventListener("squeezeend",w),n.addEventListener("end",M),n.addEventListener("inputsourceschange",R),Q.xrCompatible!==!0&&await t.makeXRCompatible(),n.renderState.layers===void 0||A.capabilities.isWebGL2===!1){const Y={antialias:n.renderState.layers===void 0?Q.antialias:!0,alpha:Q.alpha,depth:Q.depth,stencil:Q.stencil,framebufferScaleFactor:a};B=new XRWebGLLayer(n,t,Y),n.updateRenderState({baseLayer:B}),l=new qn(B.framebufferWidth,B.framebufferHeight,{format:ai,type:Hn,encoding:A.outputEncoding,stencilBuffer:Q.stencil})}else{let Y=null,CA=null,K=null;Q.depth&&(K=Q.stencil?35056:33190,Y=Q.stencil?As:Ln,CA=Q.stencil?Ka:Mn);const AA={colorFormat:32856,depthFormat:K,scaleFactor:a};g=new XRWebGLBinding(n,t),C=g.createProjectionLayer(AA),n.updateRenderState({layers:[C]}),l=new qn(C.textureWidth,C.textureHeight,{format:ai,type:Hn,depthTexture:new hm(C.textureWidth,C.textureHeight,CA,void 0,void 0,void 0,void 0,void 0,void 0,Y),stencilBuffer:Q.stencil,encoding:A.outputEncoding,samples:Q.antialias?4:0});const lA=A.properties.get(l);lA.__ignoreDepthValues=C.ignoreDepthValues}l.isXRRenderTarget=!0,this.setFoveation(1),I=null,o=await n.requestReferenceSpace(s),z.setContext(n),z.start(),e.isPresenting=!0,e.dispatchEvent({type:"sessionstart"})}};function R(W){for(let Y=0;Y<W.removed.length;Y++){const CA=W.removed[Y],K=f.indexOf(CA);K>=0&&(f[K]=null,E[K].dispatchEvent({type:"disconnected",data:CA}))}for(let Y=0;Y<W.added.length;Y++){const CA=W.added[Y];let K=f.indexOf(CA);if(K===-1){for(let lA=0;lA<E.length;lA++)if(lA>=f.length){f.push(CA),K=lA;break}else if(f[lA]===null){f[lA]=CA,K=lA;break}if(K===-1)break}const AA=E[K];AA&&AA.dispatchEvent({type:"connected",data:CA})}}const U=new rA,N=new rA;function G(W,Y,CA){U.setFromMatrixPosition(Y.matrixWorld),N.setFromMatrixPosition(CA.matrixWorld);const K=U.distanceTo(N),AA=Y.projectionMatrix.elements,lA=CA.projectionMatrix.elements,Z=AA[14]/(AA[10]-1),oA=AA[14]/(AA[10]+1),wA=(AA[9]+1)/AA[5],uA=(AA[9]-1)/AA[5],mA=(AA[8]-1)/AA[0],fA=(lA[8]+1)/lA[0],RA=Z*mA,MA=Z*fA,SA=K/(-mA+fA),TA=SA*-mA;Y.matrixWorld.decompose(W.position,W.quaternion,W.scale),W.translateX(TA),W.translateZ(SA),W.matrixWorld.compose(W.position,W.quaternion,W.scale),W.matrixWorldInverse.copy(W.matrixWorld).invert();const OA=Z+SA,JA=oA+SA,YA=RA-TA,HA=MA+(K-TA),kA=wA*oA/JA*OA,rt=uA*oA/JA*OA;W.projectionMatrix.makePerspective(YA,HA,kA,rt,OA,JA)}function T(W,Y){Y===null?W.matrixWorld.copy(W.matrix):W.matrixWorld.multiplyMatrices(Y.matrixWorld,W.matrix),W.matrixWorldInverse.copy(W.matrixWorld).invert()}this.updateCamera=function(W){if(n===null)return;S.near=d.near=u.near=W.near,S.far=d.far=u.far=W.far,(D!==S.near||p!==S.far)&&(n.updateRenderState({depthNear:S.near,depthFar:S.far}),D=S.near,p=S.far);const Y=W.parent,CA=S.cameras;T(S,Y);for(let AA=0;AA<CA.length;AA++)T(CA[AA],Y);S.matrixWorld.decompose(S.position,S.quaternion,S.scale),W.matrix.copy(S.matrix),W.matrix.decompose(W.position,W.quaternion,W.scale);const K=W.children;for(let AA=0,lA=K.length;AA<lA;AA++)K[AA].updateMatrixWorld(!0);CA.length===2?G(S,u,d):S.projectionMatrix.copy(u.projectionMatrix)},this.getCamera=function(){return S},this.getFoveation=function(){if(C!==null)return C.fixedFoveation;if(B!==null)return B.fixedFoveation},this.setFoveation=function(W){C!==null&&(C.fixedFoveation=W),B!==null&&B.fixedFoveation!==void 0&&(B.fixedFoveation=W)};let V=null;function tA(W,Y){if(r=Y.getViewerPose(I||o),c=Y,r!==null){const CA=r.views;B!==null&&(A.setRenderTargetFramebuffer(l,B.framebuffer),A.setRenderTarget(l));let K=!1;CA.length!==S.cameras.length&&(S.cameras.length=0,K=!0);for(let AA=0;AA<CA.length;AA++){const lA=CA[AA];let Z=null;if(B!==null)Z=B.getViewport(lA);else{const wA=g.getViewSubImage(C,lA);Z=wA.viewport,AA===0&&(A.setRenderTargetTextures(l,wA.colorTexture,C.ignoreDepthValues?void 0:wA.depthStencilTexture),A.setRenderTarget(l))}let oA=m[AA];oA===void 0&&(oA=new le,oA.layers.enable(AA),oA.viewport=new dt,m[AA]=oA),oA.matrix.fromArray(lA.transform.matrix),oA.projectionMatrix.fromArray(lA.projectionMatrix),oA.viewport.set(Z.x,Z.y,Z.width,Z.height),AA===0&&S.matrix.copy(oA.matrix),K===!0&&S.cameras.push(oA)}}for(let CA=0;CA<E.length;CA++){const K=f[CA],AA=E[CA];K!==null&&AA!==void 0&&AA.update(K,Y,I||o)}V&&V(W,Y),c=null}const z=new Wc;z.setAnimationLoop(tA),this.setAnimationLoop=function(W){V=W},this.dispose=function(){}}}function Em(i,A){function t(h,l){h.fogColor.value.copy(l.color),l.isFog?(h.fogNear.value=l.near,h.fogFar.value=l.far):l.isFogExp2&&(h.fogDensity.value=l.density)}function e(h,l,E,f,u){l.isMeshBasicMaterial||l.isMeshLambertMaterial?n(h,l):l.isMeshToonMaterial?(n(h,l),g(h,l)):l.isMeshPhongMaterial?(n(h,l),r(h,l)):l.isMeshStandardMaterial?(n(h,l),C(h,l),l.isMeshPhysicalMaterial&&B(h,l,u)):l.isMeshMatcapMaterial?(n(h,l),c(h,l)):l.isMeshDepthMaterial?n(h,l):l.isMeshDistanceMaterial?(n(h,l),Q(h,l)):l.isMeshNormalMaterial?n(h,l):l.isLineBasicMaterial?(a(h,l),l.isLineDashedMaterial&&o(h,l)):l.isPointsMaterial?s(h,l,E,f):l.isSpriteMaterial?I(h,l):l.isShadowMaterial?(h.color.value.copy(l.color),h.opacity.value=l.opacity):l.isShaderMaterial&&(l.uniformsNeedUpdate=!1)}function n(h,l){h.opacity.value=l.opacity,l.color&&h.diffuse.value.copy(l.color),l.emissive&&h.emissive.value.copy(l.emissive).multiplyScalar(l.emissiveIntensity),l.map&&(h.map.value=l.map),l.alphaMap&&(h.alphaMap.value=l.alphaMap),l.bumpMap&&(h.bumpMap.value=l.bumpMap,h.bumpScale.value=l.bumpScale,l.side===ve&&(h.bumpScale.value*=-1)),l.displacementMap&&(h.displacementMap.value=l.displacementMap,h.displacementScale.value=l.displacementScale,h.displacementBias.value=l.displacementBias),l.emissiveMap&&(h.emissiveMap.value=l.emissiveMap),l.normalMap&&(h.normalMap.value=l.normalMap,h.normalScale.value.copy(l.normalScale),l.side===ve&&h.normalScale.value.negate()),l.specularMap&&(h.specularMap.value=l.specularMap),l.alphaTest>0&&(h.alphaTest.value=l.alphaTest);const E=A.get(l).envMap;if(E&&(h.envMap.value=E,h.flipEnvMap.value=E.isCubeTexture&&E.isRenderTargetTexture===!1?-1:1,h.reflectivity.value=l.reflectivity,h.ior.value=l.ior,h.refractionRatio.value=l.refractionRatio),l.lightMap){h.lightMap.value=l.lightMap;const d=i.physicallyCorrectLights!==!0?Math.PI:1;h.lightMapIntensity.value=l.lightMapIntensity*d}l.aoMap&&(h.aoMap.value=l.aoMap,h.aoMapIntensity.value=l.aoMapIntensity);let f;l.map?f=l.map:l.specularMap?f=l.specularMap:l.displacementMap?f=l.displacementMap:l.normalMap?f=l.normalMap:l.bumpMap?f=l.bumpMap:l.roughnessMap?f=l.roughnessMap:l.metalnessMap?f=l.metalnessMap:l.alphaMap?f=l.alphaMap:l.emissiveMap?f=l.emissiveMap:l.clearcoatMap?f=l.clearcoatMap:l.clearcoatNormalMap?f=l.clearcoatNormalMap:l.clearcoatRoughnessMap?f=l.clearcoatRoughnessMap:l.iridescenceMap?f=l.iridescenceMap:l.iridescenceThicknessMap?f=l.iridescenceThicknessMap:l.specularIntensityMap?f=l.specularIntensityMap:l.specularColorMap?f=l.specularColorMap:l.transmissionMap?f=l.transmissionMap:l.thicknessMap?f=l.thicknessMap:l.sheenColorMap?f=l.sheenColorMap:l.sheenRoughnessMap&&(f=l.sheenRoughnessMap),f!==void 0&&(f.isWebGLRenderTarget&&(f=f.texture),f.matrixAutoUpdate===!0&&f.updateMatrix(),h.uvTransform.value.copy(f.matrix));let u;l.aoMap?u=l.aoMap:l.lightMap&&(u=l.lightMap),u!==void 0&&(u.isWebGLRenderTarget&&(u=u.texture),u.matrixAutoUpdate===!0&&u.updateMatrix(),h.uv2Transform.value.copy(u.matrix))}function a(h,l){h.diffuse.value.copy(l.color),h.opacity.value=l.opacity}function o(h,l){h.dashSize.value=l.dashSize,h.totalSize.value=l.dashSize+l.gapSize,h.scale.value=l.scale}function s(h,l,E,f){h.diffuse.value.copy(l.color),h.opacity.value=l.opacity,h.size.value=l.size*E,h.scale.value=f*.5,l.map&&(h.map.value=l.map),l.alphaMap&&(h.alphaMap.value=l.alphaMap),l.alphaTest>0&&(h.alphaTest.value=l.alphaTest);let u;l.map?u=l.map:l.alphaMap&&(u=l.alphaMap),u!==void 0&&(u.matrixAutoUpdate===!0&&u.updateMatrix(),h.uvTransform.value.copy(u.matrix))}function I(h,l){h.diffuse.value.copy(l.color),h.opacity.value=l.opacity,h.rotation.value=l.rotation,l.map&&(h.map.value=l.map),l.alphaMap&&(h.alphaMap.value=l.alphaMap),l.alphaTest>0&&(h.alphaTest.value=l.alphaTest);let E;l.map?E=l.map:l.alphaMap&&(E=l.alphaMap),E!==void 0&&(E.matrixAutoUpdate===!0&&E.updateMatrix(),h.uvTransform.value.copy(E.matrix))}function r(h,l){h.specular.value.copy(l.specular),h.shininess.value=Math.max(l.shininess,1e-4)}function g(h,l){l.gradientMap&&(h.gradientMap.value=l.gradientMap)}function C(h,l){h.roughness.value=l.roughness,h.metalness.value=l.metalness,l.roughnessMap&&(h.roughnessMap.value=l.roughnessMap),l.metalnessMap&&(h.metalnessMap.value=l.metalnessMap),A.get(l).envMap&&(h.envMapIntensity.value=l.envMapIntensity)}function B(h,l,E){h.ior.value=l.ior,l.sheen>0&&(h.sheenColor.value.copy(l.sheenColor).multiplyScalar(l.sheen),h.sheenRoughness.value=l.sheenRoughness,l.sheenColorMap&&(h.sheenColorMap.value=l.sheenColorMap),l.sheenRoughnessMap&&(h.sheenRoughnessMap.value=l.sheenRoughnessMap)),l.clearcoat>0&&(h.clearcoat.value=l.clearcoat,h.clearcoatRoughness.value=l.clearcoatRoughness,l.clearcoatMap&&(h.clearcoatMap.value=l.clearcoatMap),l.clearcoatRoughnessMap&&(h.clearcoatRoughnessMap.value=l.clearcoatRoughnessMap),l.clearcoatNormalMap&&(h.clearcoatNormalScale.value.copy(l.clearcoatNormalScale),h.clearcoatNormalMap.value=l.clearcoatNormalMap,l.side===ve&&h.clearcoatNormalScale.value.negate())),l.iridescence>0&&(h.iridescence.value=l.iridescence,h.iridescenceIOR.value=l.iridescenceIOR,h.iridescenceThicknessMinimum.value=l.iridescenceThicknessRange[0],h.iridescenceThicknessMaximum.value=l.iridescenceThicknessRange[1],l.iridescenceMap&&(h.iridescenceMap.value=l.iridescenceMap),l.iridescenceThicknessMap&&(h.iridescenceThicknessMap.value=l.iridescenceThicknessMap)),l.transmission>0&&(h.transmission.value=l.transmission,h.transmissionSamplerMap.value=E.texture,h.transmissionSamplerSize.value.set(E.width,E.height),l.transmissionMap&&(h.transmissionMap.value=l.transmissionMap),h.thickness.value=l.thickness,l.thicknessMap&&(h.thicknessMap.value=l.thicknessMap),h.attenuationDistance.value=l.attenuationDistance,h.attenuationColor.value.copy(l.attenuationColor)),h.specularIntensity.value=l.specularIntensity,h.specularColor.value.copy(l.specularColor),l.specularIntensityMap&&(h.specularIntensityMap.value=l.specularIntensityMap),l.specularColorMap&&(h.specularColorMap.value=l.specularColorMap)}function c(h,l){l.matcap&&(h.matcap.value=l.matcap)}function Q(h,l){h.referencePosition.value.copy(l.referencePosition),h.nearDistance.value=l.nearDistance,h.farDistance.value=l.farDistance}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function Qm(i,A,t,e){let n={},a={},o=[];const s=t.isWebGL2?i.getParameter(35375):0;function I(f,u){const d=u.program;e.uniformBlockBinding(f,d)}function r(f,u){let d=n[f.id];d===void 0&&(Q(f),d=g(f),n[f.id]=d,f.addEventListener("dispose",l));const m=u.program;e.updateUBOMapping(f,m);const S=A.render.frame;a[f.id]!==S&&(B(f),a[f.id]=S)}function g(f){const u=C();f.__bindingPointIndex=u;const d=i.createBuffer(),m=f.__size,S=f.usage;return i.bindBuffer(35345,d),i.bufferData(35345,m,S),i.bindBuffer(35345,null),i.bindBufferBase(35345,u,d),d}function C(){for(let f=0;f<s;f++)if(o.indexOf(f)===-1)return o.push(f),f;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function B(f){const u=n[f.id],d=f.uniforms,m=f.__cache;i.bindBuffer(35345,u);for(let S=0,D=d.length;S<D;S++){const p=d[S];if(c(p,S,m)===!0){const w=p.value,M=p.__offset;typeof w=="number"?(p.__data[0]=w,i.bufferSubData(35345,M,p.__data)):(p.value.isMatrix3?(p.__data[0]=p.value.elements[0],p.__data[1]=p.value.elements[1],p.__data[2]=p.value.elements[2],p.__data[3]=p.value.elements[0],p.__data[4]=p.value.elements[3],p.__data[5]=p.value.elements[4],p.__data[6]=p.value.elements[5],p.__data[7]=p.value.elements[0],p.__data[8]=p.value.elements[6],p.__data[9]=p.value.elements[7],p.__data[10]=p.value.elements[8],p.__data[11]=p.value.elements[0]):w.toArray(p.__data),i.bufferSubData(35345,M,p.__data))}}i.bindBuffer(35345,null)}function c(f,u,d){const m=f.value;if(d[u]===void 0)return typeof m=="number"?d[u]=m:d[u]=m.clone(),!0;if(typeof m=="number"){if(d[u]!==m)return d[u]=m,!0}else{const S=d[u];if(S.equals(m)===!1)return S.copy(m),!0}return!1}function Q(f){const u=f.uniforms;let d=0;const m=16;let S=0;for(let D=0,p=u.length;D<p;D++){const w=u[D],M=h(w);if(w.__data=new Float32Array(M.storage/Float32Array.BYTES_PER_ELEMENT),w.__offset=d,D>0){S=d%m;const R=m-S;S!==0&&R-M.boundary<0&&(d+=m-S,w.__offset=d)}d+=M.storage}return S=d%m,S>0&&(d+=m-S),f.__size=d,f.__cache={},this}function h(f){const u=f.value,d={boundary:0,storage:0};return typeof u=="number"?(d.boundary=4,d.storage=4):u.isVector2?(d.boundary=8,d.storage=8):u.isVector3||u.isColor?(d.boundary=16,d.storage=12):u.isVector4?(d.boundary=16,d.storage=16):u.isMatrix3?(d.boundary=48,d.storage=48):u.isMatrix4?(d.boundary=64,d.storage=64):u.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",u),d}function l(f){const u=f.target;u.removeEventListener("dispose",l);const d=o.indexOf(u.__bindingPointIndex);o.splice(d,1),i.deleteBuffer(n[u.id]),delete n[u.id],delete a[u.id]}function E(){for(const f in n)i.deleteBuffer(n[f]);o=[],n={},a={}}return{bind:I,update:r,dispose:E}}function dm(){const i=Os("canvas");return i.style.display="block",i}function $c(i={}){this.isWebGLRenderer=!0;const A=i.canvas!==void 0?i.canvas:dm(),t=i.context!==void 0?i.context:null,e=i.depth!==void 0?i.depth:!0,n=i.stencil!==void 0?i.stencil:!0,a=i.antialias!==void 0?i.antialias:!1,o=i.premultipliedAlpha!==void 0?i.premultipliedAlpha:!0,s=i.preserveDrawingBuffer!==void 0?i.preserveDrawingBuffer:!1,I=i.powerPreference!==void 0?i.powerPreference:"default",r=i.failIfMajorPerformanceCaveat!==void 0?i.failIfMajorPerformanceCaveat:!1;let g;t!==null?g=t.getContextAttributes().alpha:g=i.alpha!==void 0?i.alpha:!1;let C=null,B=null;const c=[],Q=[];this.domElement=A,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=gn,this.physicallyCorrectLights=!1,this.toneMapping=Gi,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});const h=this;let l=!1,E=0,f=0,u=null,d=-1,m=null;const S=new dt,D=new dt;let p=null,w=A.width,M=A.height,R=1,U=null,N=null;const G=new dt(0,0,w,M),T=new dt(0,0,w,M);let V=!1;const tA=new El;let z=!1,W=!1,Y=null;const CA=new _t,K=new XA,AA=new rA,lA={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Z(){return u===null?R:1}let oA=t;function wA(F,J){for(let q=0;q<F.length;q++){const _=F[q],v=A.getContext(_,J);if(v!==null)return v}return null}try{const F={alpha:!0,depth:e,stencil:n,antialias:a,premultipliedAlpha:o,preserveDrawingBuffer:s,powerPreference:I,failIfMajorPerformanceCaveat:r};if("setAttribute"in A&&A.setAttribute("data-engine",`three.js r${Cl}`),A.addEventListener("webglcontextlost",dA,!1),A.addEventListener("webglcontextrestored",yA,!1),A.addEventListener("webglcontextcreationerror",bA,!1),oA===null){const J=["webgl2","webgl","experimental-webgl"];if(h.isWebGL1Renderer===!0&&J.shift(),oA=wA(J,F),oA===null)throw wA(J)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}oA.getShaderPrecisionFormat===void 0&&(oA.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(F){throw console.error("THREE.WebGLRenderer: "+F.message),F}let uA,mA,fA,RA,MA,SA,TA,OA,JA,YA,HA,kA,rt,$A,x,y,b,X,j,eA,sA,L,k,hA;function BA(){uA=new Mp(oA),mA=new yp(oA,uA,i),uA.init(mA),L=new lm(oA,uA,mA),fA=new gm(oA,uA,mA),RA=new vp,MA=new z0,SA=new Im(oA,uA,fA,MA,mA,L,RA),TA=new Sp(h),OA=new xp(h),JA=new Jd(oA,mA),k=new pp(oA,uA,JA,mA),YA=new Fp(oA,JA,RA,k),HA=new bp(oA,YA,JA,RA),j=new Lp(oA,mA,SA),y=new Dp(MA),kA=new V0(h,TA,OA,uA,mA,k,y),rt=new Em(h,MA),$A=new Z0,x=new im(uA,mA),X=new up(h,TA,fA,HA,g,o),b=new rm(h,HA,mA),hA=new Qm(oA,RA,mA,fA),eA=new mp(oA,uA,RA,mA),sA=new Rp(oA,uA,RA,mA),RA.programs=kA.programs,h.capabilities=mA,h.extensions=uA,h.properties=MA,h.renderLists=$A,h.shadowMap=b,h.state=fA,h.info=RA}BA();const EA=new cm(h,oA);this.xr=EA,this.getContext=function(){return oA},this.getContextAttributes=function(){return oA.getContextAttributes()},this.forceContextLoss=function(){const F=uA.get("WEBGL_lose_context");F&&F.loseContext()},this.forceContextRestore=function(){const F=uA.get("WEBGL_lose_context");F&&F.restoreContext()},this.getPixelRatio=function(){return R},this.setPixelRatio=function(F){F!==void 0&&(R=F,this.setSize(w,M,!1))},this.getSize=function(F){return F.set(w,M)},this.setSize=function(F,J,q){if(EA.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}w=F,M=J,A.width=Math.floor(F*R),A.height=Math.floor(J*R),q!==!1&&(A.style.width=F+"px",A.style.height=J+"px"),this.setViewport(0,0,F,J)},this.getDrawingBufferSize=function(F){return F.set(w*R,M*R).floor()},this.setDrawingBufferSize=function(F,J,q){w=F,M=J,R=q,A.width=Math.floor(F*q),A.height=Math.floor(J*q),this.setViewport(0,0,F,J)},this.getCurrentViewport=function(F){return F.copy(S)},this.getViewport=function(F){return F.copy(G)},this.setViewport=function(F,J,q,_){F.isVector4?G.set(F.x,F.y,F.z,F.w):G.set(F,J,q,_),fA.viewport(S.copy(G).multiplyScalar(R).floor())},this.getScissor=function(F){return F.copy(T)},this.setScissor=function(F,J,q,_){F.isVector4?T.set(F.x,F.y,F.z,F.w):T.set(F,J,q,_),fA.scissor(D.copy(T).multiplyScalar(R).floor())},this.getScissorTest=function(){return V},this.setScissorTest=function(F){fA.setScissorTest(V=F)},this.setOpaqueSort=function(F){U=F},this.setTransparentSort=function(F){N=F},this.getClearColor=function(F){return F.copy(X.getClearColor())},this.setClearColor=function(){X.setClearColor.apply(X,arguments)},this.getClearAlpha=function(){return X.getClearAlpha()},this.setClearAlpha=function(){X.setClearAlpha.apply(X,arguments)},this.clear=function(F=!0,J=!0,q=!0){let _=0;F&&(_|=16384),J&&(_|=256),q&&(_|=1024),oA.clear(_)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){A.removeEventListener("webglcontextlost",dA,!1),A.removeEventListener("webglcontextrestored",yA,!1),A.removeEventListener("webglcontextcreationerror",bA,!1),$A.dispose(),x.dispose(),MA.dispose(),TA.dispose(),OA.dispose(),HA.dispose(),k.dispose(),hA.dispose(),kA.dispose(),EA.dispose(),EA.removeEventListener("sessionstart",pA),EA.removeEventListener("sessionend",FA),Y&&(Y.dispose(),Y=null),PA.stop()};function dA(F){F.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),l=!0}function yA(){console.log("THREE.WebGLRenderer: Context Restored."),l=!1;const F=RA.autoReset,J=b.enabled,q=b.autoUpdate,_=b.needsUpdate,v=b.type;BA(),RA.autoReset=F,b.enabled=J,b.autoUpdate=q,b.needsUpdate=_,b.type=v}function bA(F){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",F.statusMessage)}function nA(F){const J=F.target;J.removeEventListener("dispose",nA),xA(J)}function xA(F){O(F),MA.remove(F)}function O(F){const J=MA.get(F).programs;J!==void 0&&(J.forEach(function(q){kA.releaseProgram(q)}),F.isShaderMaterial&&kA.releaseShaderCache(F))}this.renderBufferDirect=function(F,J,q,_,v,P){J===null&&(J=lA);const iA=v.isMesh&&v.matrixWorld.determinant()<0,aA=ia(F,J,q,_,v);fA.setMaterial(_,iA);let IA=q.index;const DA=q.attributes.position;if(IA===null){if(DA===void 0||DA.count===0)return}else if(IA.count===0)return;let QA=1;_.wireframe===!0&&(IA=YA.getWireframeAttribute(q),QA=2),k.setup(v,_,aA,q,IA);let _A,NA=eA;IA!==null&&(_A=JA.get(IA),NA=sA,NA.setIndex(_A));const KA=IA!==null?IA.count:DA.count,WA=q.drawRange.start*QA,jA=q.drawRange.count*QA,qA=P!==null?P.start*QA:0,LA=P!==null?P.count*QA:1/0,lt=Math.max(WA,qA),et=Math.min(KA,WA+jA,qA+LA)-1,pt=Math.max(0,et-lt+1);if(pt!==0){if(v.isMesh)_.wireframe===!0?(fA.setLineWidth(_.wireframeLinewidth*Z()),NA.setMode(1)):NA.setMode(4);else if(v.isLine){let Pt=_.linewidth;Pt===void 0&&(Pt=1),fA.setLineWidth(Pt*Z()),v.isLineSegments?NA.setMode(1):v.isLineLoop?NA.setMode(2):NA.setMode(3)}else v.isPoints?NA.setMode(0):v.isSprite&&NA.setMode(4);if(v.isInstancedMesh)NA.renderInstances(lt,pt,v.count);else if(q.isInstancedBufferGeometry){const Pt=Math.min(q.instanceCount,q._maxInstanceCount);NA.renderInstances(lt,pt,Pt)}else NA.render(lt,pt)}},this.compile=function(F,J){function q(_,v,P){_.transparent===!0&&_.side===Xi?(_.side=ve,_.needsUpdate=!0,yt(_,v,P),_.side=Za,_.needsUpdate=!0,yt(_,v,P),_.side=Xi):yt(_,v,P)}B=x.get(F),B.init(),Q.push(B),F.traverseVisible(function(_){_.isLight&&_.layers.test(J.layers)&&(B.pushLight(_),_.castShadow&&B.pushShadow(_))}),B.setupLights(h.physicallyCorrectLights),F.traverse(function(_){const v=_.material;if(v)if(Array.isArray(v))for(let P=0;P<v.length;P++){const iA=v[P];q(iA,F,_)}else q(v,F,_)}),Q.pop(),B=null};let $=null;function gA(F){$&&$(F)}function pA(){PA.stop()}function FA(){PA.start()}const PA=new Wc;PA.setAnimationLoop(gA),typeof self<"u"&&PA.setContext(self),this.setAnimationLoop=function(F){$=F,EA.setAnimationLoop(F),F===null?PA.stop():PA.start()},EA.addEventListener("sessionstart",pA),EA.addEventListener("sessionend",FA),this.render=function(F,J){if(J!==void 0&&J.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(l===!0)return;F.matrixWorldAutoUpdate===!0&&F.updateMatrixWorld(),J.parent===null&&J.matrixWorldAutoUpdate===!0&&J.updateMatrixWorld(),EA.enabled===!0&&EA.isPresenting===!0&&(EA.cameraAutoUpdate===!0&&EA.updateCamera(J),J=EA.getCamera()),F.isScene===!0&&F.onBeforeRender(h,F,J,u),B=x.get(F,Q.length),B.init(),Q.push(B),CA.multiplyMatrices(J.projectionMatrix,J.matrixWorldInverse),tA.setFromProjectionMatrix(CA),W=this.localClippingEnabled,z=y.init(this.clippingPlanes,W,J),C=$A.get(F,c.length),C.init(),c.push(C),ot(F,J,0,h.sortObjects),C.finish(),h.sortObjects===!0&&C.sort(U,N),z===!0&&y.beginShadows();const q=B.state.shadowsArray;if(b.render(q,F,J),z===!0&&y.endShadows(),this.info.autoReset===!0&&this.info.reset(),X.render(C,F),B.setupLights(h.physicallyCorrectLights),J.isArrayCamera){const _=J.cameras;for(let v=0,P=_.length;v<P;v++){const iA=_[v];zA(C,F,iA,iA.viewport)}}else zA(C,F,J);u!==null&&(SA.updateMultisampleRenderTarget(u),SA.updateRenderTargetMipmap(u)),F.isScene===!0&&F.onAfterRender(h,F,J),k.resetDefaultState(),d=-1,m=null,Q.pop(),Q.length>0?B=Q[Q.length-1]:B=null,c.pop(),c.length>0?C=c[c.length-1]:C=null};function ot(F,J,q,_){if(F.visible===!1)return;if(F.layers.test(J.layers)){if(F.isGroup)q=F.renderOrder;else if(F.isLOD)F.autoUpdate===!0&&F.update(J);else if(F.isLight)B.pushLight(F),F.castShadow&&B.pushShadow(F);else if(F.isSprite){if(!F.frustumCulled||tA.intersectsSprite(F)){_&&AA.setFromMatrixPosition(F.matrixWorld).applyMatrix4(CA);const iA=HA.update(F),aA=F.material;aA.visible&&C.push(F,iA,aA,q,AA.z,null)}}else if((F.isMesh||F.isLine||F.isPoints)&&(F.isSkinnedMesh&&F.skeleton.frame!==RA.render.frame&&(F.skeleton.update(),F.skeleton.frame=RA.render.frame),!F.frustumCulled||tA.intersectsObject(F))){_&&AA.setFromMatrixPosition(F.matrixWorld).applyMatrix4(CA);const iA=HA.update(F),aA=F.material;if(Array.isArray(aA)){const IA=iA.groups;for(let DA=0,QA=IA.length;DA<QA;DA++){const _A=IA[DA],NA=aA[_A.materialIndex];NA&&NA.visible&&C.push(F,iA,NA,q,AA.z,_A)}}else aA.visible&&C.push(F,iA,aA,q,AA.z,null)}}const P=F.children;for(let iA=0,aA=P.length;iA<aA;iA++)ot(P[iA],J,q,_)}function zA(F,J,q,_){const v=F.opaque,P=F.transmissive,iA=F.transparent;B.setupLightsView(q),P.length>0&&Et(v,J,q),_&&fA.viewport(S.copy(_)),v.length>0&&tt(v,J,q),P.length>0&&tt(P,J,q),iA.length>0&&tt(iA,J,q),fA.buffers.depth.setTest(!0),fA.buffers.depth.setMask(!0),fA.buffers.color.setMask(!0),fA.setPolygonOffset(!1)}function Et(F,J,q){const _=mA.isWebGL2;Y===null&&(Y=new qn(1,1,{generateMipmaps:!0,type:uA.has("EXT_color_buffer_half_float")?Ri:Hn,minFilter:ao,samples:_&&a===!0?4:0})),h.getDrawingBufferSize(K),_?Y.setSize(K.x,K.y):Y.setSize(NI(K.x),NI(K.y));const v=h.getRenderTarget();h.setRenderTarget(Y),h.clear();const P=h.toneMapping;h.toneMapping=Gi,tt(F,J,q),h.toneMapping=P,SA.updateMultisampleRenderTarget(Y),SA.updateRenderTargetMipmap(Y),h.setRenderTarget(v)}function tt(F,J,q){const _=J.isScene===!0?J.overrideMaterial:null;for(let v=0,P=F.length;v<P;v++){const iA=F[v],aA=iA.object,IA=iA.geometry,DA=_===null?iA.material:_,QA=iA.group;aA.layers.test(q.layers)&&Jt(aA,J,q,IA,DA,QA)}}function Jt(F,J,q,_,v,P){F.onBeforeRender(h,J,q,_,v,P),F.modelViewMatrix.multiplyMatrices(q.matrixWorldInverse,F.matrixWorld),F.normalMatrix.getNormalMatrix(F.modelViewMatrix),v.onBeforeRender(h,J,q,_,F,P),v.transparent===!0&&v.side===Xi?(v.side=ve,v.needsUpdate=!0,h.renderBufferDirect(q,J,_,v,F,P),v.side=Za,v.needsUpdate=!0,h.renderBufferDirect(q,J,_,v,F,P),v.side=Xi):h.renderBufferDirect(q,J,_,v,F,P),F.onAfterRender(h,J,q,_,v,P)}function yt(F,J,q){J.isScene!==!0&&(J=lA);const _=MA.get(F),v=B.state.lights,P=B.state.shadowsArray,iA=v.state.version,aA=kA.getParameters(F,v.state,P,J,q),IA=kA.getProgramCacheKey(aA);let DA=_.programs;_.environment=F.isMeshStandardMaterial?J.environment:null,_.fog=J.fog,_.envMap=(F.isMeshStandardMaterial?OA:TA).get(F.envMap||_.environment),DA===void 0&&(F.addEventListener("dispose",nA),DA=new Map,_.programs=DA);let QA=DA.get(IA);if(QA!==void 0){if(_.currentProgram===QA&&_.lightsStateVersion===iA)return ea(F,aA),QA}else aA.uniforms=kA.getUniforms(F),F.onBuild(q,aA,h),F.onBeforeCompile(aA,h),QA=kA.acquireProgram(aA,IA),DA.set(IA,QA),_.uniforms=aA.uniforms;const _A=_.uniforms;(!F.isShaderMaterial&&!F.isRawShaderMaterial||F.clipping===!0)&&(_A.clippingPlanes=y.uniform),ea(F,aA),_.needsLights=H(F),_.lightsStateVersion=iA,_.needsLights&&(_A.ambientLightColor.value=v.state.ambient,_A.lightProbe.value=v.state.probe,_A.directionalLights.value=v.state.directional,_A.directionalLightShadows.value=v.state.directionalShadow,_A.spotLights.value=v.state.spot,_A.spotLightShadows.value=v.state.spotShadow,_A.rectAreaLights.value=v.state.rectArea,_A.ltc_1.value=v.state.rectAreaLTC1,_A.ltc_2.value=v.state.rectAreaLTC2,_A.pointLights.value=v.state.point,_A.pointLightShadows.value=v.state.pointShadow,_A.hemisphereLights.value=v.state.hemi,_A.directionalShadowMap.value=v.state.directionalShadowMap,_A.directionalShadowMatrix.value=v.state.directionalShadowMatrix,_A.spotShadowMap.value=v.state.spotShadowMap,_A.spotLightMatrix.value=v.state.spotLightMatrix,_A.spotLightMap.value=v.state.spotLightMap,_A.pointShadowMap.value=v.state.pointShadowMap,_A.pointShadowMatrix.value=v.state.pointShadowMatrix);const NA=QA.getUniforms(),KA=hr.seqWithValue(NA.seq,_A);return _.currentProgram=QA,_.uniformsList=KA,QA}function ea(F,J){const q=MA.get(F);q.outputEncoding=J.outputEncoding,q.instancing=J.instancing,q.skinning=J.skinning,q.morphTargets=J.morphTargets,q.morphNormals=J.morphNormals,q.morphColors=J.morphColors,q.morphTargetsCount=J.morphTargetsCount,q.numClippingPlanes=J.numClippingPlanes,q.numIntersection=J.numClipIntersection,q.vertexAlphas=J.vertexAlphas,q.vertexTangents=J.vertexTangents,q.toneMapping=J.toneMapping}function ia(F,J,q,_,v){J.isScene!==!0&&(J=lA),SA.resetTextureUnits();const P=J.fog,iA=_.isMeshStandardMaterial?J.environment:null,aA=u===null?h.outputEncoding:u.isXRRenderTarget===!0?u.texture.encoding:gn,IA=(_.isMeshStandardMaterial?OA:TA).get(_.envMap||iA),DA=_.vertexColors===!0&&!!q.attributes.color&&q.attributes.color.itemSize===4,QA=!!_.normalMap&&!!q.attributes.tangent,_A=!!q.morphAttributes.position,NA=!!q.morphAttributes.normal,KA=!!q.morphAttributes.color,WA=_.toneMapped?h.toneMapping:Gi,jA=q.morphAttributes.position||q.morphAttributes.normal||q.morphAttributes.color,qA=jA!==void 0?jA.length:0,LA=MA.get(_),lt=B.state.lights;if(z===!0&&(W===!0||F!==m)){const Kt=F===m&&_.id===d;y.setState(_,F,Kt)}let et=!1;_.version===LA.__version?(LA.needsLights&&LA.lightsStateVersion!==lt.state.version||LA.outputEncoding!==aA||v.isInstancedMesh&&LA.instancing===!1||!v.isInstancedMesh&&LA.instancing===!0||v.isSkinnedMesh&&LA.skinning===!1||!v.isSkinnedMesh&&LA.skinning===!0||LA.envMap!==IA||_.fog===!0&&LA.fog!==P||LA.numClippingPlanes!==void 0&&(LA.numClippingPlanes!==y.numPlanes||LA.numIntersection!==y.numIntersection)||LA.vertexAlphas!==DA||LA.vertexTangents!==QA||LA.morphTargets!==_A||LA.morphNormals!==NA||LA.morphColors!==KA||LA.toneMapping!==WA||mA.isWebGL2===!0&&LA.morphTargetsCount!==qA)&&(et=!0):(et=!0,LA.__version=_.version);let pt=LA.currentProgram;et===!0&&(pt=yt(_,J,v));let Pt=!1,li=!1,Mt=!1;const ft=pt.getUniforms(),Le=LA.uniforms;if(fA.useProgram(pt.program)&&(Pt=!0,li=!0,Mt=!0),_.id!==d&&(d=_.id,li=!0),Pt||m!==F){if(ft.setValue(oA,"projectionMatrix",F.projectionMatrix),mA.logarithmicDepthBuffer&&ft.setValue(oA,"logDepthBufFC",2/(Math.log(F.far+1)/Math.LN2)),m!==F&&(m=F,li=!0,Mt=!0),_.isShaderMaterial||_.isMeshPhongMaterial||_.isMeshToonMaterial||_.isMeshStandardMaterial||_.envMap){const Kt=ft.map.cameraPosition;Kt!==void 0&&Kt.setValue(oA,AA.setFromMatrixPosition(F.matrixWorld))}(_.isMeshPhongMaterial||_.isMeshToonMaterial||_.isMeshLambertMaterial||_.isMeshBasicMaterial||_.isMeshStandardMaterial||_.isShaderMaterial)&&ft.setValue(oA,"isOrthographic",F.isOrthographicCamera===!0),(_.isMeshPhongMaterial||_.isMeshToonMaterial||_.isMeshLambertMaterial||_.isMeshBasicMaterial||_.isMeshStandardMaterial||_.isShaderMaterial||_.isShadowMaterial||v.isSkinnedMesh)&&ft.setValue(oA,"viewMatrix",F.matrixWorldInverse)}if(v.isSkinnedMesh){ft.setOptional(oA,v,"bindMatrix"),ft.setOptional(oA,v,"bindMatrixInverse");const Kt=v.skeleton;Kt&&(mA.floatVertexTextures?(Kt.boneTexture===null&&Kt.computeBoneTexture(),ft.setValue(oA,"boneTexture",Kt.boneTexture,SA),ft.setValue(oA,"boneTextureSize",Kt.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const Yt=q.morphAttributes;if((Yt.position!==void 0||Yt.normal!==void 0||Yt.color!==void 0&&mA.isWebGL2===!0)&&j.update(v,q,_,pt),(li||LA.receiveShadow!==v.receiveShadow)&&(LA.receiveShadow=v.receiveShadow,ft.setValue(oA,"receiveShadow",v.receiveShadow)),_.isMeshGouraudMaterial&&_.envMap!==null&&(Le.envMap.value=IA,Le.flipEnvMap.value=IA.isCubeTexture&&IA.isRenderTargetTexture===!1?-1:1),li&&(ft.setValue(oA,"toneMappingExposure",h.toneMappingExposure),LA.needsLights&&Li(Le,Mt),P&&_.fog===!0&&rt.refreshFogUniforms(Le,P),rt.refreshMaterialUniforms(Le,_,R,M,Y),hr.upload(oA,LA.uniformsList,Le,SA)),_.isShaderMaterial&&_.uniformsNeedUpdate===!0&&(hr.upload(oA,LA.uniformsList,Le,SA),_.uniformsNeedUpdate=!1),_.isSpriteMaterial&&ft.setValue(oA,"center",v.center),ft.setValue(oA,"modelViewMatrix",v.modelViewMatrix),ft.setValue(oA,"normalMatrix",v.normalMatrix),ft.setValue(oA,"modelMatrix",v.matrixWorld),_.isShaderMaterial||_.isRawShaderMaterial){const Kt=_.uniformsGroups;for(let cs=0,Eo=Kt.length;cs<Eo;cs++)if(mA.isWebGL2){const ql=Kt[cs];hA.update(ql,pt),hA.bind(ql,pt)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return pt}function Li(F,J){F.ambientLightColor.needsUpdate=J,F.lightProbe.needsUpdate=J,F.directionalLights.needsUpdate=J,F.directionalLightShadows.needsUpdate=J,F.pointLights.needsUpdate=J,F.pointLightShadows.needsUpdate=J,F.spotLights.needsUpdate=J,F.spotLightShadows.needsUpdate=J,F.rectAreaLights.needsUpdate=J,F.hemisphereLights.needsUpdate=J}function H(F){return F.isMeshLambertMaterial||F.isMeshToonMaterial||F.isMeshPhongMaterial||F.isMeshStandardMaterial||F.isShadowMaterial||F.isShaderMaterial&&F.lights===!0}this.getActiveCubeFace=function(){return E},this.getActiveMipmapLevel=function(){return f},this.getRenderTarget=function(){return u},this.setRenderTargetTextures=function(F,J,q){MA.get(F.texture).__webglTexture=J,MA.get(F.depthTexture).__webglTexture=q;const _=MA.get(F);_.__hasExternalTextures=!0,_.__hasExternalTextures&&(_.__autoAllocateDepthBuffer=q===void 0,_.__autoAllocateDepthBuffer||uA.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),_.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(F,J){const q=MA.get(F);q.__webglFramebuffer=J,q.__useDefaultFramebuffer=J===void 0},this.setRenderTarget=function(F,J=0,q=0){u=F,E=J,f=q;let _=!0;if(F){const IA=MA.get(F);IA.__useDefaultFramebuffer!==void 0?(fA.bindFramebuffer(36160,null),_=!1):IA.__webglFramebuffer===void 0?SA.setupRenderTarget(F):IA.__hasExternalTextures&&SA.rebindTextures(F,MA.get(F.texture).__webglTexture,MA.get(F.depthTexture).__webglTexture)}let v=null,P=!1,iA=!1;if(F){const IA=F.texture;(IA.isData3DTexture||IA.isDataArrayTexture)&&(iA=!0);const DA=MA.get(F).__webglFramebuffer;F.isWebGLCubeRenderTarget?(v=DA[J],P=!0):mA.isWebGL2&&F.samples>0&&SA.useMultisampledRTT(F)===!1?v=MA.get(F).__webglMultisampledFramebuffer:v=DA,S.copy(F.viewport),D.copy(F.scissor),p=F.scissorTest}else S.copy(G).multiplyScalar(R).floor(),D.copy(T).multiplyScalar(R).floor(),p=V;if(fA.bindFramebuffer(36160,v)&&mA.drawBuffers&&_&&fA.drawBuffers(F,v),fA.viewport(S),fA.scissor(D),fA.setScissorTest(p),P){const IA=MA.get(F.texture);oA.framebufferTexture2D(36160,36064,34069+J,IA.__webglTexture,q)}else if(iA){const IA=MA.get(F.texture),DA=J||0;oA.framebufferTextureLayer(36160,36064,IA.__webglTexture,q||0,DA)}d=-1},this.readRenderTargetPixels=function(F,J,q,_,v,P,iA){if(!(F&&F.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let aA=MA.get(F).__webglFramebuffer;if(F.isWebGLCubeRenderTarget&&iA!==void 0&&(aA=aA[iA]),aA){fA.bindFramebuffer(36160,aA);try{const IA=F.texture,DA=IA.format,QA=IA.type;if(DA!==ai&&L.convert(DA)!==oA.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const _A=QA===Ri&&(uA.has("EXT_color_buffer_half_float")||mA.isWebGL2&&uA.has("EXT_color_buffer_float"));if(QA!==Hn&&L.convert(QA)!==oA.getParameter(35738)&&!(QA===ni&&(mA.isWebGL2||uA.has("OES_texture_float")||uA.has("WEBGL_color_buffer_float")))&&!_A){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}J>=0&&J<=F.width-_&&q>=0&&q<=F.height-v&&oA.readPixels(J,q,_,v,L.convert(DA),L.convert(QA),P)}finally{const IA=u!==null?MA.get(u).__webglFramebuffer:null;fA.bindFramebuffer(36160,IA)}}},this.copyFramebufferToTexture=function(F,J,q=0){const _=Math.pow(2,-q),v=Math.floor(J.image.width*_),P=Math.floor(J.image.height*_);SA.setTexture2D(J,0),oA.copyTexSubImage2D(3553,q,0,0,F.x,F.y,v,P),fA.unbindTexture()},this.copyTextureToTexture=function(F,J,q,_=0){const v=J.image.width,P=J.image.height,iA=L.convert(q.format),aA=L.convert(q.type);SA.setTexture2D(q,0),oA.pixelStorei(37440,q.flipY),oA.pixelStorei(37441,q.premultiplyAlpha),oA.pixelStorei(3317,q.unpackAlignment),J.isDataTexture?oA.texSubImage2D(3553,_,F.x,F.y,v,P,iA,aA,J.image.data):J.isCompressedTexture?oA.compressedTexSubImage2D(3553,_,F.x,F.y,J.mipmaps[0].width,J.mipmaps[0].height,iA,J.mipmaps[0].data):oA.texSubImage2D(3553,_,F.x,F.y,iA,aA,J.image),_===0&&q.generateMipmaps&&oA.generateMipmap(3553),fA.unbindTexture()},this.copyTextureToTexture3D=function(F,J,q,_,v=0){if(h.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const P=F.max.x-F.min.x+1,iA=F.max.y-F.min.y+1,aA=F.max.z-F.min.z+1,IA=L.convert(_.format),DA=L.convert(_.type);let QA;if(_.isData3DTexture)SA.setTexture3D(_,0),QA=32879;else if(_.isDataArrayTexture)SA.setTexture2DArray(_,0),QA=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}oA.pixelStorei(37440,_.flipY),oA.pixelStorei(37441,_.premultiplyAlpha),oA.pixelStorei(3317,_.unpackAlignment);const _A=oA.getParameter(3314),NA=oA.getParameter(32878),KA=oA.getParameter(3316),WA=oA.getParameter(3315),jA=oA.getParameter(32877),qA=q.isCompressedTexture?q.mipmaps[0]:q.image;oA.pixelStorei(3314,qA.width),oA.pixelStorei(32878,qA.height),oA.pixelStorei(3316,F.min.x),oA.pixelStorei(3315,F.min.y),oA.pixelStorei(32877,F.min.z),q.isDataTexture||q.isData3DTexture?oA.texSubImage3D(QA,v,J.x,J.y,J.z,P,iA,aA,IA,DA,qA.data):q.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),oA.compressedTexSubImage3D(QA,v,J.x,J.y,J.z,P,iA,aA,IA,qA.data)):oA.texSubImage3D(QA,v,J.x,J.y,J.z,P,iA,aA,IA,DA,qA),oA.pixelStorei(3314,_A),oA.pixelStorei(32878,NA),oA.pixelStorei(3316,KA),oA.pixelStorei(3315,WA),oA.pixelStorei(32877,jA),v===0&&_.generateMipmaps&&oA.generateMipmap(QA),fA.unbindTexture()},this.initTexture=function(F){F.isCubeTexture?SA.setTextureCube(F,0):F.isData3DTexture?SA.setTexture3D(F,0):F.isDataArrayTexture?SA.setTexture2DArray(F,0):SA.setTexture2D(F,0),fA.unbindTexture()},this.resetState=function(){E=0,f=0,u=null,fA.reset(),k.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class fm extends $c{}fm.prototype.isWebGL1Renderer=!0;class um extends vt{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(A,t){return super.copy(A,t),A.background!==null&&(this.background=A.background.clone()),A.environment!==null&&(this.environment=A.environment.clone()),A.fog!==null&&(this.fog=A.fog.clone()),A.overrideMaterial!==null&&(this.overrideMaterial=A.overrideMaterial.clone()),this.matrixAutoUpdate=A.matrixAutoUpdate,this}toJSON(A){const t=super.toJSON(A);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}get autoUpdate(){return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate}set autoUpdate(A){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate=A}}class pm extends we{constructor(A=null,t=1,e=1,n,a,o,s,I,r=Ae,g=Ae,C,B){super(null,o,s,I,r,g,n,a,C,B),this.isDataTexture=!0,this.image={data:A,width:t,height:e},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Be extends Cn{constructor(A=1,t=32,e=16,n=0,a=Math.PI*2,o=0,s=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:A,widthSegments:t,heightSegments:e,phiStart:n,phiLength:a,thetaStart:o,thetaLength:s},t=Math.max(3,Math.floor(t)),e=Math.max(2,Math.floor(e));const I=Math.min(o+s,Math.PI);let r=0;const g=[],C=new rA,B=new rA,c=[],Q=[],h=[],l=[];for(let E=0;E<=e;E++){const f=[],u=E/e;let d=0;E==0&&o==0?d=.5/t:E==e&&I==Math.PI&&(d=-.5/t);for(let m=0;m<=t;m++){const S=m/t;C.x=-A*Math.cos(n+S*a)*Math.sin(o+u*s),C.y=A*Math.cos(o+u*s),C.z=A*Math.sin(n+S*a)*Math.sin(o+u*s),Q.push(C.x,C.y,C.z),B.copy(C).normalize(),h.push(B.x,B.y,B.z),l.push(S+d,1-u),f.push(r++)}g.push(f)}for(let E=0;E<e;E++)for(let f=0;f<t;f++){const u=g[E][f+1],d=g[E][f],m=g[E+1][f],S=g[E+1][f+1];(E!==0||o>0)&&c.push(u,d,S),(E!==e-1||I<Math.PI)&&c.push(d,m,S)}this.setIndex(c),this.setAttribute("position",new ri(Q,3)),this.setAttribute("normal",new ri(h,3)),this.setAttribute("uv",new ri(l,2))}static fromJSON(A){return new Be(A.radius,A.widthSegments,A.heightSegments,A.phiStart,A.phiLength,A.thetaStart,A.thetaLength)}}class bI extends ss{constructor(A){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new st(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new st(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=hl,this.normalScale=new XA(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.defines={STANDARD:""},this.color.copy(A.color),this.roughness=A.roughness,this.metalness=A.metalness,this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.emissive.copy(A.emissive),this.emissiveMap=A.emissiveMap,this.emissiveIntensity=A.emissiveIntensity,this.bumpMap=A.bumpMap,this.bumpScale=A.bumpScale,this.normalMap=A.normalMap,this.normalMapType=A.normalMapType,this.normalScale.copy(A.normalScale),this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this.roughnessMap=A.roughnessMap,this.metalnessMap=A.metalnessMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.envMapIntensity=A.envMapIntensity,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.flatShading=A.flatShading,this.fog=A.fog,this}}class UI extends ss{constructor(A){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new st(16777215),this.specular=new st(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new st(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=hl,this.normalScale=new XA(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Bl,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.specular.copy(A.specular),this.shininess=A.shininess,this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.emissive.copy(A.emissive),this.emissiveMap=A.emissiveMap,this.emissiveIntensity=A.emissiveIntensity,this.bumpMap=A.bumpMap,this.bumpScale=A.bumpScale,this.normalMap=A.normalMap,this.normalMapType=A.normalMapType,this.normalScale.copy(A.normalScale),this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this.specularMap=A.specularMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.combine=A.combine,this.reflectivity=A.reflectivity,this.refractionRatio=A.refractionRatio,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.flatShading=A.flatShading,this.fog=A.fog,this}}const Dr={enabled:!1,files:{},add:function(i,A){this.enabled!==!1&&(this.files[i]=A)},get:function(i){if(this.enabled!==!1)return this.files[i]},remove:function(i){delete this.files[i]},clear:function(){this.files={}}};class mm{constructor(A,t,e){const n=this;let a=!1,o=0,s=0,I;const r=[];this.onStart=void 0,this.onLoad=A,this.onProgress=t,this.onError=e,this.itemStart=function(g){s++,a===!1&&n.onStart!==void 0&&n.onStart(g,o,s),a=!0},this.itemEnd=function(g){o++,n.onProgress!==void 0&&n.onProgress(g,o,s),o===s&&(a=!1,n.onLoad!==void 0&&n.onLoad())},this.itemError=function(g){n.onError!==void 0&&n.onError(g)},this.resolveURL=function(g){return I?I(g):g},this.setURLModifier=function(g){return I=g,this},this.addHandler=function(g,C){return r.push(g,C),this},this.removeHandler=function(g){const C=r.indexOf(g);return C!==-1&&r.splice(C,2),this},this.getHandler=function(g){for(let C=0,B=r.length;C<B;C+=2){const c=r[C],Q=r[C+1];if(c.global&&(c.lastIndex=0),c.test(g))return Q}return null}}}const ym=new mm;class kr{constructor(A){this.manager=A!==void 0?A:ym,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(A,t){const e=this;return new Promise(function(n,a){e.load(A,n,t,a)})}parse(){}setCrossOrigin(A){return this.crossOrigin=A,this}setWithCredentials(A){return this.withCredentials=A,this}setPath(A){return this.path=A,this}setResourcePath(A){return this.resourcePath=A,this}setRequestHeader(A){return this.requestHeader=A,this}}const Qi={};class Dm extends Error{constructor(A,t){super(A),this.response=t}}class Sm extends kr{constructor(A){super(A)}load(A,t,e,n){A===void 0&&(A=""),this.path!==void 0&&(A=this.path+A),A=this.manager.resolveURL(A);const a=Dr.get(A);if(a!==void 0)return this.manager.itemStart(A),setTimeout(()=>{t&&t(a),this.manager.itemEnd(A)},0),a;if(Qi[A]!==void 0){Qi[A].push({onLoad:t,onProgress:e,onError:n});return}Qi[A]=[],Qi[A].push({onLoad:t,onProgress:e,onError:n});const o=new Request(A,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),s=this.mimeType,I=this.responseType;fetch(o).then(r=>{if(r.status===200||r.status===0){if(r.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||r.body===void 0||r.body.getReader===void 0)return r;const g=Qi[A],C=r.body.getReader(),B=r.headers.get("Content-Length"),c=B?parseInt(B):0,Q=c!==0;let h=0;const l=new ReadableStream({start(E){f();function f(){C.read().then(({done:u,value:d})=>{if(u)E.close();else{h+=d.byteLength;const m=new ProgressEvent("progress",{lengthComputable:Q,loaded:h,total:c});for(let S=0,D=g.length;S<D;S++){const p=g[S];p.onProgress&&p.onProgress(m)}E.enqueue(d),f()}})}}});return new Response(l)}else throw new Dm(`fetch for "${r.url}" responded with ${r.status}: ${r.statusText}`,r)}).then(r=>{switch(I){case"arraybuffer":return r.arrayBuffer();case"blob":return r.blob();case"document":return r.text().then(g=>new DOMParser().parseFromString(g,s));case"json":return r.json();default:if(s===void 0)return r.text();{const C=/charset="?([^;"\s]*)"?/i.exec(s),B=C&&C[1]?C[1].toLowerCase():void 0,c=new TextDecoder(B);return r.arrayBuffer().then(Q=>c.decode(Q))}}}).then(r=>{Dr.add(A,r);const g=Qi[A];delete Qi[A];for(let C=0,B=g.length;C<B;C++){const c=g[C];c.onLoad&&c.onLoad(r)}}).catch(r=>{const g=Qi[A];if(g===void 0)throw this.manager.itemError(A),r;delete Qi[A];for(let C=0,B=g.length;C<B;C++){const c=g[C];c.onError&&c.onError(r)}this.manager.itemError(A)}).finally(()=>{this.manager.itemEnd(A)}),this.manager.itemStart(A)}setResponseType(A){return this.responseType=A,this}setMimeType(A){return this.mimeType=A,this}}class wm extends kr{constructor(A){super(A)}load(A,t,e,n){this.path!==void 0&&(A=this.path+A),A=this.manager.resolveURL(A);const a=this,o=Dr.get(A);if(o!==void 0)return a.manager.itemStart(A),setTimeout(function(){t&&t(o),a.manager.itemEnd(A)},0),o;const s=Os("img");function I(){g(),Dr.add(A,this),t&&t(this),a.manager.itemEnd(A)}function r(C){g(),n&&n(C),a.manager.itemError(A),a.manager.itemEnd(A)}function g(){s.removeEventListener("load",I,!1),s.removeEventListener("error",r,!1)}return s.addEventListener("load",I,!1),s.addEventListener("error",r,!1),A.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(s.crossOrigin=this.crossOrigin),a.manager.itemStart(A),s.src=A,s}}class _m extends kr{constructor(A){super(A)}load(A,t,e,n){const a=this,o=new pm,s=new Sm(this.manager);return s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setPath(this.path),s.setWithCredentials(a.withCredentials),s.load(A,function(I){const r=a.parse(I);!r||(r.image!==void 0?o.image=r.image:r.data!==void 0&&(o.image.width=r.width,o.image.height=r.height,o.image.data=r.data),o.wrapS=r.wrapS!==void 0?r.wrapS:se,o.wrapT=r.wrapT!==void 0?r.wrapT:se,o.magFilter=r.magFilter!==void 0?r.magFilter:Wt,o.minFilter=r.minFilter!==void 0?r.minFilter:Wt,o.anisotropy=r.anisotropy!==void 0?r.anisotropy:1,r.encoding!==void 0&&(o.encoding=r.encoding),r.flipY!==void 0&&(o.flipY=r.flipY),r.format!==void 0&&(o.format=r.format),r.type!==void 0&&(o.type=r.type),r.mipmaps!==void 0&&(o.mipmaps=r.mipmaps,o.minFilter=ao),r.mipmapCount===1&&(o.minFilter=Wt),r.generateMipmaps!==void 0&&(o.generateMipmaps=r.generateMipmaps),o.needsUpdate=!0,t&&t(o,r))},e,n),o}}class xm extends kr{constructor(A){super(A)}load(A,t,e,n){const a=new we,o=new wm(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(A,function(s){a.image=s,a.needsUpdate=!0,t!==void 0&&t(a)},e,n),a}}class Tr extends vt{constructor(A,t=1){super(),this.isLight=!0,this.type="Light",this.color=new st(A),this.intensity=t}dispose(){}copy(A,t){return super.copy(A,t),this.color.copy(A.color),this.intensity=A.intensity,this}toJSON(A){const t=super.toJSON(A);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}class AE extends Tr{constructor(A,t,e){super(A,e),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(vt.DefaultUp),this.updateMatrix(),this.groundColor=new st(t)}copy(A,t){return super.copy(A,t),this.groundColor.copy(A.groundColor),this}}const Sg=new _t,$C=new rA,AB=new rA;class fl{constructor(A){this.camera=A,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new XA(512,512),this.map=null,this.mapPass=null,this.matrix=new _t,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new El,this._frameExtents=new XA(1,1),this._viewportCount=1,this._viewports=[new dt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(A){const t=this.camera,e=this.matrix;$C.setFromMatrixPosition(A.matrixWorld),t.position.copy($C),AB.setFromMatrixPosition(A.target.matrixWorld),t.lookAt(AB),t.updateMatrixWorld(),Sg.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Sg),e.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),e.multiply(Sg)}getViewport(A){return this._viewports[A]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(A){return this.camera=A.camera.clone(),this.bias=A.bias,this.radius=A.radius,this.mapSize.copy(A.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const A={};return this.bias!==0&&(A.bias=this.bias),this.normalBias!==0&&(A.normalBias=this.normalBias),this.radius!==1&&(A.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(A.mapSize=this.mapSize.toArray()),A.camera=this.camera.toJSON(!1).object,delete A.camera.matrix,A}}class Mm extends fl{constructor(){super(new le(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(A){const t=this.camera,e=GI*2*A.angle*this.focus,n=this.mapSize.width/this.mapSize.height,a=A.distance||t.far;(e!==t.fov||n!==t.aspect||a!==t.far)&&(t.fov=e,t.aspect=n,t.far=a,t.updateProjectionMatrix()),super.updateMatrices(A)}copy(A){return super.copy(A),this.focus=A.focus,this}}class tE extends Tr{constructor(A,t,e=0,n=Math.PI/3,a=0,o=1){super(A,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(vt.DefaultUp),this.updateMatrix(),this.target=new vt,this.distance=e,this.angle=n,this.penumbra=a,this.decay=o,this.map=null,this.shadow=new Mm}get power(){return this.intensity*Math.PI}set power(A){this.intensity=A/Math.PI}dispose(){this.shadow.dispose()}copy(A,t){return super.copy(A,t),this.distance=A.distance,this.angle=A.angle,this.penumbra=A.penumbra,this.decay=A.decay,this.target=A.target.clone(),this.shadow=A.shadow.clone(),this}}const tB=new _t,fs=new rA,wg=new rA;class Fm extends fl{constructor(){super(new le(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new XA(4,2),this._viewportCount=6,this._viewports=[new dt(2,1,1,1),new dt(0,1,1,1),new dt(3,1,1,1),new dt(1,1,1,1),new dt(3,0,1,1),new dt(1,0,1,1)],this._cubeDirections=[new rA(1,0,0),new rA(-1,0,0),new rA(0,0,1),new rA(0,0,-1),new rA(0,1,0),new rA(0,-1,0)],this._cubeUps=[new rA(0,1,0),new rA(0,1,0),new rA(0,1,0),new rA(0,1,0),new rA(0,0,1),new rA(0,0,-1)]}updateMatrices(A,t=0){const e=this.camera,n=this.matrix,a=A.distance||e.far;a!==e.far&&(e.far=a,e.updateProjectionMatrix()),fs.setFromMatrixPosition(A.matrixWorld),e.position.copy(fs),wg.copy(e.position),wg.add(this._cubeDirections[t]),e.up.copy(this._cubeUps[t]),e.lookAt(wg),e.updateMatrixWorld(),n.makeTranslation(-fs.x,-fs.y,-fs.z),tB.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(tB)}}class eE extends Tr{constructor(A,t,e=0,n=1){super(A,t),this.isPointLight=!0,this.type="PointLight",this.distance=e,this.decay=n,this.shadow=new Fm}get power(){return this.intensity*4*Math.PI}set power(A){this.intensity=A/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(A,t){return super.copy(A,t),this.distance=A.distance,this.decay=A.decay,this.shadow=A.shadow.clone(),this}}class Rm extends fl{constructor(){super(new Vc(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class ul extends Tr{constructor(A,t){super(A,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(vt.DefaultUp),this.updateMatrix(),this.target=new vt,this.shadow=new Rm}dispose(){this.shadow.dispose()}copy(A){return super.copy(A),this.target=A.target.clone(),this.shadow=A.shadow.clone(),this}}class eB{constructor(A=1,t=0,e=0){return this.radius=A,this.phi=t,this.theta=e,this}set(A,t,e){return this.radius=A,this.phi=t,this.theta=e,this}copy(A){return this.radius=A.radius,this.phi=A.phi,this.theta=A.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(A){return this.setFromCartesianCoords(A.x,A.y,A.z)}setFromCartesianCoords(A,t,e){return this.radius=Math.sqrt(A*A+t*t+e*e),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(A,e),this.phi=Math.acos(ae(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}const Mi=vm();function vm(){const i=new ArrayBuffer(4),A=new Float32Array(i),t=new Uint32Array(i),e=new Uint32Array(512),n=new Uint32Array(512);for(let I=0;I<256;++I){const r=I-127;r<-27?(e[I]=0,e[I|256]=32768,n[I]=24,n[I|256]=24):r<-14?(e[I]=1024>>-r-14,e[I|256]=1024>>-r-14|32768,n[I]=-r-1,n[I|256]=-r-1):r<=15?(e[I]=r+15<<10,e[I|256]=r+15<<10|32768,n[I]=13,n[I|256]=13):r<128?(e[I]=31744,e[I|256]=64512,n[I]=24,n[I|256]=24):(e[I]=31744,e[I|256]=64512,n[I]=13,n[I|256]=13)}const a=new Uint32Array(2048),o=new Uint32Array(64),s=new Uint32Array(64);for(let I=1;I<1024;++I){let r=I<<13,g=0;for(;(r&8388608)===0;)r<<=1,g-=8388608;r&=-8388609,g+=947912704,a[I]=r|g}for(let I=1024;I<2048;++I)a[I]=939524096+(I-1024<<13);for(let I=1;I<31;++I)o[I]=I<<23;o[31]=1199570944,o[32]=2147483648;for(let I=33;I<63;++I)o[I]=2147483648+(I-32<<23);o[63]=3347054592;for(let I=1;I<64;++I)I!==32&&(s[I]=1024);return{floatView:A,uint32View:t,baseTable:e,shiftTable:n,mantissaTable:a,exponentTable:o,offsetTable:s}}function Gm(i){Math.abs(i)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),i=ae(i,-65504,65504),Mi.floatView[0]=i;const A=Mi.uint32View[0],t=A>>23&511;return Mi.baseTable[t]+((A&8388607)>>Mi.shiftTable[t])}function Nm(i){const A=i>>10;return Mi.uint32View[0]=Mi.mantissaTable[Mi.offsetTable[A]+(i&1023)]+Mi.exponentTable[A],Mi.floatView[0]}var To=Object.freeze({__proto__:null,toHalfFloat:Gm,fromHalfFloat:Nm});typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Cl}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Cl);const iB={type:"change"},_g={type:"start"},nB={type:"end"};class Lm extends $n{constructor(A,t){super(),this.object=A,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new rA,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:na.ROTATE,MIDDLE:na.DOLLY,RIGHT:na.PAN},this.touches={ONE:aa.ROTATE,TWO:aa.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return s.phi},this.getAzimuthalAngle=function(){return s.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(L){L.addEventListener("keydown",$A),this._domElementKeyEvents=L},this.saveState=function(){e.target0.copy(e.target),e.position0.copy(e.object.position),e.zoom0=e.object.zoom},this.reset=function(){e.target.copy(e.target0),e.object.position.copy(e.position0),e.object.zoom=e.zoom0,e.object.updateProjectionMatrix(),e.dispatchEvent(iB),e.update(),a=n.NONE},this.update=function(){const L=new rA,k=new Jn().setFromUnitVectors(A.up,new rA(0,1,0)),hA=k.clone().invert(),BA=new rA,EA=new Jn,dA=2*Math.PI;return function(){const bA=e.object.position;L.copy(bA).sub(e.target),L.applyQuaternion(k),s.setFromVector3(L),e.autoRotate&&a===n.NONE&&w(D()),e.enableDamping?(s.theta+=I.theta*e.dampingFactor,s.phi+=I.phi*e.dampingFactor):(s.theta+=I.theta,s.phi+=I.phi);let nA=e.minAzimuthAngle,xA=e.maxAzimuthAngle;return isFinite(nA)&&isFinite(xA)&&(nA<-Math.PI?nA+=dA:nA>Math.PI&&(nA-=dA),xA<-Math.PI?xA+=dA:xA>Math.PI&&(xA-=dA),nA<=xA?s.theta=Math.max(nA,Math.min(xA,s.theta)):s.theta=s.theta>(nA+xA)/2?Math.max(nA,s.theta):Math.min(xA,s.theta)),s.phi=Math.max(e.minPolarAngle,Math.min(e.maxPolarAngle,s.phi)),s.makeSafe(),s.radius*=r,s.radius=Math.max(e.minDistance,Math.min(e.maxDistance,s.radius)),e.enableDamping===!0?e.target.addScaledVector(g,e.dampingFactor):e.target.add(g),L.setFromSpherical(s),L.applyQuaternion(hA),bA.copy(e.target).add(L),e.object.lookAt(e.target),e.enableDamping===!0?(I.theta*=1-e.dampingFactor,I.phi*=1-e.dampingFactor,g.multiplyScalar(1-e.dampingFactor)):(I.set(0,0,0),g.set(0,0,0)),r=1,C||BA.distanceToSquared(e.object.position)>o||8*(1-EA.dot(e.object.quaternion))>o?(e.dispatchEvent(iB),BA.copy(e.object.position),EA.copy(e.object.quaternion),C=!1,!0):!1}}(),this.dispose=function(){e.domElement.removeEventListener("contextmenu",b),e.domElement.removeEventListener("pointerdown",TA),e.domElement.removeEventListener("pointercancel",YA),e.domElement.removeEventListener("wheel",rt),e.domElement.removeEventListener("pointermove",OA),e.domElement.removeEventListener("pointerup",JA),e._domElementKeyEvents!==null&&e._domElementKeyEvents.removeEventListener("keydown",$A)};const e=this,n={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let a=n.NONE;const o=1e-6,s=new eB,I=new eB;let r=1;const g=new rA;let C=!1;const B=new XA,c=new XA,Q=new XA,h=new XA,l=new XA,E=new XA,f=new XA,u=new XA,d=new XA,m=[],S={};function D(){return 2*Math.PI/60/60*e.autoRotateSpeed}function p(){return Math.pow(.95,e.zoomSpeed)}function w(L){I.theta-=L}function M(L){I.phi-=L}const R=function(){const L=new rA;return function(hA,BA){L.setFromMatrixColumn(BA,0),L.multiplyScalar(-hA),g.add(L)}}(),U=function(){const L=new rA;return function(hA,BA){e.screenSpacePanning===!0?L.setFromMatrixColumn(BA,1):(L.setFromMatrixColumn(BA,0),L.crossVectors(e.object.up,L)),L.multiplyScalar(hA),g.add(L)}}(),N=function(){const L=new rA;return function(hA,BA){const EA=e.domElement;if(e.object.isPerspectiveCamera){const dA=e.object.position;L.copy(dA).sub(e.target);let yA=L.length();yA*=Math.tan(e.object.fov/2*Math.PI/180),R(2*hA*yA/EA.clientHeight,e.object.matrix),U(2*BA*yA/EA.clientHeight,e.object.matrix)}else e.object.isOrthographicCamera?(R(hA*(e.object.right-e.object.left)/e.object.zoom/EA.clientWidth,e.object.matrix),U(BA*(e.object.top-e.object.bottom)/e.object.zoom/EA.clientHeight,e.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),e.enablePan=!1)}}();function G(L){e.object.isPerspectiveCamera?r/=L:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom*L)),e.object.updateProjectionMatrix(),C=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function T(L){e.object.isPerspectiveCamera?r*=L:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/L)),e.object.updateProjectionMatrix(),C=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function V(L){B.set(L.clientX,L.clientY)}function tA(L){f.set(L.clientX,L.clientY)}function z(L){h.set(L.clientX,L.clientY)}function W(L){c.set(L.clientX,L.clientY),Q.subVectors(c,B).multiplyScalar(e.rotateSpeed);const k=e.domElement;w(2*Math.PI*Q.x/k.clientHeight),M(2*Math.PI*Q.y/k.clientHeight),B.copy(c),e.update()}function Y(L){u.set(L.clientX,L.clientY),d.subVectors(u,f),d.y>0?G(p()):d.y<0&&T(p()),f.copy(u),e.update()}function CA(L){l.set(L.clientX,L.clientY),E.subVectors(l,h).multiplyScalar(e.panSpeed),N(E.x,E.y),h.copy(l),e.update()}function K(L){L.deltaY<0?T(p()):L.deltaY>0&&G(p()),e.update()}function AA(L){let k=!1;switch(L.code){case e.keys.UP:N(0,e.keyPanSpeed),k=!0;break;case e.keys.BOTTOM:N(0,-e.keyPanSpeed),k=!0;break;case e.keys.LEFT:N(e.keyPanSpeed,0),k=!0;break;case e.keys.RIGHT:N(-e.keyPanSpeed,0),k=!0;break}k&&(L.preventDefault(),e.update())}function lA(){if(m.length===1)B.set(m[0].pageX,m[0].pageY);else{const L=.5*(m[0].pageX+m[1].pageX),k=.5*(m[0].pageY+m[1].pageY);B.set(L,k)}}function Z(){if(m.length===1)h.set(m[0].pageX,m[0].pageY);else{const L=.5*(m[0].pageX+m[1].pageX),k=.5*(m[0].pageY+m[1].pageY);h.set(L,k)}}function oA(){const L=m[0].pageX-m[1].pageX,k=m[0].pageY-m[1].pageY,hA=Math.sqrt(L*L+k*k);f.set(0,hA)}function wA(){e.enableZoom&&oA(),e.enablePan&&Z()}function uA(){e.enableZoom&&oA(),e.enableRotate&&lA()}function mA(L){if(m.length==1)c.set(L.pageX,L.pageY);else{const hA=sA(L),BA=.5*(L.pageX+hA.x),EA=.5*(L.pageY+hA.y);c.set(BA,EA)}Q.subVectors(c,B).multiplyScalar(e.rotateSpeed);const k=e.domElement;w(2*Math.PI*Q.x/k.clientHeight),M(2*Math.PI*Q.y/k.clientHeight),B.copy(c)}function fA(L){if(m.length===1)l.set(L.pageX,L.pageY);else{const k=sA(L),hA=.5*(L.pageX+k.x),BA=.5*(L.pageY+k.y);l.set(hA,BA)}E.subVectors(l,h).multiplyScalar(e.panSpeed),N(E.x,E.y),h.copy(l)}function RA(L){const k=sA(L),hA=L.pageX-k.x,BA=L.pageY-k.y,EA=Math.sqrt(hA*hA+BA*BA);u.set(0,EA),d.set(0,Math.pow(u.y/f.y,e.zoomSpeed)),G(d.y),f.copy(u)}function MA(L){e.enableZoom&&RA(L),e.enablePan&&fA(L)}function SA(L){e.enableZoom&&RA(L),e.enableRotate&&mA(L)}function TA(L){e.enabled!==!1&&(m.length===0&&(e.domElement.setPointerCapture(L.pointerId),e.domElement.addEventListener("pointermove",OA),e.domElement.addEventListener("pointerup",JA)),X(L),L.pointerType==="touch"?x(L):HA(L))}function OA(L){e.enabled!==!1&&(L.pointerType==="touch"?y(L):kA(L))}function JA(L){j(L),m.length===0&&(e.domElement.releasePointerCapture(L.pointerId),e.domElement.removeEventListener("pointermove",OA),e.domElement.removeEventListener("pointerup",JA)),e.dispatchEvent(nB),a=n.NONE}function YA(L){j(L)}function HA(L){let k;switch(L.button){case 0:k=e.mouseButtons.LEFT;break;case 1:k=e.mouseButtons.MIDDLE;break;case 2:k=e.mouseButtons.RIGHT;break;default:k=-1}switch(k){case na.DOLLY:if(e.enableZoom===!1)return;tA(L),a=n.DOLLY;break;case na.ROTATE:if(L.ctrlKey||L.metaKey||L.shiftKey){if(e.enablePan===!1)return;z(L),a=n.PAN}else{if(e.enableRotate===!1)return;V(L),a=n.ROTATE}break;case na.PAN:if(L.ctrlKey||L.metaKey||L.shiftKey){if(e.enableRotate===!1)return;V(L),a=n.ROTATE}else{if(e.enablePan===!1)return;z(L),a=n.PAN}break;default:a=n.NONE}a!==n.NONE&&e.dispatchEvent(_g)}function kA(L){switch(a){case n.ROTATE:if(e.enableRotate===!1)return;W(L);break;case n.DOLLY:if(e.enableZoom===!1)return;Y(L);break;case n.PAN:if(e.enablePan===!1)return;CA(L);break}}function rt(L){e.enabled===!1||e.enableZoom===!1||a!==n.NONE||(L.preventDefault(),e.dispatchEvent(_g),K(L),e.dispatchEvent(nB))}function $A(L){e.enabled===!1||e.enablePan===!1||AA(L)}function x(L){switch(eA(L),m.length){case 1:switch(e.touches.ONE){case aa.ROTATE:if(e.enableRotate===!1)return;lA(),a=n.TOUCH_ROTATE;break;case aa.PAN:if(e.enablePan===!1)return;Z(),a=n.TOUCH_PAN;break;default:a=n.NONE}break;case 2:switch(e.touches.TWO){case aa.DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;wA(),a=n.TOUCH_DOLLY_PAN;break;case aa.DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;uA(),a=n.TOUCH_DOLLY_ROTATE;break;default:a=n.NONE}break;default:a=n.NONE}a!==n.NONE&&e.dispatchEvent(_g)}function y(L){switch(eA(L),a){case n.TOUCH_ROTATE:if(e.enableRotate===!1)return;mA(L),e.update();break;case n.TOUCH_PAN:if(e.enablePan===!1)return;fA(L),e.update();break;case n.TOUCH_DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;MA(L),e.update();break;case n.TOUCH_DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;SA(L),e.update();break;default:a=n.NONE}}function b(L){e.enabled!==!1&&L.preventDefault()}function X(L){m.push(L)}function j(L){delete S[L.pointerId];for(let k=0;k<m.length;k++)if(m[k].pointerId==L.pointerId){m.splice(k,1);return}}function eA(L){let k=S[L.pointerId];k===void 0&&(k=new XA,S[L.pointerId]=k),k.set(L.pageX,L.pageY)}function sA(L){const k=L.pointerId===m[0].pointerId?m[1]:m[0];return S[k.pointerId]}e.domElement.addEventListener("contextmenu",b),e.domElement.addEventListener("pointerdown",TA),e.domElement.addEventListener("pointercancel",YA),e.domElement.addEventListener("wheel",rt,{passive:!1}),this.update()}}var bm=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},iE={exports:{}};(function(i,A){(function(t,e){i.exports=e()})(bm,function(){var t=function(){function e(c){return o.appendChild(c.dom),c}function n(c){for(var Q=0;Q<o.children.length;Q++)o.children[Q].style.display=Q===c?"block":"none";a=c}var a=0,o=document.createElement("div");o.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",o.addEventListener("click",function(c){c.preventDefault(),n(++a%o.children.length)},!1);var s=(performance||Date).now(),I=s,r=0,g=e(new t.Panel("FPS","#0ff","#002")),C=e(new t.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var B=e(new t.Panel("MB","#f08","#201"));return n(0),{REVISION:16,dom:o,addPanel:e,showPanel:n,begin:function(){s=(performance||Date).now()},end:function(){r++;var c=(performance||Date).now();if(C.update(c-s,200),c>I+1e3&&(g.update(1e3*r/(c-I),100),I=c,r=0,B)){var Q=performance.memory;B.update(Q.usedJSHeapSize/1048576,Q.jsHeapSizeLimit/1048576)}return c},update:function(){s=this.end()},domElement:o,setMode:n}};return t.Panel=function(e,n,a){var o=1/0,s=0,I=Math.round,r=I(window.devicePixelRatio||1),g=80*r,C=48*r,B=3*r,c=2*r,Q=3*r,h=15*r,l=74*r,E=30*r,f=document.createElement("canvas");f.width=g,f.height=C,f.style.cssText="width:80px;height:48px";var u=f.getContext("2d");return u.font="bold "+9*r+"px Helvetica,Arial,sans-serif",u.textBaseline="top",u.fillStyle=a,u.fillRect(0,0,g,C),u.fillStyle=n,u.fillText(e,B,c),u.fillRect(Q,h,l,E),u.fillStyle=a,u.globalAlpha=.9,u.fillRect(Q,h,l,E),{dom:f,update:function(d,m){o=Math.min(o,d),s=Math.max(s,d),u.fillStyle=a,u.globalAlpha=1,u.fillRect(0,0,g,h),u.fillStyle=n,u.fillText(I(d)+" "+e+" ("+I(o)+"-"+I(s)+")",B,c),u.drawImage(f,Q+r,h,l-r,E,Q,h,l-r,E),u.fillRect(Q+l-r,h,r,E),u.fillStyle=a,u.globalAlpha=.9,u.fillRect(Q+l-r,h,r,I((1-d/m)*E))}}},t})})(iE);const Um=iE.exports;/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const pl="150",km=0,aB=1,Tm=2,nE=1,Hm=2,Gs=3,In=0,ce=1,ji=2,an=0,Oa=1,sB=2,oB=3,rB=4,qm=5,ka=100,Jm=101,Pm=102,gB=103,IB=104,Ym=200,Km=201,Om=202,Wm=203,aE=204,sE=205,Vm=206,zm=207,Xm=208,Zm=209,jm=210,$m=0,Ay=1,ty=2,kI=3,ey=4,iy=5,ny=6,ay=7,ml=0,sy=1,oy=2,Ni=0,ry=1,gy=2,Iy=3,ly=4,Cy=5,oE=300,es=301,is=302,TI=303,HI=304,Hr=306,qI=1e3,Fe=1001,JI=1002,ne=1003,lB=1004,xg=1005,te=1006,By=1007,Ws=1008,Yn=1009,hy=1010,cy=1011,rE=1012,Ey=1013,Rn=1014,vn=1015,Vs=1016,Qy=1017,dy=1018,Wa=1020,fy=1021,Ke=1023,uy=1024,py=1025,Un=1026,ns=1027,PI=1028,my=1029,yy=1030,Dy=1031,Sy=1033,Mg=33776,Fg=33777,Rg=33778,vg=33779,CB=35840,BB=35841,hB=35842,cB=35843,wy=36196,EB=37492,QB=37496,dB=37808,fB=37809,uB=37810,pB=37811,mB=37812,yB=37813,DB=37814,SB=37815,wB=37816,_B=37817,xB=37818,MB=37819,FB=37820,RB=37821,Gg=36492,_y=36283,vB=36284,GB=36285,NB=36286,Kn=3e3,ht=3001,xy=3200,My=3201,gE=0,Fy=1,$e="srgb",zs="srgb-linear",IE="display-p3",Ng=7680,Ry=519,LB=35044,bB="300 es",YI=1035;class rs{addEventListener(A,t){this._listeners===void 0&&(this._listeners={});const e=this._listeners;e[A]===void 0&&(e[A]=[]),e[A].indexOf(t)===-1&&e[A].push(t)}hasEventListener(A,t){if(this._listeners===void 0)return!1;const e=this._listeners;return e[A]!==void 0&&e[A].indexOf(t)!==-1}removeEventListener(A,t){if(this._listeners===void 0)return;const n=this._listeners[A];if(n!==void 0){const a=n.indexOf(t);a!==-1&&n.splice(a,1)}}dispatchEvent(A){if(this._listeners===void 0)return;const e=this._listeners[A.type];if(e!==void 0){A.target=this;const n=e.slice(0);for(let a=0,o=n.length;a<o;a++)n[a].call(this,A);A.target=null}}}const Zt=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let UB=1234567;const Hs=Math.PI/180,Sr=180/Math.PI;function gs(){const i=Math.random()*4294967295|0,A=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0;return(Zt[i&255]+Zt[i>>8&255]+Zt[i>>16&255]+Zt[i>>24&255]+"-"+Zt[A&255]+Zt[A>>8&255]+"-"+Zt[A>>16&15|64]+Zt[A>>24&255]+"-"+Zt[t&63|128]+Zt[t>>8&255]+"-"+Zt[t>>16&255]+Zt[t>>24&255]+Zt[e&255]+Zt[e>>8&255]+Zt[e>>16&255]+Zt[e>>24&255]).toLowerCase()}function Ce(i,A,t){return Math.max(A,Math.min(t,i))}function yl(i,A){return(i%A+A)%A}function vy(i,A,t,e,n){return e+(i-A)*(n-e)/(t-A)}function Gy(i,A,t){return i!==A?(t-i)/(A-i):0}function qs(i,A,t){return(1-t)*i+t*A}function Ny(i,A,t,e){return qs(i,A,1-Math.exp(-t*e))}function Ly(i,A=1){return A-Math.abs(yl(i,A*2)-A)}function by(i,A,t){return i<=A?0:i>=t?1:(i=(i-A)/(t-A),i*i*(3-2*i))}function Uy(i,A,t){return i<=A?0:i>=t?1:(i=(i-A)/(t-A),i*i*i*(i*(i*6-15)+10))}function ky(i,A){return i+Math.floor(Math.random()*(A-i+1))}function Ty(i,A){return i+Math.random()*(A-i)}function Hy(i){return i*(.5-Math.random())}function qy(i){i!==void 0&&(UB=i);let A=UB+=1831565813;return A=Math.imul(A^A>>>15,A|1),A^=A+Math.imul(A^A>>>7,A|61),((A^A>>>14)>>>0)/4294967296}function Jy(i){return i*Hs}function Py(i){return i*Sr}function KI(i){return(i&i-1)===0&&i!==0}function Yy(i){return Math.pow(2,Math.ceil(Math.log(i)/Math.LN2))}function lE(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))}function Ky(i,A,t,e,n){const a=Math.cos,o=Math.sin,s=a(t/2),I=o(t/2),r=a((A+e)/2),g=o((A+e)/2),C=a((A-e)/2),B=o((A-e)/2),c=a((e-A)/2),Q=o((e-A)/2);switch(n){case"XYX":i.set(s*g,I*C,I*B,s*r);break;case"YZY":i.set(I*B,s*g,I*C,s*r);break;case"ZXZ":i.set(I*C,I*B,s*g,s*r);break;case"XZX":i.set(s*g,I*Q,I*c,s*r);break;case"YXY":i.set(I*c,s*g,I*Q,s*r);break;case"ZYZ":i.set(I*Q,I*c,s*g,s*r);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+n)}}function Ns(i,A){switch(A.constructor){case Float32Array:return i;case Uint16Array:return i/65535;case Uint8Array:return i/255;case Int16Array:return Math.max(i/32767,-1);case Int8Array:return Math.max(i/127,-1);default:throw new Error("Invalid component type.")}}function ge(i,A){switch(A.constructor){case Float32Array:return i;case Uint16Array:return Math.round(i*65535);case Uint8Array:return Math.round(i*255);case Int16Array:return Math.round(i*32767);case Int8Array:return Math.round(i*127);default:throw new Error("Invalid component type.")}}const Oy={DEG2RAD:Hs,RAD2DEG:Sr,generateUUID:gs,clamp:Ce,euclideanModulo:yl,mapLinear:vy,inverseLerp:Gy,lerp:qs,damp:Ny,pingpong:Ly,smoothstep:by,smootherstep:Uy,randInt:ky,randFloat:Ty,randFloatSpread:Hy,seededRandom:qy,degToRad:Jy,radToDeg:Py,isPowerOfTwo:KI,ceilPowerOfTwo:Yy,floorPowerOfTwo:lE,setQuaternionFromProperEuler:Ky,normalize:ge,denormalize:Ns};class Bt{constructor(A=0,t=0){Bt.prototype.isVector2=!0,this.x=A,this.y=t}get width(){return this.x}set width(A){this.x=A}get height(){return this.y}set height(A){this.y=A}set(A,t){return this.x=A,this.y=t,this}setScalar(A){return this.x=A,this.y=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setComponent(A,t){switch(A){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y)}copy(A){return this.x=A.x,this.y=A.y,this}add(A){return this.x+=A.x,this.y+=A.y,this}addScalar(A){return this.x+=A,this.y+=A,this}addVectors(A,t){return this.x=A.x+t.x,this.y=A.y+t.y,this}addScaledVector(A,t){return this.x+=A.x*t,this.y+=A.y*t,this}sub(A){return this.x-=A.x,this.y-=A.y,this}subScalar(A){return this.x-=A,this.y-=A,this}subVectors(A,t){return this.x=A.x-t.x,this.y=A.y-t.y,this}multiply(A){return this.x*=A.x,this.y*=A.y,this}multiplyScalar(A){return this.x*=A,this.y*=A,this}divide(A){return this.x/=A.x,this.y/=A.y,this}divideScalar(A){return this.multiplyScalar(1/A)}applyMatrix3(A){const t=this.x,e=this.y,n=A.elements;return this.x=n[0]*t+n[3]*e+n[6],this.y=n[1]*t+n[4]*e+n[7],this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this}clamp(A,t){return this.x=Math.max(A.x,Math.min(t.x,this.x)),this.y=Math.max(A.y,Math.min(t.y,this.y)),this}clampScalar(A,t){return this.x=Math.max(A,Math.min(t,this.x)),this.y=Math.max(A,Math.min(t,this.y)),this}clampLength(A,t){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(A,Math.min(t,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(A){return this.x*A.x+this.y*A.y}cross(A){return this.x*A.y-this.y*A.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const t=this.x-A.x,e=this.y-A.y;return t*t+e*e}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,t){return this.x+=(A.x-this.x)*t,this.y+=(A.y-this.y)*t,this}lerpVectors(A,t,e){return this.x=A.x+(t.x-A.x)*e,this.y=A.y+(t.y-A.y)*e,this}equals(A){return A.x===this.x&&A.y===this.y}fromArray(A,t=0){return this.x=A[t],this.y=A[t+1],this}toArray(A=[],t=0){return A[t]=this.x,A[t+1]=this.y,A}fromBufferAttribute(A,t){return this.x=A.getX(t),this.y=A.getY(t),this}rotateAround(A,t){const e=Math.cos(t),n=Math.sin(t),a=this.x-A.x,o=this.y-A.y;return this.x=a*e-o*n+A.x,this.y=a*n+o*e+A.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class re{constructor(){re.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(A,t,e,n,a,o,s,I,r){const g=this.elements;return g[0]=A,g[1]=n,g[2]=s,g[3]=t,g[4]=a,g[5]=I,g[6]=e,g[7]=o,g[8]=r,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(A){const t=this.elements,e=A.elements;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],this}extractBasis(A,t,e){return A.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),e.setFromMatrix3Column(this,2),this}setFromMatrix4(A){const t=A.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,t){const e=A.elements,n=t.elements,a=this.elements,o=e[0],s=e[3],I=e[6],r=e[1],g=e[4],C=e[7],B=e[2],c=e[5],Q=e[8],h=n[0],l=n[3],E=n[6],f=n[1],u=n[4],d=n[7],m=n[2],S=n[5],D=n[8];return a[0]=o*h+s*f+I*m,a[3]=o*l+s*u+I*S,a[6]=o*E+s*d+I*D,a[1]=r*h+g*f+C*m,a[4]=r*l+g*u+C*S,a[7]=r*E+g*d+C*D,a[2]=B*h+c*f+Q*m,a[5]=B*l+c*u+Q*S,a[8]=B*E+c*d+Q*D,this}multiplyScalar(A){const t=this.elements;return t[0]*=A,t[3]*=A,t[6]*=A,t[1]*=A,t[4]*=A,t[7]*=A,t[2]*=A,t[5]*=A,t[8]*=A,this}determinant(){const A=this.elements,t=A[0],e=A[1],n=A[2],a=A[3],o=A[4],s=A[5],I=A[6],r=A[7],g=A[8];return t*o*g-t*s*r-e*a*g+e*s*I+n*a*r-n*o*I}invert(){const A=this.elements,t=A[0],e=A[1],n=A[2],a=A[3],o=A[4],s=A[5],I=A[6],r=A[7],g=A[8],C=g*o-s*r,B=s*I-g*a,c=r*a-o*I,Q=t*C+e*B+n*c;if(Q===0)return this.set(0,0,0,0,0,0,0,0,0);const h=1/Q;return A[0]=C*h,A[1]=(n*r-g*e)*h,A[2]=(s*e-n*o)*h,A[3]=B*h,A[4]=(g*t-n*I)*h,A[5]=(n*a-s*t)*h,A[6]=c*h,A[7]=(e*I-r*t)*h,A[8]=(o*t-e*a)*h,this}transpose(){let A;const t=this.elements;return A=t[1],t[1]=t[3],t[3]=A,A=t[2],t[2]=t[6],t[6]=A,A=t[5],t[5]=t[7],t[7]=A,this}getNormalMatrix(A){return this.setFromMatrix4(A).invert().transpose()}transposeIntoArray(A){const t=this.elements;return A[0]=t[0],A[1]=t[3],A[2]=t[6],A[3]=t[1],A[4]=t[4],A[5]=t[7],A[6]=t[2],A[7]=t[5],A[8]=t[8],this}setUvTransform(A,t,e,n,a,o,s){const I=Math.cos(a),r=Math.sin(a);return this.set(e*I,e*r,-e*(I*o+r*s)+o+A,-n*r,n*I,-n*(-r*o+I*s)+s+t,0,0,1),this}scale(A,t){return this.premultiply(Lg.makeScale(A,t)),this}rotate(A){return this.premultiply(Lg.makeRotation(-A)),this}translate(A,t){return this.premultiply(Lg.makeTranslation(A,t)),this}makeTranslation(A,t){return this.set(1,0,A,0,1,t,0,0,1),this}makeRotation(A){const t=Math.cos(A),e=Math.sin(A);return this.set(t,-e,0,e,t,0,0,0,1),this}makeScale(A,t){return this.set(A,0,0,0,t,0,0,0,1),this}equals(A){const t=this.elements,e=A.elements;for(let n=0;n<9;n++)if(t[n]!==e[n])return!1;return!0}fromArray(A,t=0){for(let e=0;e<9;e++)this.elements[e]=A[e+t];return this}toArray(A=[],t=0){const e=this.elements;return A[t]=e[0],A[t+1]=e[1],A[t+2]=e[2],A[t+3]=e[3],A[t+4]=e[4],A[t+5]=e[5],A[t+6]=e[6],A[t+7]=e[7],A[t+8]=e[8],A}clone(){return new this.constructor().fromArray(this.elements)}}const Lg=new re;function CE(i){for(let A=i.length-1;A>=0;--A)if(i[A]>=65535)return!0;return!1}function wr(i){return document.createElementNS("http://www.w3.org/1999/xhtml",i)}class go{constructor(A=0,t=0,e=0,n=1){this.isQuaternion=!0,this._x=A,this._y=t,this._z=e,this._w=n}static slerpFlat(A,t,e,n,a,o,s){let I=e[n+0],r=e[n+1],g=e[n+2],C=e[n+3];const B=a[o+0],c=a[o+1],Q=a[o+2],h=a[o+3];if(s===0){A[t+0]=I,A[t+1]=r,A[t+2]=g,A[t+3]=C;return}if(s===1){A[t+0]=B,A[t+1]=c,A[t+2]=Q,A[t+3]=h;return}if(C!==h||I!==B||r!==c||g!==Q){let l=1-s;const E=I*B+r*c+g*Q+C*h,f=E>=0?1:-1,u=1-E*E;if(u>Number.EPSILON){const m=Math.sqrt(u),S=Math.atan2(m,E*f);l=Math.sin(l*S)/m,s=Math.sin(s*S)/m}const d=s*f;if(I=I*l+B*d,r=r*l+c*d,g=g*l+Q*d,C=C*l+h*d,l===1-s){const m=1/Math.sqrt(I*I+r*r+g*g+C*C);I*=m,r*=m,g*=m,C*=m}}A[t]=I,A[t+1]=r,A[t+2]=g,A[t+3]=C}static multiplyQuaternionsFlat(A,t,e,n,a,o){const s=e[n],I=e[n+1],r=e[n+2],g=e[n+3],C=a[o],B=a[o+1],c=a[o+2],Q=a[o+3];return A[t]=s*Q+g*C+I*c-r*B,A[t+1]=I*Q+g*B+r*C-s*c,A[t+2]=r*Q+g*c+s*B-I*C,A[t+3]=g*Q-s*C-I*B-r*c,A}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get w(){return this._w}set w(A){this._w=A,this._onChangeCallback()}set(A,t,e,n){return this._x=A,this._y=t,this._z=e,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(A){return this._x=A.x,this._y=A.y,this._z=A.z,this._w=A.w,this._onChangeCallback(),this}setFromEuler(A,t){const e=A._x,n=A._y,a=A._z,o=A._order,s=Math.cos,I=Math.sin,r=s(e/2),g=s(n/2),C=s(a/2),B=I(e/2),c=I(n/2),Q=I(a/2);switch(o){case"XYZ":this._x=B*g*C+r*c*Q,this._y=r*c*C-B*g*Q,this._z=r*g*Q+B*c*C,this._w=r*g*C-B*c*Q;break;case"YXZ":this._x=B*g*C+r*c*Q,this._y=r*c*C-B*g*Q,this._z=r*g*Q-B*c*C,this._w=r*g*C+B*c*Q;break;case"ZXY":this._x=B*g*C-r*c*Q,this._y=r*c*C+B*g*Q,this._z=r*g*Q+B*c*C,this._w=r*g*C-B*c*Q;break;case"ZYX":this._x=B*g*C-r*c*Q,this._y=r*c*C+B*g*Q,this._z=r*g*Q-B*c*C,this._w=r*g*C+B*c*Q;break;case"YZX":this._x=B*g*C+r*c*Q,this._y=r*c*C+B*g*Q,this._z=r*g*Q-B*c*C,this._w=r*g*C-B*c*Q;break;case"XZY":this._x=B*g*C-r*c*Q,this._y=r*c*C-B*g*Q,this._z=r*g*Q+B*c*C,this._w=r*g*C+B*c*Q;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(A,t){const e=t/2,n=Math.sin(e);return this._x=A.x*n,this._y=A.y*n,this._z=A.z*n,this._w=Math.cos(e),this._onChangeCallback(),this}setFromRotationMatrix(A){const t=A.elements,e=t[0],n=t[4],a=t[8],o=t[1],s=t[5],I=t[9],r=t[2],g=t[6],C=t[10],B=e+s+C;if(B>0){const c=.5/Math.sqrt(B+1);this._w=.25/c,this._x=(g-I)*c,this._y=(a-r)*c,this._z=(o-n)*c}else if(e>s&&e>C){const c=2*Math.sqrt(1+e-s-C);this._w=(g-I)/c,this._x=.25*c,this._y=(n+o)/c,this._z=(a+r)/c}else if(s>C){const c=2*Math.sqrt(1+s-e-C);this._w=(a-r)/c,this._x=(n+o)/c,this._y=.25*c,this._z=(I+g)/c}else{const c=2*Math.sqrt(1+C-e-s);this._w=(o-n)/c,this._x=(a+r)/c,this._y=(I+g)/c,this._z=.25*c}return this._onChangeCallback(),this}setFromUnitVectors(A,t){let e=A.dot(t)+1;return e<Number.EPSILON?(e=0,Math.abs(A.x)>Math.abs(A.z)?(this._x=-A.y,this._y=A.x,this._z=0,this._w=e):(this._x=0,this._y=-A.z,this._z=A.y,this._w=e)):(this._x=A.y*t.z-A.z*t.y,this._y=A.z*t.x-A.x*t.z,this._z=A.x*t.y-A.y*t.x,this._w=e),this.normalize()}angleTo(A){return 2*Math.acos(Math.abs(Ce(this.dot(A),-1,1)))}rotateTowards(A,t){const e=this.angleTo(A);if(e===0)return this;const n=Math.min(1,t/e);return this.slerp(A,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(A){return this._x*A._x+this._y*A._y+this._z*A._z+this._w*A._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let A=this.length();return A===0?(this._x=0,this._y=0,this._z=0,this._w=1):(A=1/A,this._x=this._x*A,this._y=this._y*A,this._z=this._z*A,this._w=this._w*A),this._onChangeCallback(),this}multiply(A){return this.multiplyQuaternions(this,A)}premultiply(A){return this.multiplyQuaternions(A,this)}multiplyQuaternions(A,t){const e=A._x,n=A._y,a=A._z,o=A._w,s=t._x,I=t._y,r=t._z,g=t._w;return this._x=e*g+o*s+n*r-a*I,this._y=n*g+o*I+a*s-e*r,this._z=a*g+o*r+e*I-n*s,this._w=o*g-e*s-n*I-a*r,this._onChangeCallback(),this}slerp(A,t){if(t===0)return this;if(t===1)return this.copy(A);const e=this._x,n=this._y,a=this._z,o=this._w;let s=o*A._w+e*A._x+n*A._y+a*A._z;if(s<0?(this._w=-A._w,this._x=-A._x,this._y=-A._y,this._z=-A._z,s=-s):this.copy(A),s>=1)return this._w=o,this._x=e,this._y=n,this._z=a,this;const I=1-s*s;if(I<=Number.EPSILON){const c=1-t;return this._w=c*o+t*this._w,this._x=c*e+t*this._x,this._y=c*n+t*this._y,this._z=c*a+t*this._z,this.normalize(),this._onChangeCallback(),this}const r=Math.sqrt(I),g=Math.atan2(r,s),C=Math.sin((1-t)*g)/r,B=Math.sin(t*g)/r;return this._w=o*C+this._w*B,this._x=e*C+this._x*B,this._y=n*C+this._y*B,this._z=a*C+this._z*B,this._onChangeCallback(),this}slerpQuaternions(A,t,e){return this.copy(A).slerp(t,e)}random(){const A=Math.random(),t=Math.sqrt(1-A),e=Math.sqrt(A),n=2*Math.PI*Math.random(),a=2*Math.PI*Math.random();return this.set(t*Math.cos(n),e*Math.sin(a),e*Math.cos(a),t*Math.sin(n))}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._w===this._w}fromArray(A,t=0){return this._x=A[t],this._y=A[t+1],this._z=A[t+2],this._w=A[t+3],this._onChangeCallback(),this}toArray(A=[],t=0){return A[t]=this._x,A[t+1]=this._y,A[t+2]=this._z,A[t+3]=this._w,A}fromBufferAttribute(A,t){return this._x=A.getX(t),this._y=A.getY(t),this._z=A.getZ(t),this._w=A.getW(t),this}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class cA{constructor(A=0,t=0,e=0){cA.prototype.isVector3=!0,this.x=A,this.y=t,this.z=e}set(A,t,e){return e===void 0&&(e=this.z),this.x=A,this.y=t,this.z=e,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setComponent(A,t){switch(A){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this}addVectors(A,t){return this.x=A.x+t.x,this.y=A.y+t.y,this.z=A.z+t.z,this}addScaledVector(A,t){return this.x+=A.x*t,this.y+=A.y*t,this.z+=A.z*t,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this}subVectors(A,t){return this.x=A.x-t.x,this.y=A.y-t.y,this.z=A.z-t.z,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this}multiplyVectors(A,t){return this.x=A.x*t.x,this.y=A.y*t.y,this.z=A.z*t.z,this}applyEuler(A){return this.applyQuaternion(kB.setFromEuler(A))}applyAxisAngle(A,t){return this.applyQuaternion(kB.setFromAxisAngle(A,t))}applyMatrix3(A){const t=this.x,e=this.y,n=this.z,a=A.elements;return this.x=a[0]*t+a[3]*e+a[6]*n,this.y=a[1]*t+a[4]*e+a[7]*n,this.z=a[2]*t+a[5]*e+a[8]*n,this}applyNormalMatrix(A){return this.applyMatrix3(A).normalize()}applyMatrix4(A){const t=this.x,e=this.y,n=this.z,a=A.elements,o=1/(a[3]*t+a[7]*e+a[11]*n+a[15]);return this.x=(a[0]*t+a[4]*e+a[8]*n+a[12])*o,this.y=(a[1]*t+a[5]*e+a[9]*n+a[13])*o,this.z=(a[2]*t+a[6]*e+a[10]*n+a[14])*o,this}applyQuaternion(A){const t=this.x,e=this.y,n=this.z,a=A.x,o=A.y,s=A.z,I=A.w,r=I*t+o*n-s*e,g=I*e+s*t-a*n,C=I*n+a*e-o*t,B=-a*t-o*e-s*n;return this.x=r*I+B*-a+g*-s-C*-o,this.y=g*I+B*-o+C*-a-r*-s,this.z=C*I+B*-s+r*-o-g*-a,this}project(A){return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix)}unproject(A){return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld)}transformDirection(A){const t=this.x,e=this.y,n=this.z,a=A.elements;return this.x=a[0]*t+a[4]*e+a[8]*n,this.y=a[1]*t+a[5]*e+a[9]*n,this.z=a[2]*t+a[6]*e+a[10]*n,this.normalize()}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this}divideScalar(A){return this.multiplyScalar(1/A)}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this}clamp(A,t){return this.x=Math.max(A.x,Math.min(t.x,this.x)),this.y=Math.max(A.y,Math.min(t.y,this.y)),this.z=Math.max(A.z,Math.min(t.z,this.z)),this}clampScalar(A,t){return this.x=Math.max(A,Math.min(t,this.x)),this.y=Math.max(A,Math.min(t,this.y)),this.z=Math.max(A,Math.min(t,this.z)),this}clampLength(A,t){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(A,Math.min(t,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,t){return this.x+=(A.x-this.x)*t,this.y+=(A.y-this.y)*t,this.z+=(A.z-this.z)*t,this}lerpVectors(A,t,e){return this.x=A.x+(t.x-A.x)*e,this.y=A.y+(t.y-A.y)*e,this.z=A.z+(t.z-A.z)*e,this}cross(A){return this.crossVectors(this,A)}crossVectors(A,t){const e=A.x,n=A.y,a=A.z,o=t.x,s=t.y,I=t.z;return this.x=n*I-a*s,this.y=a*o-e*I,this.z=e*s-n*o,this}projectOnVector(A){const t=A.lengthSq();if(t===0)return this.set(0,0,0);const e=A.dot(this)/t;return this.copy(A).multiplyScalar(e)}projectOnPlane(A){return bg.copy(this).projectOnVector(A),this.sub(bg)}reflect(A){return this.sub(bg.copy(A).multiplyScalar(2*this.dot(A)))}angleTo(A){const t=Math.sqrt(this.lengthSq()*A.lengthSq());if(t===0)return Math.PI/2;const e=this.dot(A)/t;return Math.acos(Ce(e,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const t=this.x-A.x,e=this.y-A.y,n=this.z-A.z;return t*t+e*e+n*n}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)+Math.abs(this.z-A.z)}setFromSpherical(A){return this.setFromSphericalCoords(A.radius,A.phi,A.theta)}setFromSphericalCoords(A,t,e){const n=Math.sin(t)*A;return this.x=n*Math.sin(e),this.y=Math.cos(t)*A,this.z=n*Math.cos(e),this}setFromCylindrical(A){return this.setFromCylindricalCoords(A.radius,A.theta,A.y)}setFromCylindricalCoords(A,t,e){return this.x=A*Math.sin(t),this.y=e,this.z=A*Math.cos(t),this}setFromMatrixPosition(A){const t=A.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(A){const t=this.setFromMatrixColumn(A,0).length(),e=this.setFromMatrixColumn(A,1).length(),n=this.setFromMatrixColumn(A,2).length();return this.x=t,this.y=e,this.z=n,this}setFromMatrixColumn(A,t){return this.fromArray(A.elements,t*4)}setFromMatrix3Column(A,t){return this.fromArray(A.elements,t*3)}setFromEuler(A){return this.x=A._x,this.y=A._y,this.z=A._z,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z}fromArray(A,t=0){return this.x=A[t],this.y=A[t+1],this.z=A[t+2],this}toArray(A=[],t=0){return A[t]=this.x,A[t+1]=this.y,A[t+2]=this.z,A}fromBufferAttribute(A,t){return this.x=A.getX(t),this.y=A.getY(t),this.z=A.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const A=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,e=Math.sqrt(1-A**2);return this.x=e*Math.cos(t),this.y=e*Math.sin(t),this.z=A,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const bg=new cA,kB=new go;function Va(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function Ug(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}const Wy=new re().fromArray([.8224621,.0331941,.0170827,.177538,.9668058,.0723974,-1e-7,1e-7,.9105199]),Vy=new re().fromArray([1.2249401,-.0420569,-.0196376,-.2249404,1.0420571,-.0786361,1e-7,0,1.0982735]),$i=new cA;function zy(i){return i.convertSRGBToLinear(),$i.set(i.r,i.g,i.b).applyMatrix3(Vy),i.setRGB($i.x,$i.y,$i.z)}function Xy(i){return $i.set(i.r,i.g,i.b).applyMatrix3(Wy),i.setRGB($i.x,$i.y,$i.z).convertLinearToSRGB()}const Zy={[zs]:i=>i,[$e]:i=>i.convertSRGBToLinear(),[IE]:zy},jy={[zs]:i=>i,[$e]:i=>i.convertLinearToSRGB(),[IE]:Xy},ee={enabled:!1,get legacyMode(){return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),!this.enabled},set legacyMode(i){console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),this.enabled=!i},get workingColorSpace(){return zs},set workingColorSpace(i){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(i,A,t){if(this.enabled===!1||A===t||!A||!t)return i;const e=Zy[A],n=jy[t];if(e===void 0||n===void 0)throw new Error(`Unsupported color space conversion, "${A}" to "${t}".`);return n(e(i))},fromWorkingColorSpace:function(i,A){return this.convert(i,this.workingColorSpace,A)},toWorkingColorSpace:function(i,A){return this.convert(i,A,this.workingColorSpace)}};let ua;class BE{static getDataURL(A){if(/^data:/i.test(A.src)||typeof HTMLCanvasElement>"u")return A.src;let t;if(A instanceof HTMLCanvasElement)t=A;else{ua===void 0&&(ua=wr("canvas")),ua.width=A.width,ua.height=A.height;const e=ua.getContext("2d");A instanceof ImageData?e.putImageData(A,0,0):e.drawImage(A,0,0,A.width,A.height),t=ua}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",A),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(A){if(typeof HTMLImageElement<"u"&&A instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&A instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&A instanceof ImageBitmap){const t=wr("canvas");t.width=A.width,t.height=A.height;const e=t.getContext("2d");e.drawImage(A,0,0,A.width,A.height);const n=e.getImageData(0,0,A.width,A.height),a=n.data;for(let o=0;o<a.length;o++)a[o]=Va(a[o]/255)*255;return e.putImageData(n,0,0),t}else if(A.data){const t=A.data.slice(0);for(let e=0;e<t.length;e++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[e]=Math.floor(Va(t[e]/255)*255):t[e]=Va(t[e]);return{data:t,width:A.width,height:A.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),A}}class hE{constructor(A=null){this.isSource=!0,this.uuid=gs(),this.data=A,this.version=0}set needsUpdate(A){A===!0&&this.version++}toJSON(A){const t=A===void 0||typeof A=="string";if(!t&&A.images[this.uuid]!==void 0)return A.images[this.uuid];const e={uuid:this.uuid,url:""},n=this.data;if(n!==null){let a;if(Array.isArray(n)){a=[];for(let o=0,s=n.length;o<s;o++)n[o].isDataTexture?a.push(kg(n[o].image)):a.push(kg(n[o]))}else a=kg(n);e.url=a}return t||(A.images[this.uuid]=e),e}}function kg(i){return typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&i instanceof ImageBitmap?BE.getDataURL(i):i.data?{data:Array.from(i.data),width:i.width,height:i.height,type:i.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let $y=0;class Ee extends rs{constructor(A=Ee.DEFAULT_IMAGE,t=Ee.DEFAULT_MAPPING,e=Fe,n=Fe,a=te,o=Ws,s=Ke,I=Yn,r=Ee.DEFAULT_ANISOTROPY,g=Kn){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:$y++}),this.uuid=gs(),this.name="",this.source=new hE(A),this.mipmaps=[],this.mapping=t,this.wrapS=e,this.wrapT=n,this.magFilter=a,this.minFilter=o,this.anisotropy=r,this.format=s,this.internalFormat=null,this.type=I,this.offset=new Bt(0,0),this.repeat=new Bt(1,1),this.center=new Bt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new re,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=g,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(A=null){this.source.data=A}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(A){return this.name=A.name,this.source=A.source,this.mipmaps=A.mipmaps.slice(0),this.mapping=A.mapping,this.wrapS=A.wrapS,this.wrapT=A.wrapT,this.magFilter=A.magFilter,this.minFilter=A.minFilter,this.anisotropy=A.anisotropy,this.format=A.format,this.internalFormat=A.internalFormat,this.type=A.type,this.offset.copy(A.offset),this.repeat.copy(A.repeat),this.center.copy(A.center),this.rotation=A.rotation,this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrix.copy(A.matrix),this.generateMipmaps=A.generateMipmaps,this.premultiplyAlpha=A.premultiplyAlpha,this.flipY=A.flipY,this.unpackAlignment=A.unpackAlignment,this.encoding=A.encoding,this.userData=JSON.parse(JSON.stringify(A.userData)),this.needsUpdate=!0,this}toJSON(A){const t=A===void 0||typeof A=="string";if(!t&&A.textures[this.uuid]!==void 0)return A.textures[this.uuid];const e={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(A).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(e.userData=this.userData),t||(A.textures[this.uuid]=e),e}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(A){if(this.mapping!==oE)return A;if(A.applyMatrix3(this.matrix),A.x<0||A.x>1)switch(this.wrapS){case qI:A.x=A.x-Math.floor(A.x);break;case Fe:A.x=A.x<0?0:1;break;case JI:Math.abs(Math.floor(A.x)%2)===1?A.x=Math.ceil(A.x)-A.x:A.x=A.x-Math.floor(A.x);break}if(A.y<0||A.y>1)switch(this.wrapT){case qI:A.y=A.y-Math.floor(A.y);break;case Fe:A.y=A.y<0?0:1;break;case JI:Math.abs(Math.floor(A.y)%2)===1?A.y=Math.ceil(A.y)-A.y:A.y=A.y-Math.floor(A.y);break}return this.flipY&&(A.y=1-A.y),A}set needsUpdate(A){A===!0&&(this.version++,this.source.needsUpdate=!0)}}Ee.DEFAULT_IMAGE=null;Ee.DEFAULT_MAPPING=oE;Ee.DEFAULT_ANISOTROPY=1;class Vt{constructor(A=0,t=0,e=0,n=1){Vt.prototype.isVector4=!0,this.x=A,this.y=t,this.z=e,this.w=n}get width(){return this.z}set width(A){this.z=A}get height(){return this.w}set height(A){this.w=A}set(A,t,e,n){return this.x=A,this.y=t,this.z=e,this.w=n,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this.w=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setW(A){return this.w=A,this}setComponent(A,t){switch(A){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this.w=A.w!==void 0?A.w:1,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this.w+=A.w,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this.w+=A,this}addVectors(A,t){return this.x=A.x+t.x,this.y=A.y+t.y,this.z=A.z+t.z,this.w=A.w+t.w,this}addScaledVector(A,t){return this.x+=A.x*t,this.y+=A.y*t,this.z+=A.z*t,this.w+=A.w*t,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this.w-=A.w,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this.w-=A,this}subVectors(A,t){return this.x=A.x-t.x,this.y=A.y-t.y,this.z=A.z-t.z,this.w=A.w-t.w,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this.w*=A.w,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this.w*=A,this}applyMatrix4(A){const t=this.x,e=this.y,n=this.z,a=this.w,o=A.elements;return this.x=o[0]*t+o[4]*e+o[8]*n+o[12]*a,this.y=o[1]*t+o[5]*e+o[9]*n+o[13]*a,this.z=o[2]*t+o[6]*e+o[10]*n+o[14]*a,this.w=o[3]*t+o[7]*e+o[11]*n+o[15]*a,this}divideScalar(A){return this.multiplyScalar(1/A)}setAxisAngleFromQuaternion(A){this.w=2*Math.acos(A.w);const t=Math.sqrt(1-A.w*A.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=A.x/t,this.y=A.y/t,this.z=A.z/t),this}setAxisAngleFromRotationMatrix(A){let t,e,n,a;const I=A.elements,r=I[0],g=I[4],C=I[8],B=I[1],c=I[5],Q=I[9],h=I[2],l=I[6],E=I[10];if(Math.abs(g-B)<.01&&Math.abs(C-h)<.01&&Math.abs(Q-l)<.01){if(Math.abs(g+B)<.1&&Math.abs(C+h)<.1&&Math.abs(Q+l)<.1&&Math.abs(r+c+E-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const u=(r+1)/2,d=(c+1)/2,m=(E+1)/2,S=(g+B)/4,D=(C+h)/4,p=(Q+l)/4;return u>d&&u>m?u<.01?(e=0,n=.707106781,a=.707106781):(e=Math.sqrt(u),n=S/e,a=D/e):d>m?d<.01?(e=.707106781,n=0,a=.707106781):(n=Math.sqrt(d),e=S/n,a=p/n):m<.01?(e=.707106781,n=.707106781,a=0):(a=Math.sqrt(m),e=D/a,n=p/a),this.set(e,n,a,t),this}let f=Math.sqrt((l-Q)*(l-Q)+(C-h)*(C-h)+(B-g)*(B-g));return Math.abs(f)<.001&&(f=1),this.x=(l-Q)/f,this.y=(C-h)/f,this.z=(B-g)/f,this.w=Math.acos((r+c+E-1)/2),this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this.w=Math.min(this.w,A.w),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this.w=Math.max(this.w,A.w),this}clamp(A,t){return this.x=Math.max(A.x,Math.min(t.x,this.x)),this.y=Math.max(A.y,Math.min(t.y,this.y)),this.z=Math.max(A.z,Math.min(t.z,this.z)),this.w=Math.max(A.w,Math.min(t.w,this.w)),this}clampScalar(A,t){return this.x=Math.max(A,Math.min(t,this.x)),this.y=Math.max(A,Math.min(t,this.y)),this.z=Math.max(A,Math.min(t,this.z)),this.w=Math.max(A,Math.min(t,this.w)),this}clampLength(A,t){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(A,Math.min(t,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z+this.w*A.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,t){return this.x+=(A.x-this.x)*t,this.y+=(A.y-this.y)*t,this.z+=(A.z-this.z)*t,this.w+=(A.w-this.w)*t,this}lerpVectors(A,t,e){return this.x=A.x+(t.x-A.x)*e,this.y=A.y+(t.y-A.y)*e,this.z=A.z+(t.z-A.z)*e,this.w=A.w+(t.w-A.w)*e,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z&&A.w===this.w}fromArray(A,t=0){return this.x=A[t],this.y=A[t+1],this.z=A[t+2],this.w=A[t+3],this}toArray(A=[],t=0){return A[t]=this.x,A[t+1]=this.y,A[t+2]=this.z,A[t+3]=this.w,A}fromBufferAttribute(A,t){return this.x=A.getX(t),this.y=A.getY(t),this.z=A.getZ(t),this.w=A.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class On extends rs{constructor(A=1,t=1,e={}){super(),this.isWebGLRenderTarget=!0,this.width=A,this.height=t,this.depth=1,this.scissor=new Vt(0,0,A,t),this.scissorTest=!1,this.viewport=new Vt(0,0,A,t);const n={width:A,height:t,depth:1};this.texture=new Ee(n,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.internalFormat=e.internalFormat!==void 0?e.internalFormat:null,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:te,this.depthBuffer=e.depthBuffer!==void 0?e.depthBuffer:!0,this.stencilBuffer=e.stencilBuffer!==void 0?e.stencilBuffer:!1,this.depthTexture=e.depthTexture!==void 0?e.depthTexture:null,this.samples=e.samples!==void 0?e.samples:0}setSize(A,t,e=1){(this.width!==A||this.height!==t||this.depth!==e)&&(this.width=A,this.height=t,this.depth=e,this.texture.image.width=A,this.texture.image.height=t,this.texture.image.depth=e,this.dispose()),this.viewport.set(0,0,A,t),this.scissor.set(0,0,A,t)}clone(){return new this.constructor().copy(this)}copy(A){this.width=A.width,this.height=A.height,this.depth=A.depth,this.viewport.copy(A.viewport),this.texture=A.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},A.texture.image);return this.texture.source=new hE(t),this.depthBuffer=A.depthBuffer,this.stencilBuffer=A.stencilBuffer,A.depthTexture!==null&&(this.depthTexture=A.depthTexture.clone()),this.samples=A.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class cE extends Ee{constructor(A=null,t=1,e=1,n=1){super(null),this.isDataArrayTexture=!0,this.image={data:A,width:t,height:e,depth:n},this.magFilter=ne,this.minFilter=ne,this.wrapR=Fe,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class OI extends Ee{constructor(A=null,t=1,e=1,n=1){super(null),this.isData3DTexture=!0,this.image={data:A,width:t,height:e,depth:n},this.magFilter=ne,this.minFilter=ne,this.wrapR=Fe,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Is{constructor(A=new cA(1/0,1/0,1/0),t=new cA(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=A,this.max=t}set(A,t){return this.min.copy(A),this.max.copy(t),this}setFromArray(A){let t=1/0,e=1/0,n=1/0,a=-1/0,o=-1/0,s=-1/0;for(let I=0,r=A.length;I<r;I+=3){const g=A[I],C=A[I+1],B=A[I+2];g<t&&(t=g),C<e&&(e=C),B<n&&(n=B),g>a&&(a=g),C>o&&(o=C),B>s&&(s=B)}return this.min.set(t,e,n),this.max.set(a,o,s),this}setFromBufferAttribute(A){let t=1/0,e=1/0,n=1/0,a=-1/0,o=-1/0,s=-1/0;for(let I=0,r=A.count;I<r;I++){const g=A.getX(I),C=A.getY(I),B=A.getZ(I);g<t&&(t=g),C<e&&(e=C),B<n&&(n=B),g>a&&(a=g),C>o&&(o=C),B>s&&(s=B)}return this.min.set(t,e,n),this.max.set(a,o,s),this}setFromPoints(A){this.makeEmpty();for(let t=0,e=A.length;t<e;t++)this.expandByPoint(A[t]);return this}setFromCenterAndSize(A,t){const e=Qn.copy(t).multiplyScalar(.5);return this.min.copy(A).sub(e),this.max.copy(A).add(e),this}setFromObject(A,t=!1){return this.makeEmpty(),this.expandByObject(A,t)}clone(){return new this.constructor().copy(this)}copy(A){return this.min.copy(A.min),this.max.copy(A.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(A){return this.isEmpty()?A.set(0,0,0):A.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(A){return this.isEmpty()?A.set(0,0,0):A.subVectors(this.max,this.min)}expandByPoint(A){return this.min.min(A),this.max.max(A),this}expandByVector(A){return this.min.sub(A),this.max.add(A),this}expandByScalar(A){return this.min.addScalar(-A),this.max.addScalar(A),this}expandByObject(A,t=!1){A.updateWorldMatrix(!1,!1);const e=A.geometry;if(e!==void 0)if(t&&e.attributes!=null&&e.attributes.position!==void 0){const a=e.attributes.position;for(let o=0,s=a.count;o<s;o++)Qn.fromBufferAttribute(a,o).applyMatrix4(A.matrixWorld),this.expandByPoint(Qn)}else e.boundingBox===null&&e.computeBoundingBox(),Tg.copy(e.boundingBox),Tg.applyMatrix4(A.matrixWorld),this.union(Tg);const n=A.children;for(let a=0,o=n.length;a<o;a++)this.expandByObject(n[a],t);return this}containsPoint(A){return!(A.x<this.min.x||A.x>this.max.x||A.y<this.min.y||A.y>this.max.y||A.z<this.min.z||A.z>this.max.z)}containsBox(A){return this.min.x<=A.min.x&&A.max.x<=this.max.x&&this.min.y<=A.min.y&&A.max.y<=this.max.y&&this.min.z<=A.min.z&&A.max.z<=this.max.z}getParameter(A,t){return t.set((A.x-this.min.x)/(this.max.x-this.min.x),(A.y-this.min.y)/(this.max.y-this.min.y),(A.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(A){return!(A.max.x<this.min.x||A.min.x>this.max.x||A.max.y<this.min.y||A.min.y>this.max.y||A.max.z<this.min.z||A.min.z>this.max.z)}intersectsSphere(A){return this.clampPoint(A.center,Qn),Qn.distanceToSquared(A.center)<=A.radius*A.radius}intersectsPlane(A){let t,e;return A.normal.x>0?(t=A.normal.x*this.min.x,e=A.normal.x*this.max.x):(t=A.normal.x*this.max.x,e=A.normal.x*this.min.x),A.normal.y>0?(t+=A.normal.y*this.min.y,e+=A.normal.y*this.max.y):(t+=A.normal.y*this.max.y,e+=A.normal.y*this.min.y),A.normal.z>0?(t+=A.normal.z*this.min.z,e+=A.normal.z*this.max.z):(t+=A.normal.z*this.max.z,e+=A.normal.z*this.min.z),t<=-A.constant&&e>=-A.constant}intersectsTriangle(A){if(this.isEmpty())return!1;this.getCenter(us),Ho.subVectors(this.max,us),pa.subVectors(A.a,us),ma.subVectors(A.b,us),ya.subVectors(A.c,us),Pi.subVectors(ma,pa),Yi.subVectors(ya,ma),dn.subVectors(pa,ya);let t=[0,-Pi.z,Pi.y,0,-Yi.z,Yi.y,0,-dn.z,dn.y,Pi.z,0,-Pi.x,Yi.z,0,-Yi.x,dn.z,0,-dn.x,-Pi.y,Pi.x,0,-Yi.y,Yi.x,0,-dn.y,dn.x,0];return!Hg(t,pa,ma,ya,Ho)||(t=[1,0,0,0,1,0,0,0,1],!Hg(t,pa,ma,ya,Ho))?!1:(qo.crossVectors(Pi,Yi),t=[qo.x,qo.y,qo.z],Hg(t,pa,ma,ya,Ho))}clampPoint(A,t){return t.copy(A).clamp(this.min,this.max)}distanceToPoint(A){return this.clampPoint(A,Qn).distanceTo(A)}getBoundingSphere(A){return this.isEmpty()?A.makeEmpty():(this.getCenter(A.center),A.radius=this.getSize(Qn).length()*.5),A}intersect(A){return this.min.max(A.min),this.max.min(A.max),this.isEmpty()&&this.makeEmpty(),this}union(A){return this.min.min(A.min),this.max.max(A.max),this}applyMatrix4(A){return this.isEmpty()?this:(di[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(A),di[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(A),di[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(A),di[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(A),di[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(A),di[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(A),di[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(A),di[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(A),this.setFromPoints(di),this)}translate(A){return this.min.add(A),this.max.add(A),this}equals(A){return A.min.equals(this.min)&&A.max.equals(this.max)}}const di=[new cA,new cA,new cA,new cA,new cA,new cA,new cA,new cA],Qn=new cA,Tg=new Is,pa=new cA,ma=new cA,ya=new cA,Pi=new cA,Yi=new cA,dn=new cA,us=new cA,Ho=new cA,qo=new cA,fn=new cA;function Hg(i,A,t,e,n){for(let a=0,o=i.length-3;a<=o;a+=3){fn.fromArray(i,a);const s=n.x*Math.abs(fn.x)+n.y*Math.abs(fn.y)+n.z*Math.abs(fn.z),I=A.dot(fn),r=t.dot(fn),g=e.dot(fn);if(Math.max(-Math.max(I,r,g),Math.min(I,r,g))>s)return!1}return!0}const AD=new Is,ps=new cA,qg=new cA;class Dl{constructor(A=new cA,t=-1){this.center=A,this.radius=t}set(A,t){return this.center.copy(A),this.radius=t,this}setFromPoints(A,t){const e=this.center;t!==void 0?e.copy(t):AD.setFromPoints(A).getCenter(e);let n=0;for(let a=0,o=A.length;a<o;a++)n=Math.max(n,e.distanceToSquared(A[a]));return this.radius=Math.sqrt(n),this}copy(A){return this.center.copy(A.center),this.radius=A.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(A){return A.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(A){return A.distanceTo(this.center)-this.radius}intersectsSphere(A){const t=this.radius+A.radius;return A.center.distanceToSquared(this.center)<=t*t}intersectsBox(A){return A.intersectsSphere(this)}intersectsPlane(A){return Math.abs(A.distanceToPoint(this.center))<=this.radius}clampPoint(A,t){const e=this.center.distanceToSquared(A);return t.copy(A),e>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(A){return this.isEmpty()?(A.makeEmpty(),A):(A.set(this.center,this.center),A.expandByScalar(this.radius),A)}applyMatrix4(A){return this.center.applyMatrix4(A),this.radius=this.radius*A.getMaxScaleOnAxis(),this}translate(A){return this.center.add(A),this}expandByPoint(A){if(this.isEmpty())return this.center.copy(A),this.radius=0,this;ps.subVectors(A,this.center);const t=ps.lengthSq();if(t>this.radius*this.radius){const e=Math.sqrt(t),n=(e-this.radius)*.5;this.center.addScaledVector(ps,n/e),this.radius+=n}return this}union(A){return A.isEmpty()?this:this.isEmpty()?(this.copy(A),this):(this.center.equals(A.center)===!0?this.radius=Math.max(this.radius,A.radius):(qg.subVectors(A.center,this.center).setLength(A.radius),this.expandByPoint(ps.copy(A.center).add(qg)),this.expandByPoint(ps.copy(A.center).sub(qg))),this)}equals(A){return A.center.equals(this.center)&&A.radius===this.radius}clone(){return new this.constructor().copy(this)}}const fi=new cA,Jg=new cA,Jo=new cA,Ki=new cA,Pg=new cA,Po=new cA,Yg=new cA;class tD{constructor(A=new cA,t=new cA(0,0,-1)){this.origin=A,this.direction=t}set(A,t){return this.origin.copy(A),this.direction.copy(t),this}copy(A){return this.origin.copy(A.origin),this.direction.copy(A.direction),this}at(A,t){return t.copy(this.origin).addScaledVector(this.direction,A)}lookAt(A){return this.direction.copy(A).sub(this.origin).normalize(),this}recast(A){return this.origin.copy(this.at(A,fi)),this}closestPointToPoint(A,t){t.subVectors(A,this.origin);const e=t.dot(this.direction);return e<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,e)}distanceToPoint(A){return Math.sqrt(this.distanceSqToPoint(A))}distanceSqToPoint(A){const t=fi.subVectors(A,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(A):(fi.copy(this.origin).addScaledVector(this.direction,t),fi.distanceToSquared(A))}distanceSqToSegment(A,t,e,n){Jg.copy(A).add(t).multiplyScalar(.5),Jo.copy(t).sub(A).normalize(),Ki.copy(this.origin).sub(Jg);const a=A.distanceTo(t)*.5,o=-this.direction.dot(Jo),s=Ki.dot(this.direction),I=-Ki.dot(Jo),r=Ki.lengthSq(),g=Math.abs(1-o*o);let C,B,c,Q;if(g>0)if(C=o*I-s,B=o*s-I,Q=a*g,C>=0)if(B>=-Q)if(B<=Q){const h=1/g;C*=h,B*=h,c=C*(C+o*B+2*s)+B*(o*C+B+2*I)+r}else B=a,C=Math.max(0,-(o*B+s)),c=-C*C+B*(B+2*I)+r;else B=-a,C=Math.max(0,-(o*B+s)),c=-C*C+B*(B+2*I)+r;else B<=-Q?(C=Math.max(0,-(-o*a+s)),B=C>0?-a:Math.min(Math.max(-a,-I),a),c=-C*C+B*(B+2*I)+r):B<=Q?(C=0,B=Math.min(Math.max(-a,-I),a),c=B*(B+2*I)+r):(C=Math.max(0,-(o*a+s)),B=C>0?a:Math.min(Math.max(-a,-I),a),c=-C*C+B*(B+2*I)+r);else B=o>0?-a:a,C=Math.max(0,-(o*B+s)),c=-C*C+B*(B+2*I)+r;return e&&e.copy(this.origin).addScaledVector(this.direction,C),n&&n.copy(Jg).addScaledVector(Jo,B),c}intersectSphere(A,t){fi.subVectors(A.center,this.origin);const e=fi.dot(this.direction),n=fi.dot(fi)-e*e,a=A.radius*A.radius;if(n>a)return null;const o=Math.sqrt(a-n),s=e-o,I=e+o;return I<0?null:s<0?this.at(I,t):this.at(s,t)}intersectsSphere(A){return this.distanceSqToPoint(A.center)<=A.radius*A.radius}distanceToPlane(A){const t=A.normal.dot(this.direction);if(t===0)return A.distanceToPoint(this.origin)===0?0:null;const e=-(this.origin.dot(A.normal)+A.constant)/t;return e>=0?e:null}intersectPlane(A,t){const e=this.distanceToPlane(A);return e===null?null:this.at(e,t)}intersectsPlane(A){const t=A.distanceToPoint(this.origin);return t===0||A.normal.dot(this.direction)*t<0}intersectBox(A,t){let e,n,a,o,s,I;const r=1/this.direction.x,g=1/this.direction.y,C=1/this.direction.z,B=this.origin;return r>=0?(e=(A.min.x-B.x)*r,n=(A.max.x-B.x)*r):(e=(A.max.x-B.x)*r,n=(A.min.x-B.x)*r),g>=0?(a=(A.min.y-B.y)*g,o=(A.max.y-B.y)*g):(a=(A.max.y-B.y)*g,o=(A.min.y-B.y)*g),e>o||a>n||((a>e||isNaN(e))&&(e=a),(o<n||isNaN(n))&&(n=o),C>=0?(s=(A.min.z-B.z)*C,I=(A.max.z-B.z)*C):(s=(A.max.z-B.z)*C,I=(A.min.z-B.z)*C),e>I||s>n)||((s>e||e!==e)&&(e=s),(I<n||n!==n)&&(n=I),n<0)?null:this.at(e>=0?e:n,t)}intersectsBox(A){return this.intersectBox(A,fi)!==null}intersectTriangle(A,t,e,n,a){Pg.subVectors(t,A),Po.subVectors(e,A),Yg.crossVectors(Pg,Po);let o=this.direction.dot(Yg),s;if(o>0){if(n)return null;s=1}else if(o<0)s=-1,o=-o;else return null;Ki.subVectors(this.origin,A);const I=s*this.direction.dot(Po.crossVectors(Ki,Po));if(I<0)return null;const r=s*this.direction.dot(Pg.cross(Ki));if(r<0||I+r>o)return null;const g=-s*Ki.dot(Yg);return g<0?null:this.at(g/o,a)}applyMatrix4(A){return this.origin.applyMatrix4(A),this.direction.transformDirection(A),this}equals(A){return A.origin.equals(this.origin)&&A.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class xt{constructor(){xt.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(A,t,e,n,a,o,s,I,r,g,C,B,c,Q,h,l){const E=this.elements;return E[0]=A,E[4]=t,E[8]=e,E[12]=n,E[1]=a,E[5]=o,E[9]=s,E[13]=I,E[2]=r,E[6]=g,E[10]=C,E[14]=B,E[3]=c,E[7]=Q,E[11]=h,E[15]=l,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new xt().fromArray(this.elements)}copy(A){const t=this.elements,e=A.elements;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],this}copyPosition(A){const t=this.elements,e=A.elements;return t[12]=e[12],t[13]=e[13],t[14]=e[14],this}setFromMatrix3(A){const t=A.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(A,t,e){return A.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}makeBasis(A,t,e){return this.set(A.x,t.x,e.x,0,A.y,t.y,e.y,0,A.z,t.z,e.z,0,0,0,0,1),this}extractRotation(A){const t=this.elements,e=A.elements,n=1/Da.setFromMatrixColumn(A,0).length(),a=1/Da.setFromMatrixColumn(A,1).length(),o=1/Da.setFromMatrixColumn(A,2).length();return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=0,t[4]=e[4]*a,t[5]=e[5]*a,t[6]=e[6]*a,t[7]=0,t[8]=e[8]*o,t[9]=e[9]*o,t[10]=e[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(A){const t=this.elements,e=A.x,n=A.y,a=A.z,o=Math.cos(e),s=Math.sin(e),I=Math.cos(n),r=Math.sin(n),g=Math.cos(a),C=Math.sin(a);if(A.order==="XYZ"){const B=o*g,c=o*C,Q=s*g,h=s*C;t[0]=I*g,t[4]=-I*C,t[8]=r,t[1]=c+Q*r,t[5]=B-h*r,t[9]=-s*I,t[2]=h-B*r,t[6]=Q+c*r,t[10]=o*I}else if(A.order==="YXZ"){const B=I*g,c=I*C,Q=r*g,h=r*C;t[0]=B+h*s,t[4]=Q*s-c,t[8]=o*r,t[1]=o*C,t[5]=o*g,t[9]=-s,t[2]=c*s-Q,t[6]=h+B*s,t[10]=o*I}else if(A.order==="ZXY"){const B=I*g,c=I*C,Q=r*g,h=r*C;t[0]=B-h*s,t[4]=-o*C,t[8]=Q+c*s,t[1]=c+Q*s,t[5]=o*g,t[9]=h-B*s,t[2]=-o*r,t[6]=s,t[10]=o*I}else if(A.order==="ZYX"){const B=o*g,c=o*C,Q=s*g,h=s*C;t[0]=I*g,t[4]=Q*r-c,t[8]=B*r+h,t[1]=I*C,t[5]=h*r+B,t[9]=c*r-Q,t[2]=-r,t[6]=s*I,t[10]=o*I}else if(A.order==="YZX"){const B=o*I,c=o*r,Q=s*I,h=s*r;t[0]=I*g,t[4]=h-B*C,t[8]=Q*C+c,t[1]=C,t[5]=o*g,t[9]=-s*g,t[2]=-r*g,t[6]=c*C+Q,t[10]=B-h*C}else if(A.order==="XZY"){const B=o*I,c=o*r,Q=s*I,h=s*r;t[0]=I*g,t[4]=-C,t[8]=r*g,t[1]=B*C+h,t[5]=o*g,t[9]=c*C-Q,t[2]=Q*C-c,t[6]=s*g,t[10]=h*C+B}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(A){return this.compose(eD,A,iD)}lookAt(A,t,e){const n=this.elements;return ue.subVectors(A,t),ue.lengthSq()===0&&(ue.z=1),ue.normalize(),Oi.crossVectors(e,ue),Oi.lengthSq()===0&&(Math.abs(e.z)===1?ue.x+=1e-4:ue.z+=1e-4,ue.normalize(),Oi.crossVectors(e,ue)),Oi.normalize(),Yo.crossVectors(ue,Oi),n[0]=Oi.x,n[4]=Yo.x,n[8]=ue.x,n[1]=Oi.y,n[5]=Yo.y,n[9]=ue.y,n[2]=Oi.z,n[6]=Yo.z,n[10]=ue.z,this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,t){const e=A.elements,n=t.elements,a=this.elements,o=e[0],s=e[4],I=e[8],r=e[12],g=e[1],C=e[5],B=e[9],c=e[13],Q=e[2],h=e[6],l=e[10],E=e[14],f=e[3],u=e[7],d=e[11],m=e[15],S=n[0],D=n[4],p=n[8],w=n[12],M=n[1],R=n[5],U=n[9],N=n[13],G=n[2],T=n[6],V=n[10],tA=n[14],z=n[3],W=n[7],Y=n[11],CA=n[15];return a[0]=o*S+s*M+I*G+r*z,a[4]=o*D+s*R+I*T+r*W,a[8]=o*p+s*U+I*V+r*Y,a[12]=o*w+s*N+I*tA+r*CA,a[1]=g*S+C*M+B*G+c*z,a[5]=g*D+C*R+B*T+c*W,a[9]=g*p+C*U+B*V+c*Y,a[13]=g*w+C*N+B*tA+c*CA,a[2]=Q*S+h*M+l*G+E*z,a[6]=Q*D+h*R+l*T+E*W,a[10]=Q*p+h*U+l*V+E*Y,a[14]=Q*w+h*N+l*tA+E*CA,a[3]=f*S+u*M+d*G+m*z,a[7]=f*D+u*R+d*T+m*W,a[11]=f*p+u*U+d*V+m*Y,a[15]=f*w+u*N+d*tA+m*CA,this}multiplyScalar(A){const t=this.elements;return t[0]*=A,t[4]*=A,t[8]*=A,t[12]*=A,t[1]*=A,t[5]*=A,t[9]*=A,t[13]*=A,t[2]*=A,t[6]*=A,t[10]*=A,t[14]*=A,t[3]*=A,t[7]*=A,t[11]*=A,t[15]*=A,this}determinant(){const A=this.elements,t=A[0],e=A[4],n=A[8],a=A[12],o=A[1],s=A[5],I=A[9],r=A[13],g=A[2],C=A[6],B=A[10],c=A[14],Q=A[3],h=A[7],l=A[11],E=A[15];return Q*(+a*I*C-n*r*C-a*s*B+e*r*B+n*s*c-e*I*c)+h*(+t*I*c-t*r*B+a*o*B-n*o*c+n*r*g-a*I*g)+l*(+t*r*C-t*s*c-a*o*C+e*o*c+a*s*g-e*r*g)+E*(-n*s*g-t*I*C+t*s*B+n*o*C-e*o*B+e*I*g)}transpose(){const A=this.elements;let t;return t=A[1],A[1]=A[4],A[4]=t,t=A[2],A[2]=A[8],A[8]=t,t=A[6],A[6]=A[9],A[9]=t,t=A[3],A[3]=A[12],A[12]=t,t=A[7],A[7]=A[13],A[13]=t,t=A[11],A[11]=A[14],A[14]=t,this}setPosition(A,t,e){const n=this.elements;return A.isVector3?(n[12]=A.x,n[13]=A.y,n[14]=A.z):(n[12]=A,n[13]=t,n[14]=e),this}invert(){const A=this.elements,t=A[0],e=A[1],n=A[2],a=A[3],o=A[4],s=A[5],I=A[6],r=A[7],g=A[8],C=A[9],B=A[10],c=A[11],Q=A[12],h=A[13],l=A[14],E=A[15],f=C*l*r-h*B*r+h*I*c-s*l*c-C*I*E+s*B*E,u=Q*B*r-g*l*r-Q*I*c+o*l*c+g*I*E-o*B*E,d=g*h*r-Q*C*r+Q*s*c-o*h*c-g*s*E+o*C*E,m=Q*C*I-g*h*I-Q*s*B+o*h*B+g*s*l-o*C*l,S=t*f+e*u+n*d+a*m;if(S===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const D=1/S;return A[0]=f*D,A[1]=(h*B*a-C*l*a-h*n*c+e*l*c+C*n*E-e*B*E)*D,A[2]=(s*l*a-h*I*a+h*n*r-e*l*r-s*n*E+e*I*E)*D,A[3]=(C*I*a-s*B*a-C*n*r+e*B*r+s*n*c-e*I*c)*D,A[4]=u*D,A[5]=(g*l*a-Q*B*a+Q*n*c-t*l*c-g*n*E+t*B*E)*D,A[6]=(Q*I*a-o*l*a-Q*n*r+t*l*r+o*n*E-t*I*E)*D,A[7]=(o*B*a-g*I*a+g*n*r-t*B*r-o*n*c+t*I*c)*D,A[8]=d*D,A[9]=(Q*C*a-g*h*a-Q*e*c+t*h*c+g*e*E-t*C*E)*D,A[10]=(o*h*a-Q*s*a+Q*e*r-t*h*r-o*e*E+t*s*E)*D,A[11]=(g*s*a-o*C*a-g*e*r+t*C*r+o*e*c-t*s*c)*D,A[12]=m*D,A[13]=(g*h*n-Q*C*n+Q*e*B-t*h*B-g*e*l+t*C*l)*D,A[14]=(Q*s*n-o*h*n-Q*e*I+t*h*I+o*e*l-t*s*l)*D,A[15]=(o*C*n-g*s*n+g*e*I-t*C*I-o*e*B+t*s*B)*D,this}scale(A){const t=this.elements,e=A.x,n=A.y,a=A.z;return t[0]*=e,t[4]*=n,t[8]*=a,t[1]*=e,t[5]*=n,t[9]*=a,t[2]*=e,t[6]*=n,t[10]*=a,t[3]*=e,t[7]*=n,t[11]*=a,this}getMaxScaleOnAxis(){const A=this.elements,t=A[0]*A[0]+A[1]*A[1]+A[2]*A[2],e=A[4]*A[4]+A[5]*A[5]+A[6]*A[6],n=A[8]*A[8]+A[9]*A[9]+A[10]*A[10];return Math.sqrt(Math.max(t,e,n))}makeTranslation(A,t,e){return this.set(1,0,0,A,0,1,0,t,0,0,1,e,0,0,0,1),this}makeRotationX(A){const t=Math.cos(A),e=Math.sin(A);return this.set(1,0,0,0,0,t,-e,0,0,e,t,0,0,0,0,1),this}makeRotationY(A){const t=Math.cos(A),e=Math.sin(A);return this.set(t,0,e,0,0,1,0,0,-e,0,t,0,0,0,0,1),this}makeRotationZ(A){const t=Math.cos(A),e=Math.sin(A);return this.set(t,-e,0,0,e,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(A,t){const e=Math.cos(t),n=Math.sin(t),a=1-e,o=A.x,s=A.y,I=A.z,r=a*o,g=a*s;return this.set(r*o+e,r*s-n*I,r*I+n*s,0,r*s+n*I,g*s+e,g*I-n*o,0,r*I-n*s,g*I+n*o,a*I*I+e,0,0,0,0,1),this}makeScale(A,t,e){return this.set(A,0,0,0,0,t,0,0,0,0,e,0,0,0,0,1),this}makeShear(A,t,e,n,a,o){return this.set(1,e,a,0,A,1,o,0,t,n,1,0,0,0,0,1),this}compose(A,t,e){const n=this.elements,a=t._x,o=t._y,s=t._z,I=t._w,r=a+a,g=o+o,C=s+s,B=a*r,c=a*g,Q=a*C,h=o*g,l=o*C,E=s*C,f=I*r,u=I*g,d=I*C,m=e.x,S=e.y,D=e.z;return n[0]=(1-(h+E))*m,n[1]=(c+d)*m,n[2]=(Q-u)*m,n[3]=0,n[4]=(c-d)*S,n[5]=(1-(B+E))*S,n[6]=(l+f)*S,n[7]=0,n[8]=(Q+u)*D,n[9]=(l-f)*D,n[10]=(1-(B+h))*D,n[11]=0,n[12]=A.x,n[13]=A.y,n[14]=A.z,n[15]=1,this}decompose(A,t,e){const n=this.elements;let a=Da.set(n[0],n[1],n[2]).length();const o=Da.set(n[4],n[5],n[6]).length(),s=Da.set(n[8],n[9],n[10]).length();this.determinant()<0&&(a=-a),A.x=n[12],A.y=n[13],A.z=n[14],He.copy(this);const r=1/a,g=1/o,C=1/s;return He.elements[0]*=r,He.elements[1]*=r,He.elements[2]*=r,He.elements[4]*=g,He.elements[5]*=g,He.elements[6]*=g,He.elements[8]*=C,He.elements[9]*=C,He.elements[10]*=C,t.setFromRotationMatrix(He),e.x=a,e.y=o,e.z=s,this}makePerspective(A,t,e,n,a,o){const s=this.elements,I=2*a/(t-A),r=2*a/(e-n),g=(t+A)/(t-A),C=(e+n)/(e-n),B=-(o+a)/(o-a),c=-2*o*a/(o-a);return s[0]=I,s[4]=0,s[8]=g,s[12]=0,s[1]=0,s[5]=r,s[9]=C,s[13]=0,s[2]=0,s[6]=0,s[10]=B,s[14]=c,s[3]=0,s[7]=0,s[11]=-1,s[15]=0,this}makeOrthographic(A,t,e,n,a,o){const s=this.elements,I=1/(t-A),r=1/(e-n),g=1/(o-a),C=(t+A)*I,B=(e+n)*r,c=(o+a)*g;return s[0]=2*I,s[4]=0,s[8]=0,s[12]=-C,s[1]=0,s[5]=2*r,s[9]=0,s[13]=-B,s[2]=0,s[6]=0,s[10]=-2*g,s[14]=-c,s[3]=0,s[7]=0,s[11]=0,s[15]=1,this}equals(A){const t=this.elements,e=A.elements;for(let n=0;n<16;n++)if(t[n]!==e[n])return!1;return!0}fromArray(A,t=0){for(let e=0;e<16;e++)this.elements[e]=A[e+t];return this}toArray(A=[],t=0){const e=this.elements;return A[t]=e[0],A[t+1]=e[1],A[t+2]=e[2],A[t+3]=e[3],A[t+4]=e[4],A[t+5]=e[5],A[t+6]=e[6],A[t+7]=e[7],A[t+8]=e[8],A[t+9]=e[9],A[t+10]=e[10],A[t+11]=e[11],A[t+12]=e[12],A[t+13]=e[13],A[t+14]=e[14],A[t+15]=e[15],A}}const Da=new cA,He=new xt,eD=new cA(0,0,0),iD=new cA(1,1,1),Oi=new cA,Yo=new cA,ue=new cA,TB=new xt,HB=new go;class qr{constructor(A=0,t=0,e=0,n=qr.DEFAULT_ORDER){this.isEuler=!0,this._x=A,this._y=t,this._z=e,this._order=n}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get order(){return this._order}set order(A){this._order=A,this._onChangeCallback()}set(A,t,e,n=this._order){return this._x=A,this._y=t,this._z=e,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(A){return this._x=A._x,this._y=A._y,this._z=A._z,this._order=A._order,this._onChangeCallback(),this}setFromRotationMatrix(A,t=this._order,e=!0){const n=A.elements,a=n[0],o=n[4],s=n[8],I=n[1],r=n[5],g=n[9],C=n[2],B=n[6],c=n[10];switch(t){case"XYZ":this._y=Math.asin(Ce(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-g,c),this._z=Math.atan2(-o,a)):(this._x=Math.atan2(B,r),this._z=0);break;case"YXZ":this._x=Math.asin(-Ce(g,-1,1)),Math.abs(g)<.9999999?(this._y=Math.atan2(s,c),this._z=Math.atan2(I,r)):(this._y=Math.atan2(-C,a),this._z=0);break;case"ZXY":this._x=Math.asin(Ce(B,-1,1)),Math.abs(B)<.9999999?(this._y=Math.atan2(-C,c),this._z=Math.atan2(-o,r)):(this._y=0,this._z=Math.atan2(I,a));break;case"ZYX":this._y=Math.asin(-Ce(C,-1,1)),Math.abs(C)<.9999999?(this._x=Math.atan2(B,c),this._z=Math.atan2(I,a)):(this._x=0,this._z=Math.atan2(-o,r));break;case"YZX":this._z=Math.asin(Ce(I,-1,1)),Math.abs(I)<.9999999?(this._x=Math.atan2(-g,r),this._y=Math.atan2(-C,a)):(this._x=0,this._y=Math.atan2(s,c));break;case"XZY":this._z=Math.asin(-Ce(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(B,r),this._y=Math.atan2(s,a)):(this._x=Math.atan2(-g,c),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,e===!0&&this._onChangeCallback(),this}setFromQuaternion(A,t,e){return TB.makeRotationFromQuaternion(A),this.setFromRotationMatrix(TB,t,e)}setFromVector3(A,t=this._order){return this.set(A.x,A.y,A.z,t)}reorder(A){return HB.setFromEuler(this),this.setFromQuaternion(HB,A)}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._order===this._order}fromArray(A){return this._x=A[0],this._y=A[1],this._z=A[2],A[3]!==void 0&&(this._order=A[3]),this._onChangeCallback(),this}toArray(A=[],t=0){return A[t]=this._x,A[t+1]=this._y,A[t+2]=this._z,A[t+3]=this._order,A}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}qr.DEFAULT_ORDER="XYZ";class EE{constructor(){this.mask=1}set(A){this.mask=(1<<A|0)>>>0}enable(A){this.mask|=1<<A|0}enableAll(){this.mask=-1}toggle(A){this.mask^=1<<A|0}disable(A){this.mask&=~(1<<A|0)}disableAll(){this.mask=0}test(A){return(this.mask&A.mask)!==0}isEnabled(A){return(this.mask&(1<<A|0))!==0}}let nD=0;const qB=new cA,Sa=new go,ui=new xt,Ko=new cA,ms=new cA,aD=new cA,sD=new go,JB=new cA(1,0,0),PB=new cA(0,1,0),YB=new cA(0,0,1),oD={type:"added"},KB={type:"removed"};class De extends rs{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:nD++}),this.uuid=gs(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=De.DEFAULT_UP.clone();const A=new cA,t=new qr,e=new go,n=new cA(1,1,1);function a(){e.setFromEuler(t,!1)}function o(){t.setFromQuaternion(e,void 0,!1)}t._onChange(a),e._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:A},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:e},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new xt},normalMatrix:{value:new re}}),this.matrix=new xt,this.matrixWorld=new xt,this.matrixAutoUpdate=De.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=De.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.layers=new EE,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(A){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(A),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(A){return this.quaternion.premultiply(A),this}setRotationFromAxisAngle(A,t){this.quaternion.setFromAxisAngle(A,t)}setRotationFromEuler(A){this.quaternion.setFromEuler(A,!0)}setRotationFromMatrix(A){this.quaternion.setFromRotationMatrix(A)}setRotationFromQuaternion(A){this.quaternion.copy(A)}rotateOnAxis(A,t){return Sa.setFromAxisAngle(A,t),this.quaternion.multiply(Sa),this}rotateOnWorldAxis(A,t){return Sa.setFromAxisAngle(A,t),this.quaternion.premultiply(Sa),this}rotateX(A){return this.rotateOnAxis(JB,A)}rotateY(A){return this.rotateOnAxis(PB,A)}rotateZ(A){return this.rotateOnAxis(YB,A)}translateOnAxis(A,t){return qB.copy(A).applyQuaternion(this.quaternion),this.position.add(qB.multiplyScalar(t)),this}translateX(A){return this.translateOnAxis(JB,A)}translateY(A){return this.translateOnAxis(PB,A)}translateZ(A){return this.translateOnAxis(YB,A)}localToWorld(A){return this.updateWorldMatrix(!0,!1),A.applyMatrix4(this.matrixWorld)}worldToLocal(A){return this.updateWorldMatrix(!0,!1),A.applyMatrix4(ui.copy(this.matrixWorld).invert())}lookAt(A,t,e){A.isVector3?Ko.copy(A):Ko.set(A,t,e);const n=this.parent;this.updateWorldMatrix(!0,!1),ms.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ui.lookAt(ms,Ko,this.up):ui.lookAt(Ko,ms,this.up),this.quaternion.setFromRotationMatrix(ui),n&&(ui.extractRotation(n.matrixWorld),Sa.setFromRotationMatrix(ui),this.quaternion.premultiply(Sa.invert()))}add(A){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return A===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",A),this):(A&&A.isObject3D?(A.parent!==null&&A.parent.remove(A),A.parent=this,this.children.push(A),A.dispatchEvent(oD)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",A),this)}remove(A){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(A);return t!==-1&&(A.parent=null,this.children.splice(t,1),A.dispatchEvent(KB)),this}removeFromParent(){const A=this.parent;return A!==null&&A.remove(this),this}clear(){for(let A=0;A<this.children.length;A++){const t=this.children[A];t.parent=null,t.dispatchEvent(KB)}return this.children.length=0,this}attach(A){return this.updateWorldMatrix(!0,!1),ui.copy(this.matrixWorld).invert(),A.parent!==null&&(A.parent.updateWorldMatrix(!0,!1),ui.multiply(A.parent.matrixWorld)),A.applyMatrix4(ui),this.add(A),A.updateWorldMatrix(!1,!0),this}getObjectById(A){return this.getObjectByProperty("id",A)}getObjectByName(A){return this.getObjectByProperty("name",A)}getObjectByProperty(A,t){if(this[A]===t)return this;for(let e=0,n=this.children.length;e<n;e++){const o=this.children[e].getObjectByProperty(A,t);if(o!==void 0)return o}}getObjectsByProperty(A,t){let e=[];this[A]===t&&e.push(this);for(let n=0,a=this.children.length;n<a;n++){const o=this.children[n].getObjectsByProperty(A,t);o.length>0&&(e=e.concat(o))}return e}getWorldPosition(A){return this.updateWorldMatrix(!0,!1),A.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ms,A,aD),A}getWorldScale(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ms,sD,A),A}getWorldDirection(A){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return A.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(A){A(this);const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].traverse(A)}traverseVisible(A){if(this.visible===!1)return;A(this);const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].traverseVisible(A)}traverseAncestors(A){const t=this.parent;t!==null&&(A(t),t.traverseAncestors(A))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(A){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||A)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,A=!0);const t=this.children;for(let e=0,n=t.length;e<n;e++){const a=t[e];(a.matrixWorldAutoUpdate===!0||A===!0)&&a.updateMatrixWorld(A)}}updateWorldMatrix(A,t){const e=this.parent;if(A===!0&&e!==null&&e.matrixWorldAutoUpdate===!0&&e.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const n=this.children;for(let a=0,o=n.length;a<o;a++){const s=n[a];s.matrixWorldAutoUpdate===!0&&s.updateWorldMatrix(!1,!0)}}}toJSON(A){const t=A===void 0||typeof A=="string",e={};t&&(A={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},e.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const n={};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.castShadow===!0&&(n.castShadow=!0),this.receiveShadow===!0&&(n.receiveShadow=!0),this.visible===!1&&(n.visible=!1),this.frustumCulled===!1&&(n.frustumCulled=!1),this.renderOrder!==0&&(n.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(n.instanceColor=this.instanceColor.toJSON()));function a(s,I){return s[I.uuid]===void 0&&(s[I.uuid]=I.toJSON(A)),I.uuid}if(this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(A).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(n.environment=this.environment.toJSON(A).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=a(A.geometries,this.geometry);const s=this.geometry.parameters;if(s!==void 0&&s.shapes!==void 0){const I=s.shapes;if(Array.isArray(I))for(let r=0,g=I.length;r<g;r++){const C=I[r];a(A.shapes,C)}else a(A.shapes,I)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(a(A.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const s=[];for(let I=0,r=this.material.length;I<r;I++)s.push(a(A.materials,this.material[I]));n.material=s}else n.material=a(A.materials,this.material);if(this.children.length>0){n.children=[];for(let s=0;s<this.children.length;s++)n.children.push(this.children[s].toJSON(A).object)}if(this.animations.length>0){n.animations=[];for(let s=0;s<this.animations.length;s++){const I=this.animations[s];n.animations.push(a(A.animations,I))}}if(t){const s=o(A.geometries),I=o(A.materials),r=o(A.textures),g=o(A.images),C=o(A.shapes),B=o(A.skeletons),c=o(A.animations),Q=o(A.nodes);s.length>0&&(e.geometries=s),I.length>0&&(e.materials=I),r.length>0&&(e.textures=r),g.length>0&&(e.images=g),C.length>0&&(e.shapes=C),B.length>0&&(e.skeletons=B),c.length>0&&(e.animations=c),Q.length>0&&(e.nodes=Q)}return e.object=n,e;function o(s){const I=[];for(const r in s){const g=s[r];delete g.metadata,I.push(g)}return I}}clone(A){return new this.constructor().copy(this,A)}copy(A,t=!0){if(this.name=A.name,this.up.copy(A.up),this.position.copy(A.position),this.rotation.order=A.rotation.order,this.quaternion.copy(A.quaternion),this.scale.copy(A.scale),this.matrix.copy(A.matrix),this.matrixWorld.copy(A.matrixWorld),this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrixWorldNeedsUpdate=A.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=A.matrixWorldAutoUpdate,this.layers.mask=A.layers.mask,this.visible=A.visible,this.castShadow=A.castShadow,this.receiveShadow=A.receiveShadow,this.frustumCulled=A.frustumCulled,this.renderOrder=A.renderOrder,this.userData=JSON.parse(JSON.stringify(A.userData)),t===!0)for(let e=0;e<A.children.length;e++){const n=A.children[e];this.add(n.clone())}return this}}De.DEFAULT_UP=new cA(0,1,0);De.DEFAULT_MATRIX_AUTO_UPDATE=!0;De.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const qe=new cA,pi=new cA,Kg=new cA,mi=new cA,wa=new cA,_a=new cA,OB=new cA,Og=new cA,Wg=new cA,Vg=new cA;class Fi{constructor(A=new cA,t=new cA,e=new cA){this.a=A,this.b=t,this.c=e}static getNormal(A,t,e,n){n.subVectors(e,t),qe.subVectors(A,t),n.cross(qe);const a=n.lengthSq();return a>0?n.multiplyScalar(1/Math.sqrt(a)):n.set(0,0,0)}static getBarycoord(A,t,e,n,a){qe.subVectors(n,t),pi.subVectors(e,t),Kg.subVectors(A,t);const o=qe.dot(qe),s=qe.dot(pi),I=qe.dot(Kg),r=pi.dot(pi),g=pi.dot(Kg),C=o*r-s*s;if(C===0)return a.set(-2,-1,-1);const B=1/C,c=(r*I-s*g)*B,Q=(o*g-s*I)*B;return a.set(1-c-Q,Q,c)}static containsPoint(A,t,e,n){return this.getBarycoord(A,t,e,n,mi),mi.x>=0&&mi.y>=0&&mi.x+mi.y<=1}static getUV(A,t,e,n,a,o,s,I){return this.getBarycoord(A,t,e,n,mi),I.set(0,0),I.addScaledVector(a,mi.x),I.addScaledVector(o,mi.y),I.addScaledVector(s,mi.z),I}static isFrontFacing(A,t,e,n){return qe.subVectors(e,t),pi.subVectors(A,t),qe.cross(pi).dot(n)<0}set(A,t,e){return this.a.copy(A),this.b.copy(t),this.c.copy(e),this}setFromPointsAndIndices(A,t,e,n){return this.a.copy(A[t]),this.b.copy(A[e]),this.c.copy(A[n]),this}setFromAttributeAndIndices(A,t,e,n){return this.a.fromBufferAttribute(A,t),this.b.fromBufferAttribute(A,e),this.c.fromBufferAttribute(A,n),this}clone(){return new this.constructor().copy(this)}copy(A){return this.a.copy(A.a),this.b.copy(A.b),this.c.copy(A.c),this}getArea(){return qe.subVectors(this.c,this.b),pi.subVectors(this.a,this.b),qe.cross(pi).length()*.5}getMidpoint(A){return A.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(A){return Fi.getNormal(this.a,this.b,this.c,A)}getPlane(A){return A.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(A,t){return Fi.getBarycoord(A,this.a,this.b,this.c,t)}getUV(A,t,e,n,a){return Fi.getUV(A,this.a,this.b,this.c,t,e,n,a)}containsPoint(A){return Fi.containsPoint(A,this.a,this.b,this.c)}isFrontFacing(A){return Fi.isFrontFacing(this.a,this.b,this.c,A)}intersectsBox(A){return A.intersectsTriangle(this)}closestPointToPoint(A,t){const e=this.a,n=this.b,a=this.c;let o,s;wa.subVectors(n,e),_a.subVectors(a,e),Og.subVectors(A,e);const I=wa.dot(Og),r=_a.dot(Og);if(I<=0&&r<=0)return t.copy(e);Wg.subVectors(A,n);const g=wa.dot(Wg),C=_a.dot(Wg);if(g>=0&&C<=g)return t.copy(n);const B=I*C-g*r;if(B<=0&&I>=0&&g<=0)return o=I/(I-g),t.copy(e).addScaledVector(wa,o);Vg.subVectors(A,a);const c=wa.dot(Vg),Q=_a.dot(Vg);if(Q>=0&&c<=Q)return t.copy(a);const h=c*r-I*Q;if(h<=0&&r>=0&&Q<=0)return s=r/(r-Q),t.copy(e).addScaledVector(_a,s);const l=g*Q-c*C;if(l<=0&&C-g>=0&&c-Q>=0)return OB.subVectors(a,n),s=(C-g)/(C-g+(c-Q)),t.copy(n).addScaledVector(OB,s);const E=1/(l+h+B);return o=h*E,s=B*E,t.copy(e).addScaledVector(wa,o).addScaledVector(_a,s)}equals(A){return A.a.equals(this.a)&&A.b.equals(this.b)&&A.c.equals(this.c)}}let rD=0;class Io extends rs{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:rD++}),this.uuid=gs(),this.name="",this.type="Material",this.blending=Oa,this.side=In,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=aE,this.blendDst=sE,this.blendEquation=ka,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=kI,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Ry,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Ng,this.stencilZFail=Ng,this.stencilZPass=Ng,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(A){this._alphaTest>0!=A>0&&this.version++,this._alphaTest=A}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(A){if(A!==void 0)for(const t in A){const e=A[t];if(e===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}const n=this[t];if(n===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}n&&n.isColor?n.set(e):n&&n.isVector3&&e&&e.isVector3?n.copy(e):this[t]=e}}toJSON(A){const t=A===void 0||typeof A=="string";t&&(A={textures:{},images:{}});const e={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),this.color&&this.color.isColor&&(e.color=this.color.getHex()),this.roughness!==void 0&&(e.roughness=this.roughness),this.metalness!==void 0&&(e.metalness=this.metalness),this.sheen!==void 0&&(e.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(e.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(e.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(e.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(e.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(e.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(e.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(e.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(e.shininess=this.shininess),this.clearcoat!==void 0&&(e.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(e.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(e.clearcoatMap=this.clearcoatMap.toJSON(A).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(e.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(A).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(e.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(A).uuid,e.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(e.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(e.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(e.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(e.iridescenceMap=this.iridescenceMap.toJSON(A).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(e.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(A).uuid),this.map&&this.map.isTexture&&(e.map=this.map.toJSON(A).uuid),this.matcap&&this.matcap.isTexture&&(e.matcap=this.matcap.toJSON(A).uuid),this.alphaMap&&this.alphaMap.isTexture&&(e.alphaMap=this.alphaMap.toJSON(A).uuid),this.lightMap&&this.lightMap.isTexture&&(e.lightMap=this.lightMap.toJSON(A).uuid,e.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(e.aoMap=this.aoMap.toJSON(A).uuid,e.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(e.bumpMap=this.bumpMap.toJSON(A).uuid,e.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(e.normalMap=this.normalMap.toJSON(A).uuid,e.normalMapType=this.normalMapType,e.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(e.displacementMap=this.displacementMap.toJSON(A).uuid,e.displacementScale=this.displacementScale,e.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(e.roughnessMap=this.roughnessMap.toJSON(A).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(e.metalnessMap=this.metalnessMap.toJSON(A).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(e.emissiveMap=this.emissiveMap.toJSON(A).uuid),this.specularMap&&this.specularMap.isTexture&&(e.specularMap=this.specularMap.toJSON(A).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(e.specularIntensityMap=this.specularIntensityMap.toJSON(A).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(e.specularColorMap=this.specularColorMap.toJSON(A).uuid),this.envMap&&this.envMap.isTexture&&(e.envMap=this.envMap.toJSON(A).uuid,this.combine!==void 0&&(e.combine=this.combine)),this.envMapIntensity!==void 0&&(e.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(e.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(e.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(e.gradientMap=this.gradientMap.toJSON(A).uuid),this.transmission!==void 0&&(e.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(e.transmissionMap=this.transmissionMap.toJSON(A).uuid),this.thickness!==void 0&&(e.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(e.thicknessMap=this.thicknessMap.toJSON(A).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(e.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(e.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(e.size=this.size),this.shadowSide!==null&&(e.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(e.sizeAttenuation=this.sizeAttenuation),this.blending!==Oa&&(e.blending=this.blending),this.side!==In&&(e.side=this.side),this.vertexColors&&(e.vertexColors=!0),this.opacity<1&&(e.opacity=this.opacity),this.transparent===!0&&(e.transparent=this.transparent),e.depthFunc=this.depthFunc,e.depthTest=this.depthTest,e.depthWrite=this.depthWrite,e.colorWrite=this.colorWrite,e.stencilWrite=this.stencilWrite,e.stencilWriteMask=this.stencilWriteMask,e.stencilFunc=this.stencilFunc,e.stencilRef=this.stencilRef,e.stencilFuncMask=this.stencilFuncMask,e.stencilFail=this.stencilFail,e.stencilZFail=this.stencilZFail,e.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(e.rotation=this.rotation),this.polygonOffset===!0&&(e.polygonOffset=!0),this.polygonOffsetFactor!==0&&(e.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(e.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(e.linewidth=this.linewidth),this.dashSize!==void 0&&(e.dashSize=this.dashSize),this.gapSize!==void 0&&(e.gapSize=this.gapSize),this.scale!==void 0&&(e.scale=this.scale),this.dithering===!0&&(e.dithering=!0),this.alphaTest>0&&(e.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(e.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(e.premultipliedAlpha=this.premultipliedAlpha),this.forceSinglePass===!0&&(e.forceSinglePass=this.forceSinglePass),this.wireframe===!0&&(e.wireframe=this.wireframe),this.wireframeLinewidth>1&&(e.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(e.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(e.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(e.flatShading=this.flatShading),this.visible===!1&&(e.visible=!1),this.toneMapped===!1&&(e.toneMapped=!1),this.fog===!1&&(e.fog=!1),Object.keys(this.userData).length>0&&(e.userData=this.userData);function n(a){const o=[];for(const s in a){const I=a[s];delete I.metadata,o.push(I)}return o}if(t){const a=n(A.textures),o=n(A.images);a.length>0&&(e.textures=a),o.length>0&&(e.images=o)}return e}clone(){return new this.constructor().copy(this)}copy(A){this.name=A.name,this.blending=A.blending,this.side=A.side,this.vertexColors=A.vertexColors,this.opacity=A.opacity,this.transparent=A.transparent,this.blendSrc=A.blendSrc,this.blendDst=A.blendDst,this.blendEquation=A.blendEquation,this.blendSrcAlpha=A.blendSrcAlpha,this.blendDstAlpha=A.blendDstAlpha,this.blendEquationAlpha=A.blendEquationAlpha,this.depthFunc=A.depthFunc,this.depthTest=A.depthTest,this.depthWrite=A.depthWrite,this.stencilWriteMask=A.stencilWriteMask,this.stencilFunc=A.stencilFunc,this.stencilRef=A.stencilRef,this.stencilFuncMask=A.stencilFuncMask,this.stencilFail=A.stencilFail,this.stencilZFail=A.stencilZFail,this.stencilZPass=A.stencilZPass,this.stencilWrite=A.stencilWrite;const t=A.clippingPlanes;let e=null;if(t!==null){const n=t.length;e=new Array(n);for(let a=0;a!==n;++a)e[a]=t[a].clone()}return this.clippingPlanes=e,this.clipIntersection=A.clipIntersection,this.clipShadows=A.clipShadows,this.shadowSide=A.shadowSide,this.colorWrite=A.colorWrite,this.precision=A.precision,this.polygonOffset=A.polygonOffset,this.polygonOffsetFactor=A.polygonOffsetFactor,this.polygonOffsetUnits=A.polygonOffsetUnits,this.dithering=A.dithering,this.alphaTest=A.alphaTest,this.alphaToCoverage=A.alphaToCoverage,this.premultipliedAlpha=A.premultipliedAlpha,this.forceSinglePass=A.forceSinglePass,this.visible=A.visible,this.toneMapped=A.toneMapped,this.userData=JSON.parse(JSON.stringify(A.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(A){A===!0&&this.version++}}const QE={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Je={h:0,s:0,l:0},Oo={h:0,s:0,l:0};function zg(i,A,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?i+(A-i)*6*t:t<1/2?A:t<2/3?i+(A-i)*6*(2/3-t):i}class It{constructor(A,t,e){return this.isColor=!0,this.r=1,this.g=1,this.b=1,t===void 0&&e===void 0?this.set(A):this.setRGB(A,t,e)}set(A){return A&&A.isColor?this.copy(A):typeof A=="number"?this.setHex(A):typeof A=="string"&&this.setStyle(A),this}setScalar(A){return this.r=A,this.g=A,this.b=A,this}setHex(A,t=$e){return A=Math.floor(A),this.r=(A>>16&255)/255,this.g=(A>>8&255)/255,this.b=(A&255)/255,ee.toWorkingColorSpace(this,t),this}setRGB(A,t,e,n=ee.workingColorSpace){return this.r=A,this.g=t,this.b=e,ee.toWorkingColorSpace(this,n),this}setHSL(A,t,e,n=ee.workingColorSpace){if(A=yl(A,1),t=Ce(t,0,1),e=Ce(e,0,1),t===0)this.r=this.g=this.b=e;else{const a=e<=.5?e*(1+t):e+t-e*t,o=2*e-a;this.r=zg(o,a,A+1/3),this.g=zg(o,a,A),this.b=zg(o,a,A-1/3)}return ee.toWorkingColorSpace(this,n),this}setStyle(A,t=$e){function e(a){a!==void 0&&parseFloat(a)<1&&console.warn("THREE.Color: Alpha component of "+A+" will be ignored.")}let n;if(n=/^(\w+)\(([^\)]*)\)/.exec(A)){let a;const o=n[1],s=n[2];switch(o){case"rgb":case"rgba":if(a=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(255,parseInt(a[1],10))/255,this.g=Math.min(255,parseInt(a[2],10))/255,this.b=Math.min(255,parseInt(a[3],10))/255,ee.toWorkingColorSpace(this,t),e(a[4]),this;if(a=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(100,parseInt(a[1],10))/100,this.g=Math.min(100,parseInt(a[2],10))/100,this.b=Math.min(100,parseInt(a[3],10))/100,ee.toWorkingColorSpace(this,t),e(a[4]),this;break;case"hsl":case"hsla":if(a=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)){const I=parseFloat(a[1])/360,r=parseFloat(a[2])/100,g=parseFloat(a[3])/100;return e(a[4]),this.setHSL(I,r,g,t)}break;default:console.warn("THREE.Color: Unknown color model "+A)}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(A)){const a=n[1],o=a.length;if(o===3)return this.r=parseInt(a.charAt(0)+a.charAt(0),16)/255,this.g=parseInt(a.charAt(1)+a.charAt(1),16)/255,this.b=parseInt(a.charAt(2)+a.charAt(2),16)/255,ee.toWorkingColorSpace(this,t),this;if(o===6)return this.r=parseInt(a.charAt(0)+a.charAt(1),16)/255,this.g=parseInt(a.charAt(2)+a.charAt(3),16)/255,this.b=parseInt(a.charAt(4)+a.charAt(5),16)/255,ee.toWorkingColorSpace(this,t),this;console.warn("THREE.Color: Invalid hex color "+A)}else if(A&&A.length>0)return this.setColorName(A,t);return this}setColorName(A,t=$e){const e=QE[A.toLowerCase()];return e!==void 0?this.setHex(e,t):console.warn("THREE.Color: Unknown color "+A),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(A){return this.r=A.r,this.g=A.g,this.b=A.b,this}copySRGBToLinear(A){return this.r=Va(A.r),this.g=Va(A.g),this.b=Va(A.b),this}copyLinearToSRGB(A){return this.r=Ug(A.r),this.g=Ug(A.g),this.b=Ug(A.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(A=$e){return ee.fromWorkingColorSpace(jt.copy(this),A),Ce(jt.r*255,0,255)<<16^Ce(jt.g*255,0,255)<<8^Ce(jt.b*255,0,255)<<0}getHexString(A=$e){return("000000"+this.getHex(A).toString(16)).slice(-6)}getHSL(A,t=ee.workingColorSpace){ee.fromWorkingColorSpace(jt.copy(this),t);const e=jt.r,n=jt.g,a=jt.b,o=Math.max(e,n,a),s=Math.min(e,n,a);let I,r;const g=(s+o)/2;if(s===o)I=0,r=0;else{const C=o-s;switch(r=g<=.5?C/(o+s):C/(2-o-s),o){case e:I=(n-a)/C+(n<a?6:0);break;case n:I=(a-e)/C+2;break;case a:I=(e-n)/C+4;break}I/=6}return A.h=I,A.s=r,A.l=g,A}getRGB(A,t=ee.workingColorSpace){return ee.fromWorkingColorSpace(jt.copy(this),t),A.r=jt.r,A.g=jt.g,A.b=jt.b,A}getStyle(A=$e){ee.fromWorkingColorSpace(jt.copy(this),A);const t=jt.r,e=jt.g,n=jt.b;return A!==$e?`color(${A} ${t.toFixed(3)} ${e.toFixed(3)} ${n.toFixed(3)})`:`rgb(${t*255|0},${e*255|0},${n*255|0})`}offsetHSL(A,t,e){return this.getHSL(Je),Je.h+=A,Je.s+=t,Je.l+=e,this.setHSL(Je.h,Je.s,Je.l),this}add(A){return this.r+=A.r,this.g+=A.g,this.b+=A.b,this}addColors(A,t){return this.r=A.r+t.r,this.g=A.g+t.g,this.b=A.b+t.b,this}addScalar(A){return this.r+=A,this.g+=A,this.b+=A,this}sub(A){return this.r=Math.max(0,this.r-A.r),this.g=Math.max(0,this.g-A.g),this.b=Math.max(0,this.b-A.b),this}multiply(A){return this.r*=A.r,this.g*=A.g,this.b*=A.b,this}multiplyScalar(A){return this.r*=A,this.g*=A,this.b*=A,this}lerp(A,t){return this.r+=(A.r-this.r)*t,this.g+=(A.g-this.g)*t,this.b+=(A.b-this.b)*t,this}lerpColors(A,t,e){return this.r=A.r+(t.r-A.r)*e,this.g=A.g+(t.g-A.g)*e,this.b=A.b+(t.b-A.b)*e,this}lerpHSL(A,t){this.getHSL(Je),A.getHSL(Oo);const e=qs(Je.h,Oo.h,t),n=qs(Je.s,Oo.s,t),a=qs(Je.l,Oo.l,t);return this.setHSL(e,n,a),this}equals(A){return A.r===this.r&&A.g===this.g&&A.b===this.b}fromArray(A,t=0){return this.r=A[t],this.g=A[t+1],this.b=A[t+2],this}toArray(A=[],t=0){return A[t]=this.r,A[t+1]=this.g,A[t+2]=this.b,A}fromBufferAttribute(A,t){return this.r=A.getX(t),this.g=A.getY(t),this.b=A.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const jt=new It;It.NAMES=QE;class Sl extends Io{constructor(A){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new It(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ml,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.specularMap=A.specularMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.combine=A.combine,this.reflectivity=A.reflectivity,this.refractionRatio=A.refractionRatio,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.fog=A.fog,this}}const St=new cA,Wo=new Bt;class We{constructor(A,t,e=!1){if(Array.isArray(A))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=A,this.itemSize=t,this.count=A!==void 0?A.length/t:0,this.normalized=e,this.usage=LB,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(A){A===!0&&this.version++}setUsage(A){return this.usage=A,this}copy(A){return this.name=A.name,this.array=new A.array.constructor(A.array),this.itemSize=A.itemSize,this.count=A.count,this.normalized=A.normalized,this.usage=A.usage,this}copyAt(A,t,e){A*=this.itemSize,e*=t.itemSize;for(let n=0,a=this.itemSize;n<a;n++)this.array[A+n]=t.array[e+n];return this}copyArray(A){return this.array.set(A),this}applyMatrix3(A){if(this.itemSize===2)for(let t=0,e=this.count;t<e;t++)Wo.fromBufferAttribute(this,t),Wo.applyMatrix3(A),this.setXY(t,Wo.x,Wo.y);else if(this.itemSize===3)for(let t=0,e=this.count;t<e;t++)St.fromBufferAttribute(this,t),St.applyMatrix3(A),this.setXYZ(t,St.x,St.y,St.z);return this}applyMatrix4(A){for(let t=0,e=this.count;t<e;t++)St.fromBufferAttribute(this,t),St.applyMatrix4(A),this.setXYZ(t,St.x,St.y,St.z);return this}applyNormalMatrix(A){for(let t=0,e=this.count;t<e;t++)St.fromBufferAttribute(this,t),St.applyNormalMatrix(A),this.setXYZ(t,St.x,St.y,St.z);return this}transformDirection(A){for(let t=0,e=this.count;t<e;t++)St.fromBufferAttribute(this,t),St.transformDirection(A),this.setXYZ(t,St.x,St.y,St.z);return this}set(A,t=0){return this.array.set(A,t),this}getX(A){let t=this.array[A*this.itemSize];return this.normalized&&(t=Ns(t,this.array)),t}setX(A,t){return this.normalized&&(t=ge(t,this.array)),this.array[A*this.itemSize]=t,this}getY(A){let t=this.array[A*this.itemSize+1];return this.normalized&&(t=Ns(t,this.array)),t}setY(A,t){return this.normalized&&(t=ge(t,this.array)),this.array[A*this.itemSize+1]=t,this}getZ(A){let t=this.array[A*this.itemSize+2];return this.normalized&&(t=Ns(t,this.array)),t}setZ(A,t){return this.normalized&&(t=ge(t,this.array)),this.array[A*this.itemSize+2]=t,this}getW(A){let t=this.array[A*this.itemSize+3];return this.normalized&&(t=Ns(t,this.array)),t}setW(A,t){return this.normalized&&(t=ge(t,this.array)),this.array[A*this.itemSize+3]=t,this}setXY(A,t,e){return A*=this.itemSize,this.normalized&&(t=ge(t,this.array),e=ge(e,this.array)),this.array[A+0]=t,this.array[A+1]=e,this}setXYZ(A,t,e,n){return A*=this.itemSize,this.normalized&&(t=ge(t,this.array),e=ge(e,this.array),n=ge(n,this.array)),this.array[A+0]=t,this.array[A+1]=e,this.array[A+2]=n,this}setXYZW(A,t,e,n,a){return A*=this.itemSize,this.normalized&&(t=ge(t,this.array),e=ge(e,this.array),n=ge(n,this.array),a=ge(a,this.array)),this.array[A+0]=t,this.array[A+1]=e,this.array[A+2]=n,this.array[A+3]=a,this}onUpload(A){return this.onUploadCallback=A,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const A={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(A.name=this.name),this.usage!==LB&&(A.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(A.updateRange=this.updateRange),A}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}class dE extends We{constructor(A,t,e){super(new Uint16Array(A),t,e)}}class fE extends We{constructor(A,t,e){super(new Uint32Array(A),t,e)}}class gi extends We{constructor(A,t,e){super(new Float32Array(A),t,e)}}let gD=0;const xe=new xt,Xg=new De,xa=new cA,pe=new Is,ys=new Is,kt=new cA;class Bn extends rs{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:gD++}),this.uuid=gs(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(A){return Array.isArray(A)?this.index=new(CE(A)?fE:dE)(A,1):this.index=A,this}getAttribute(A){return this.attributes[A]}setAttribute(A,t){return this.attributes[A]=t,this}deleteAttribute(A){return delete this.attributes[A],this}hasAttribute(A){return this.attributes[A]!==void 0}addGroup(A,t,e=0){this.groups.push({start:A,count:t,materialIndex:e})}clearGroups(){this.groups=[]}setDrawRange(A,t){this.drawRange.start=A,this.drawRange.count=t}applyMatrix4(A){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(A),t.needsUpdate=!0);const e=this.attributes.normal;if(e!==void 0){const a=new re().getNormalMatrix(A);e.applyNormalMatrix(a),e.needsUpdate=!0}const n=this.attributes.tangent;return n!==void 0&&(n.transformDirection(A),n.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(A){return xe.makeRotationFromQuaternion(A),this.applyMatrix4(xe),this}rotateX(A){return xe.makeRotationX(A),this.applyMatrix4(xe),this}rotateY(A){return xe.makeRotationY(A),this.applyMatrix4(xe),this}rotateZ(A){return xe.makeRotationZ(A),this.applyMatrix4(xe),this}translate(A,t,e){return xe.makeTranslation(A,t,e),this.applyMatrix4(xe),this}scale(A,t,e){return xe.makeScale(A,t,e),this.applyMatrix4(xe),this}lookAt(A){return Xg.lookAt(A),Xg.updateMatrix(),this.applyMatrix4(Xg.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(xa).negate(),this.translate(xa.x,xa.y,xa.z),this}setFromPoints(A){const t=[];for(let e=0,n=A.length;e<n;e++){const a=A[e];t.push(a.x,a.y,a.z||0)}return this.setAttribute("position",new gi(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Is);const A=this.attributes.position,t=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new cA(-1/0,-1/0,-1/0),new cA(1/0,1/0,1/0));return}if(A!==void 0){if(this.boundingBox.setFromBufferAttribute(A),t)for(let e=0,n=t.length;e<n;e++){const a=t[e];pe.setFromBufferAttribute(a),this.morphTargetsRelative?(kt.addVectors(this.boundingBox.min,pe.min),this.boundingBox.expandByPoint(kt),kt.addVectors(this.boundingBox.max,pe.max),this.boundingBox.expandByPoint(kt)):(this.boundingBox.expandByPoint(pe.min),this.boundingBox.expandByPoint(pe.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Dl);const A=this.attributes.position,t=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new cA,1/0);return}if(A){const e=this.boundingSphere.center;if(pe.setFromBufferAttribute(A),t)for(let a=0,o=t.length;a<o;a++){const s=t[a];ys.setFromBufferAttribute(s),this.morphTargetsRelative?(kt.addVectors(pe.min,ys.min),pe.expandByPoint(kt),kt.addVectors(pe.max,ys.max),pe.expandByPoint(kt)):(pe.expandByPoint(ys.min),pe.expandByPoint(ys.max))}pe.getCenter(e);let n=0;for(let a=0,o=A.count;a<o;a++)kt.fromBufferAttribute(A,a),n=Math.max(n,e.distanceToSquared(kt));if(t)for(let a=0,o=t.length;a<o;a++){const s=t[a],I=this.morphTargetsRelative;for(let r=0,g=s.count;r<g;r++)kt.fromBufferAttribute(s,r),I&&(xa.fromBufferAttribute(A,r),kt.add(xa)),n=Math.max(n,e.distanceToSquared(kt))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const A=this.index,t=this.attributes;if(A===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const e=A.array,n=t.position.array,a=t.normal.array,o=t.uv.array,s=n.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new We(new Float32Array(4*s),4));const I=this.getAttribute("tangent").array,r=[],g=[];for(let M=0;M<s;M++)r[M]=new cA,g[M]=new cA;const C=new cA,B=new cA,c=new cA,Q=new Bt,h=new Bt,l=new Bt,E=new cA,f=new cA;function u(M,R,U){C.fromArray(n,M*3),B.fromArray(n,R*3),c.fromArray(n,U*3),Q.fromArray(o,M*2),h.fromArray(o,R*2),l.fromArray(o,U*2),B.sub(C),c.sub(C),h.sub(Q),l.sub(Q);const N=1/(h.x*l.y-l.x*h.y);!isFinite(N)||(E.copy(B).multiplyScalar(l.y).addScaledVector(c,-h.y).multiplyScalar(N),f.copy(c).multiplyScalar(h.x).addScaledVector(B,-l.x).multiplyScalar(N),r[M].add(E),r[R].add(E),r[U].add(E),g[M].add(f),g[R].add(f),g[U].add(f))}let d=this.groups;d.length===0&&(d=[{start:0,count:e.length}]);for(let M=0,R=d.length;M<R;++M){const U=d[M],N=U.start,G=U.count;for(let T=N,V=N+G;T<V;T+=3)u(e[T+0],e[T+1],e[T+2])}const m=new cA,S=new cA,D=new cA,p=new cA;function w(M){D.fromArray(a,M*3),p.copy(D);const R=r[M];m.copy(R),m.sub(D.multiplyScalar(D.dot(R))).normalize(),S.crossVectors(p,R);const N=S.dot(g[M])<0?-1:1;I[M*4]=m.x,I[M*4+1]=m.y,I[M*4+2]=m.z,I[M*4+3]=N}for(let M=0,R=d.length;M<R;++M){const U=d[M],N=U.start,G=U.count;for(let T=N,V=N+G;T<V;T+=3)w(e[T+0]),w(e[T+1]),w(e[T+2])}}computeVertexNormals(){const A=this.index,t=this.getAttribute("position");if(t!==void 0){let e=this.getAttribute("normal");if(e===void 0)e=new We(new Float32Array(t.count*3),3),this.setAttribute("normal",e);else for(let B=0,c=e.count;B<c;B++)e.setXYZ(B,0,0,0);const n=new cA,a=new cA,o=new cA,s=new cA,I=new cA,r=new cA,g=new cA,C=new cA;if(A)for(let B=0,c=A.count;B<c;B+=3){const Q=A.getX(B+0),h=A.getX(B+1),l=A.getX(B+2);n.fromBufferAttribute(t,Q),a.fromBufferAttribute(t,h),o.fromBufferAttribute(t,l),g.subVectors(o,a),C.subVectors(n,a),g.cross(C),s.fromBufferAttribute(e,Q),I.fromBufferAttribute(e,h),r.fromBufferAttribute(e,l),s.add(g),I.add(g),r.add(g),e.setXYZ(Q,s.x,s.y,s.z),e.setXYZ(h,I.x,I.y,I.z),e.setXYZ(l,r.x,r.y,r.z)}else for(let B=0,c=t.count;B<c;B+=3)n.fromBufferAttribute(t,B+0),a.fromBufferAttribute(t,B+1),o.fromBufferAttribute(t,B+2),g.subVectors(o,a),C.subVectors(n,a),g.cross(C),e.setXYZ(B+0,g.x,g.y,g.z),e.setXYZ(B+1,g.x,g.y,g.z),e.setXYZ(B+2,g.x,g.y,g.z);this.normalizeNormals(),e.needsUpdate=!0}}merge(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),this}normalizeNormals(){const A=this.attributes.normal;for(let t=0,e=A.count;t<e;t++)kt.fromBufferAttribute(A,t),kt.normalize(),A.setXYZ(t,kt.x,kt.y,kt.z)}toNonIndexed(){function A(s,I){const r=s.array,g=s.itemSize,C=s.normalized,B=new r.constructor(I.length*g);let c=0,Q=0;for(let h=0,l=I.length;h<l;h++){s.isInterleavedBufferAttribute?c=I[h]*s.data.stride+s.offset:c=I[h]*g;for(let E=0;E<g;E++)B[Q++]=r[c++]}return new We(B,g,C)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Bn,e=this.index.array,n=this.attributes;for(const s in n){const I=n[s],r=A(I,e);t.setAttribute(s,r)}const a=this.morphAttributes;for(const s in a){const I=[],r=a[s];for(let g=0,C=r.length;g<C;g++){const B=r[g],c=A(B,e);I.push(c)}t.morphAttributes[s]=I}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let s=0,I=o.length;s<I;s++){const r=o[s];t.addGroup(r.start,r.count,r.materialIndex)}return t}toJSON(){const A={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(A.uuid=this.uuid,A.type=this.type,this.name!==""&&(A.name=this.name),Object.keys(this.userData).length>0&&(A.userData=this.userData),this.parameters!==void 0){const I=this.parameters;for(const r in I)I[r]!==void 0&&(A[r]=I[r]);return A}A.data={attributes:{}};const t=this.index;t!==null&&(A.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const e=this.attributes;for(const I in e){const r=e[I];A.data.attributes[I]=r.toJSON(A.data)}const n={};let a=!1;for(const I in this.morphAttributes){const r=this.morphAttributes[I],g=[];for(let C=0,B=r.length;C<B;C++){const c=r[C];g.push(c.toJSON(A.data))}g.length>0&&(n[I]=g,a=!0)}a&&(A.data.morphAttributes=n,A.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(A.data.groups=JSON.parse(JSON.stringify(o)));const s=this.boundingSphere;return s!==null&&(A.data.boundingSphere={center:s.center.toArray(),radius:s.radius}),A}clone(){return new this.constructor().copy(this)}copy(A){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=A.name;const e=A.index;e!==null&&this.setIndex(e.clone(t));const n=A.attributes;for(const r in n){const g=n[r];this.setAttribute(r,g.clone(t))}const a=A.morphAttributes;for(const r in a){const g=[],C=a[r];for(let B=0,c=C.length;B<c;B++)g.push(C[B].clone(t));this.morphAttributes[r]=g}this.morphTargetsRelative=A.morphTargetsRelative;const o=A.groups;for(let r=0,g=o.length;r<g;r++){const C=o[r];this.addGroup(C.start,C.count,C.materialIndex)}const s=A.boundingBox;s!==null&&(this.boundingBox=s.clone());const I=A.boundingSphere;return I!==null&&(this.boundingSphere=I.clone()),this.drawRange.start=A.drawRange.start,this.drawRange.count=A.drawRange.count,this.userData=A.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const WB=new xt,ze=new tD,Vo=new Dl,VB=new cA,Ds=new cA,Ss=new cA,ws=new cA,Zg=new cA,zo=new cA,Xo=new Bt,Zo=new Bt,jo=new Bt,jg=new cA,$o=new cA;class Oe extends De{constructor(A=new Bn,t=new Sl){super(),this.isMesh=!0,this.type="Mesh",this.geometry=A,this.material=t,this.updateMorphTargets()}copy(A,t){return super.copy(A,t),A.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=A.morphTargetInfluences.slice()),A.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},A.morphTargetDictionary)),this.material=A.material,this.geometry=A.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let a=0,o=n.length;a<o;a++){const s=n[a].name||String(a);this.morphTargetInfluences.push(0),this.morphTargetDictionary[s]=a}}}}getVertexPosition(A,t){const e=this.geometry,n=e.attributes.position,a=e.morphAttributes.position,o=e.morphTargetsRelative;t.fromBufferAttribute(n,A);const s=this.morphTargetInfluences;if(a&&s){zo.set(0,0,0);for(let I=0,r=a.length;I<r;I++){const g=s[I],C=a[I];g!==0&&(Zg.fromBufferAttribute(C,A),o?zo.addScaledVector(Zg,g):zo.addScaledVector(Zg.sub(t),g))}t.add(zo)}return this.isSkinnedMesh&&this.boneTransform(A,t),t}raycast(A,t){const e=this.geometry,n=this.material,a=this.matrixWorld;if(n===void 0||(e.boundingSphere===null&&e.computeBoundingSphere(),Vo.copy(e.boundingSphere),Vo.applyMatrix4(a),ze.copy(A.ray).recast(A.near),Vo.containsPoint(ze.origin)===!1&&(ze.intersectSphere(Vo,VB)===null||ze.origin.distanceToSquared(VB)>(A.far-A.near)**2))||(WB.copy(a).invert(),ze.copy(A.ray).applyMatrix4(WB),e.boundingBox!==null&&ze.intersectsBox(e.boundingBox)===!1))return;let o;const s=e.index,I=e.attributes.position,r=e.attributes.uv,g=e.attributes.uv2,C=e.groups,B=e.drawRange;if(s!==null)if(Array.isArray(n))for(let c=0,Q=C.length;c<Q;c++){const h=C[c],l=n[h.materialIndex],E=Math.max(h.start,B.start),f=Math.min(s.count,Math.min(h.start+h.count,B.start+B.count));for(let u=E,d=f;u<d;u+=3){const m=s.getX(u),S=s.getX(u+1),D=s.getX(u+2);o=Ar(this,l,A,ze,r,g,m,S,D),o&&(o.faceIndex=Math.floor(u/3),o.face.materialIndex=h.materialIndex,t.push(o))}}else{const c=Math.max(0,B.start),Q=Math.min(s.count,B.start+B.count);for(let h=c,l=Q;h<l;h+=3){const E=s.getX(h),f=s.getX(h+1),u=s.getX(h+2);o=Ar(this,n,A,ze,r,g,E,f,u),o&&(o.faceIndex=Math.floor(h/3),t.push(o))}}else if(I!==void 0)if(Array.isArray(n))for(let c=0,Q=C.length;c<Q;c++){const h=C[c],l=n[h.materialIndex],E=Math.max(h.start,B.start),f=Math.min(I.count,Math.min(h.start+h.count,B.start+B.count));for(let u=E,d=f;u<d;u+=3){const m=u,S=u+1,D=u+2;o=Ar(this,l,A,ze,r,g,m,S,D),o&&(o.faceIndex=Math.floor(u/3),o.face.materialIndex=h.materialIndex,t.push(o))}}else{const c=Math.max(0,B.start),Q=Math.min(I.count,B.start+B.count);for(let h=c,l=Q;h<l;h+=3){const E=h,f=h+1,u=h+2;o=Ar(this,n,A,ze,r,g,E,f,u),o&&(o.faceIndex=Math.floor(h/3),t.push(o))}}}}function ID(i,A,t,e,n,a,o,s){let I;if(A.side===ce?I=e.intersectTriangle(o,a,n,!0,s):I=e.intersectTriangle(n,a,o,A.side===In,s),I===null)return null;$o.copy(s),$o.applyMatrix4(i.matrixWorld);const r=t.ray.origin.distanceTo($o);return r<t.near||r>t.far?null:{distance:r,point:$o.clone(),object:i}}function Ar(i,A,t,e,n,a,o,s,I){i.getVertexPosition(o,Ds),i.getVertexPosition(s,Ss),i.getVertexPosition(I,ws);const r=ID(i,A,t,e,Ds,Ss,ws,jg);if(r){n&&(Xo.fromBufferAttribute(n,o),Zo.fromBufferAttribute(n,s),jo.fromBufferAttribute(n,I),r.uv=Fi.getUV(jg,Ds,Ss,ws,Xo,Zo,jo,new Bt)),a&&(Xo.fromBufferAttribute(a,o),Zo.fromBufferAttribute(a,s),jo.fromBufferAttribute(a,I),r.uv2=Fi.getUV(jg,Ds,Ss,ws,Xo,Zo,jo,new Bt));const g={a:o,b:s,c:I,normal:new cA,materialIndex:0};Fi.getNormal(Ds,Ss,ws,g.normal),r.face=g}return r}class ls extends Bn{constructor(A=1,t=1,e=1,n=1,a=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:A,height:t,depth:e,widthSegments:n,heightSegments:a,depthSegments:o};const s=this;n=Math.floor(n),a=Math.floor(a),o=Math.floor(o);const I=[],r=[],g=[],C=[];let B=0,c=0;Q("z","y","x",-1,-1,e,t,A,o,a,0),Q("z","y","x",1,-1,e,t,-A,o,a,1),Q("x","z","y",1,1,A,e,t,n,o,2),Q("x","z","y",1,-1,A,e,-t,n,o,3),Q("x","y","z",1,-1,A,t,e,n,a,4),Q("x","y","z",-1,-1,A,t,-e,n,a,5),this.setIndex(I),this.setAttribute("position",new gi(r,3)),this.setAttribute("normal",new gi(g,3)),this.setAttribute("uv",new gi(C,2));function Q(h,l,E,f,u,d,m,S,D,p,w){const M=d/D,R=m/p,U=d/2,N=m/2,G=S/2,T=D+1,V=p+1;let tA=0,z=0;const W=new cA;for(let Y=0;Y<V;Y++){const CA=Y*R-N;for(let K=0;K<T;K++){const AA=K*M-U;W[h]=AA*f,W[l]=CA*u,W[E]=G,r.push(W.x,W.y,W.z),W[h]=0,W[l]=0,W[E]=S>0?1:-1,g.push(W.x,W.y,W.z),C.push(K/D),C.push(1-Y/p),tA+=1}}for(let Y=0;Y<p;Y++)for(let CA=0;CA<D;CA++){const K=B+CA+T*Y,AA=B+CA+T*(Y+1),lA=B+(CA+1)+T*(Y+1),Z=B+(CA+1)+T*Y;I.push(K,AA,Z),I.push(AA,lA,Z),z+=6}s.addGroup(c,z,w),c+=z,B+=tA}}copy(A){return super.copy(A),this.parameters=Object.assign({},A.parameters),this}static fromJSON(A){return new ls(A.width,A.height,A.depth,A.widthSegments,A.heightSegments,A.depthSegments)}}function as(i){const A={};for(const t in i){A[t]={};for(const e in i[t]){const n=i[t][e];n&&(n.isColor||n.isMatrix3||n.isMatrix4||n.isVector2||n.isVector3||n.isVector4||n.isTexture||n.isQuaternion)?A[t][e]=n.clone():Array.isArray(n)?A[t][e]=n.slice():A[t][e]=n}}return A}function ie(i){const A={};for(let t=0;t<i.length;t++){const e=as(i[t]);for(const n in e)A[n]=e[n]}return A}function lD(i){const A=[];for(let t=0;t<i.length;t++)A.push(i[t].clone());return A}function uE(i){return i.getRenderTarget()===null&&i.outputEncoding===ht?$e:zs}const CD={clone:as,merge:ie};var BD=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,hD=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Wn extends Io{constructor(A){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=BD,this.fragmentShader=hD,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,A!==void 0&&this.setValues(A)}copy(A){return super.copy(A),this.fragmentShader=A.fragmentShader,this.vertexShader=A.vertexShader,this.uniforms=as(A.uniforms),this.uniformsGroups=lD(A.uniformsGroups),this.defines=Object.assign({},A.defines),this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.fog=A.fog,this.lights=A.lights,this.clipping=A.clipping,this.extensions=Object.assign({},A.extensions),this.glslVersion=A.glslVersion,this}toJSON(A){const t=super.toJSON(A);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const o=this.uniforms[n].value;o&&o.isTexture?t.uniforms[n]={type:"t",value:o.toJSON(A).uuid}:o&&o.isColor?t.uniforms[n]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[n]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[n]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[n]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[n]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[n]={type:"m4",value:o.toArray()}:t.uniforms[n]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const e={};for(const n in this.extensions)this.extensions[n]===!0&&(e[n]=!0);return Object.keys(e).length>0&&(t.extensions=e),t}}class pE extends De{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new xt,this.projectionMatrix=new xt,this.projectionMatrixInverse=new xt}copy(A,t){return super.copy(A,t),this.matrixWorldInverse.copy(A.matrixWorldInverse),this.projectionMatrix.copy(A.projectionMatrix),this.projectionMatrixInverse.copy(A.projectionMatrixInverse),this}getWorldDirection(A){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return A.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(A){super.updateMatrixWorld(A),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(A,t){super.updateWorldMatrix(A,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class Ye extends pE{constructor(A=50,t=1,e=.1,n=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=A,this.zoom=1,this.near=e,this.far=n,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(A,t){return super.copy(A,t),this.fov=A.fov,this.zoom=A.zoom,this.near=A.near,this.far=A.far,this.focus=A.focus,this.aspect=A.aspect,this.view=A.view===null?null:Object.assign({},A.view),this.filmGauge=A.filmGauge,this.filmOffset=A.filmOffset,this}setFocalLength(A){const t=.5*this.getFilmHeight()/A;this.fov=Sr*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const A=Math.tan(Hs*.5*this.fov);return .5*this.getFilmHeight()/A}getEffectiveFOV(){return Sr*2*Math.atan(Math.tan(Hs*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(A,t,e,n,a,o){this.aspect=A/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=A,this.view.fullHeight=t,this.view.offsetX=e,this.view.offsetY=n,this.view.width=a,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const A=this.near;let t=A*Math.tan(Hs*.5*this.fov)/this.zoom,e=2*t,n=this.aspect*e,a=-.5*n;const o=this.view;if(this.view!==null&&this.view.enabled){const I=o.fullWidth,r=o.fullHeight;a+=o.offsetX*n/I,t-=o.offsetY*e/r,n*=o.width/I,e*=o.height/r}const s=this.filmOffset;s!==0&&(a+=A*s/this.getFilmWidth()),this.projectionMatrix.makePerspective(a,a+n,t,t-e,A,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(A){const t=super.toJSON(A);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Ma=-90,Fa=1;class cD extends De{constructor(A,t,e){super(),this.type="CubeCamera",this.renderTarget=e;const n=new Ye(Ma,Fa,A,t);n.layers=this.layers,n.up.set(0,1,0),n.lookAt(1,0,0),this.add(n);const a=new Ye(Ma,Fa,A,t);a.layers=this.layers,a.up.set(0,1,0),a.lookAt(-1,0,0),this.add(a);const o=new Ye(Ma,Fa,A,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(0,1,0),this.add(o);const s=new Ye(Ma,Fa,A,t);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(0,-1,0),this.add(s);const I=new Ye(Ma,Fa,A,t);I.layers=this.layers,I.up.set(0,1,0),I.lookAt(0,0,1),this.add(I);const r=new Ye(Ma,Fa,A,t);r.layers=this.layers,r.up.set(0,1,0),r.lookAt(0,0,-1),this.add(r)}update(A,t){this.parent===null&&this.updateMatrixWorld();const e=this.renderTarget,[n,a,o,s,I,r]=this.children,g=A.getRenderTarget(),C=A.toneMapping,B=A.xr.enabled;A.toneMapping=Ni,A.xr.enabled=!1;const c=e.texture.generateMipmaps;e.texture.generateMipmaps=!1,A.setRenderTarget(e,0),A.render(t,n),A.setRenderTarget(e,1),A.render(t,a),A.setRenderTarget(e,2),A.render(t,o),A.setRenderTarget(e,3),A.render(t,s),A.setRenderTarget(e,4),A.render(t,I),e.texture.generateMipmaps=c,A.setRenderTarget(e,5),A.render(t,r),A.setRenderTarget(g),A.toneMapping=C,A.xr.enabled=B,e.texture.needsPMREMUpdate=!0}}class mE extends Ee{constructor(A,t,e,n,a,o,s,I,r,g){A=A!==void 0?A:[],t=t!==void 0?t:es,super(A,t,e,n,a,o,s,I,r,g),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(A){this.image=A}}class ED extends On{constructor(A=1,t={}){super(A,A,t),this.isWebGLCubeRenderTarget=!0;const e={width:A,height:A,depth:1},n=[e,e,e,e,e,e];this.texture=new mE(n,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:te}fromEquirectangularTexture(A,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const e={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},n=new ls(5,5,5),a=new Wn({name:"CubemapFromEquirect",uniforms:as(e.uniforms),vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,side:ce,blending:an});a.uniforms.tEquirect.value=t;const o=new Oe(n,a),s=t.minFilter;return t.minFilter===Ws&&(t.minFilter=te),new cD(1,10,this).update(A,o),t.minFilter=s,o.geometry.dispose(),o.material.dispose(),this}clear(A,t,e,n){const a=A.getRenderTarget();for(let o=0;o<6;o++)A.setRenderTarget(this,o),A.clear(t,e,n);A.setRenderTarget(a)}}const $g=new cA,QD=new cA,dD=new re;class yn{constructor(A=new cA(1,0,0),t=0){this.isPlane=!0,this.normal=A,this.constant=t}set(A,t){return this.normal.copy(A),this.constant=t,this}setComponents(A,t,e,n){return this.normal.set(A,t,e),this.constant=n,this}setFromNormalAndCoplanarPoint(A,t){return this.normal.copy(A),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(A,t,e){const n=$g.subVectors(e,t).cross(QD.subVectors(A,t)).normalize();return this.setFromNormalAndCoplanarPoint(n,A),this}copy(A){return this.normal.copy(A.normal),this.constant=A.constant,this}normalize(){const A=1/this.normal.length();return this.normal.multiplyScalar(A),this.constant*=A,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(A){return this.normal.dot(A)+this.constant}distanceToSphere(A){return this.distanceToPoint(A.center)-A.radius}projectPoint(A,t){return t.copy(A).addScaledVector(this.normal,-this.distanceToPoint(A))}intersectLine(A,t){const e=A.delta($g),n=this.normal.dot(e);if(n===0)return this.distanceToPoint(A.start)===0?t.copy(A.start):null;const a=-(A.start.dot(this.normal)+this.constant)/n;return a<0||a>1?null:t.copy(A.start).addScaledVector(e,a)}intersectsLine(A){const t=this.distanceToPoint(A.start),e=this.distanceToPoint(A.end);return t<0&&e>0||e<0&&t>0}intersectsBox(A){return A.intersectsPlane(this)}intersectsSphere(A){return A.intersectsPlane(this)}coplanarPoint(A){return A.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(A,t){const e=t||dD.getNormalMatrix(A),n=this.coplanarPoint($g).applyMatrix4(A),a=this.normal.applyMatrix3(e).normalize();return this.constant=-n.dot(a),this}translate(A){return this.constant-=A.dot(this.normal),this}equals(A){return A.normal.equals(this.normal)&&A.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Ra=new Dl,tr=new cA;class yE{constructor(A=new yn,t=new yn,e=new yn,n=new yn,a=new yn,o=new yn){this.planes=[A,t,e,n,a,o]}set(A,t,e,n,a,o){const s=this.planes;return s[0].copy(A),s[1].copy(t),s[2].copy(e),s[3].copy(n),s[4].copy(a),s[5].copy(o),this}copy(A){const t=this.planes;for(let e=0;e<6;e++)t[e].copy(A.planes[e]);return this}setFromProjectionMatrix(A){const t=this.planes,e=A.elements,n=e[0],a=e[1],o=e[2],s=e[3],I=e[4],r=e[5],g=e[6],C=e[7],B=e[8],c=e[9],Q=e[10],h=e[11],l=e[12],E=e[13],f=e[14],u=e[15];return t[0].setComponents(s-n,C-I,h-B,u-l).normalize(),t[1].setComponents(s+n,C+I,h+B,u+l).normalize(),t[2].setComponents(s+a,C+r,h+c,u+E).normalize(),t[3].setComponents(s-a,C-r,h-c,u-E).normalize(),t[4].setComponents(s-o,C-g,h-Q,u-f).normalize(),t[5].setComponents(s+o,C+g,h+Q,u+f).normalize(),this}intersectsObject(A){const t=A.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),Ra.copy(t.boundingSphere).applyMatrix4(A.matrixWorld),this.intersectsSphere(Ra)}intersectsSprite(A){return Ra.center.set(0,0,0),Ra.radius=.7071067811865476,Ra.applyMatrix4(A.matrixWorld),this.intersectsSphere(Ra)}intersectsSphere(A){const t=this.planes,e=A.center,n=-A.radius;for(let a=0;a<6;a++)if(t[a].distanceToPoint(e)<n)return!1;return!0}intersectsBox(A){const t=this.planes;for(let e=0;e<6;e++){const n=t[e];if(tr.x=n.normal.x>0?A.max.x:A.min.x,tr.y=n.normal.y>0?A.max.y:A.min.y,tr.z=n.normal.z>0?A.max.z:A.min.z,n.distanceToPoint(tr)<0)return!1}return!0}containsPoint(A){const t=this.planes;for(let e=0;e<6;e++)if(t[e].distanceToPoint(A)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function DE(){let i=null,A=!1,t=null,e=null;function n(a,o){t(a,o),e=i.requestAnimationFrame(n)}return{start:function(){A!==!0&&t!==null&&(e=i.requestAnimationFrame(n),A=!0)},stop:function(){i.cancelAnimationFrame(e),A=!1},setAnimationLoop:function(a){t=a},setContext:function(a){i=a}}}function fD(i,A){const t=A.isWebGL2,e=new WeakMap;function n(r,g){const C=r.array,B=r.usage,c=i.createBuffer();i.bindBuffer(g,c),i.bufferData(g,C,B),r.onUploadCallback();let Q;if(C instanceof Float32Array)Q=5126;else if(C instanceof Uint16Array)if(r.isFloat16BufferAttribute)if(t)Q=5131;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else Q=5123;else if(C instanceof Int16Array)Q=5122;else if(C instanceof Uint32Array)Q=5125;else if(C instanceof Int32Array)Q=5124;else if(C instanceof Int8Array)Q=5120;else if(C instanceof Uint8Array)Q=5121;else if(C instanceof Uint8ClampedArray)Q=5121;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+C);return{buffer:c,type:Q,bytesPerElement:C.BYTES_PER_ELEMENT,version:r.version}}function a(r,g,C){const B=g.array,c=g.updateRange;i.bindBuffer(C,r),c.count===-1?i.bufferSubData(C,0,B):(t?i.bufferSubData(C,c.offset*B.BYTES_PER_ELEMENT,B,c.offset,c.count):i.bufferSubData(C,c.offset*B.BYTES_PER_ELEMENT,B.subarray(c.offset,c.offset+c.count)),c.count=-1),g.onUploadCallback()}function o(r){return r.isInterleavedBufferAttribute&&(r=r.data),e.get(r)}function s(r){r.isInterleavedBufferAttribute&&(r=r.data);const g=e.get(r);g&&(i.deleteBuffer(g.buffer),e.delete(r))}function I(r,g){if(r.isGLBufferAttribute){const B=e.get(r);(!B||B.version<r.version)&&e.set(r,{buffer:r.buffer,type:r.type,bytesPerElement:r.elementSize,version:r.version});return}r.isInterleavedBufferAttribute&&(r=r.data);const C=e.get(r);C===void 0?e.set(r,n(r,g)):C.version<r.version&&(a(C.buffer,r,g),C.version=r.version)}return{get:o,remove:s,update:I}}class wl extends Bn{constructor(A=1,t=1,e=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:A,height:t,widthSegments:e,heightSegments:n};const a=A/2,o=t/2,s=Math.floor(e),I=Math.floor(n),r=s+1,g=I+1,C=A/s,B=t/I,c=[],Q=[],h=[],l=[];for(let E=0;E<g;E++){const f=E*B-o;for(let u=0;u<r;u++){const d=u*C-a;Q.push(d,-f,0),h.push(0,0,1),l.push(u/s),l.push(1-E/I)}}for(let E=0;E<I;E++)for(let f=0;f<s;f++){const u=f+r*E,d=f+r*(E+1),m=f+1+r*(E+1),S=f+1+r*E;c.push(u,d,S),c.push(d,m,S)}this.setIndex(c),this.setAttribute("position",new gi(Q,3)),this.setAttribute("normal",new gi(h,3)),this.setAttribute("uv",new gi(l,2))}copy(A){return super.copy(A),this.parameters=Object.assign({},A.parameters),this}static fromJSON(A){return new wl(A.width,A.height,A.widthSegments,A.heightSegments)}}var uD=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,pD=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,mD=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,yD=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,DD=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,SD=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,wD="vec3 transformed = vec3( position );",_D=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,xD=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,MD=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,FD=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,RD=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,vD=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,GD=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,ND=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,LD=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,bD=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,UD=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,kD=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,TD=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,HD=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,qD=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,JD=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,PD=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,YD=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,KD=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,OD="gl_FragColor = linearToOutputTexel( gl_FragColor );",WD=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,VD=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,zD=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,XD=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,ZD=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,jD=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,$D=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,AS=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,tS=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,eS=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,iS=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,nS=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,aS=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,sS=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,oS=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,rS=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,gS=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,IS=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lS=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,CS=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,BS=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,hS=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,cS=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,ES=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,QS=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,dS=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,fS=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,uS=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,pS=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,mS=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,yS=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,DS=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,SS=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,wS=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,_S=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,xS=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,MS=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,FS=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,RS=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,vS=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,GS=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,NS=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,LS=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,bS=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,US=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,kS=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,TS=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,HS=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,qS=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,JS=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,PS=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,YS=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,KS=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,OS=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,WS=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,VS=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,zS=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,XS=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,ZS=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,jS=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,$S=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,Aw=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,tw=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,ew=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,iw=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,nw=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,aw=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,sw=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,ow=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,rw=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,gw=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,Iw=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		
		vec2 lodFudge = pow( 1.95, lod ) / fullSize;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec2 fullSize = vec2( textureSize( sampler, 0 ) );
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,lw=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,Cw=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,Bw=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,hw=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,cw=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,Ew=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,Qw=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const dw=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,fw=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,uw=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,pw=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,mw=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,yw=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Dw=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Sw=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,ww=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,_w=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,xw=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,Mw=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Fw=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Rw=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vw=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Gw=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Nw=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Lw=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,bw=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Uw=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,kw=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Tw=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,Hw=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,qw=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Jw=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Pw=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Yw=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Kw=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ow=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Ww=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Vw=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,zw=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Xw=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Zw=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,ZA={alphamap_fragment:uD,alphamap_pars_fragment:pD,alphatest_fragment:mD,alphatest_pars_fragment:yD,aomap_fragment:DD,aomap_pars_fragment:SD,begin_vertex:wD,beginnormal_vertex:_D,bsdfs:xD,iridescence_fragment:MD,bumpmap_pars_fragment:FD,clipping_planes_fragment:RD,clipping_planes_pars_fragment:vD,clipping_planes_pars_vertex:GD,clipping_planes_vertex:ND,color_fragment:LD,color_pars_fragment:bD,color_pars_vertex:UD,color_vertex:kD,common:TD,cube_uv_reflection_fragment:HD,defaultnormal_vertex:qD,displacementmap_pars_vertex:JD,displacementmap_vertex:PD,emissivemap_fragment:YD,emissivemap_pars_fragment:KD,encodings_fragment:OD,encodings_pars_fragment:WD,envmap_fragment:VD,envmap_common_pars_fragment:zD,envmap_pars_fragment:XD,envmap_pars_vertex:ZD,envmap_physical_pars_fragment:gS,envmap_vertex:jD,fog_vertex:$D,fog_pars_vertex:AS,fog_fragment:tS,fog_pars_fragment:eS,gradientmap_pars_fragment:iS,lightmap_fragment:nS,lightmap_pars_fragment:aS,lights_lambert_fragment:sS,lights_lambert_pars_fragment:oS,lights_pars_begin:rS,lights_toon_fragment:IS,lights_toon_pars_fragment:lS,lights_phong_fragment:CS,lights_phong_pars_fragment:BS,lights_physical_fragment:hS,lights_physical_pars_fragment:cS,lights_fragment_begin:ES,lights_fragment_maps:QS,lights_fragment_end:dS,logdepthbuf_fragment:fS,logdepthbuf_pars_fragment:uS,logdepthbuf_pars_vertex:pS,logdepthbuf_vertex:mS,map_fragment:yS,map_pars_fragment:DS,map_particle_fragment:SS,map_particle_pars_fragment:wS,metalnessmap_fragment:_S,metalnessmap_pars_fragment:xS,morphcolor_vertex:MS,morphnormal_vertex:FS,morphtarget_pars_vertex:RS,morphtarget_vertex:vS,normal_fragment_begin:GS,normal_fragment_maps:NS,normal_pars_fragment:LS,normal_pars_vertex:bS,normal_vertex:US,normalmap_pars_fragment:kS,clearcoat_normal_fragment_begin:TS,clearcoat_normal_fragment_maps:HS,clearcoat_pars_fragment:qS,iridescence_pars_fragment:JS,output_fragment:PS,packing:YS,premultiplied_alpha_fragment:KS,project_vertex:OS,dithering_fragment:WS,dithering_pars_fragment:VS,roughnessmap_fragment:zS,roughnessmap_pars_fragment:XS,shadowmap_pars_fragment:ZS,shadowmap_pars_vertex:jS,shadowmap_vertex:$S,shadowmask_pars_fragment:Aw,skinbase_vertex:tw,skinning_pars_vertex:ew,skinning_vertex:iw,skinnormal_vertex:nw,specularmap_fragment:aw,specularmap_pars_fragment:sw,tonemapping_fragment:ow,tonemapping_pars_fragment:rw,transmission_fragment:gw,transmission_pars_fragment:Iw,uv_pars_fragment:lw,uv_pars_vertex:Cw,uv_vertex:Bw,uv2_pars_fragment:hw,uv2_pars_vertex:cw,uv2_vertex:Ew,worldpos_vertex:Qw,background_vert:dw,background_frag:fw,backgroundCube_vert:uw,backgroundCube_frag:pw,cube_vert:mw,cube_frag:yw,depth_vert:Dw,depth_frag:Sw,distanceRGBA_vert:ww,distanceRGBA_frag:_w,equirect_vert:xw,equirect_frag:Mw,linedashed_vert:Fw,linedashed_frag:Rw,meshbasic_vert:vw,meshbasic_frag:Gw,meshlambert_vert:Nw,meshlambert_frag:Lw,meshmatcap_vert:bw,meshmatcap_frag:Uw,meshnormal_vert:kw,meshnormal_frag:Tw,meshphong_vert:Hw,meshphong_frag:qw,meshphysical_vert:Jw,meshphysical_frag:Pw,meshtoon_vert:Yw,meshtoon_frag:Kw,points_vert:Ow,points_frag:Ww,shadow_vert:Vw,shadow_frag:zw,sprite_vert:Xw,sprite_frag:Zw},GA={common:{diffuse:{value:new It(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new re},uv2Transform:{value:new re},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Bt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new It(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new It(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new re}},sprite:{diffuse:{value:new It(16777215)},opacity:{value:1},center:{value:new Bt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new re}}},ti={basic:{uniforms:ie([GA.common,GA.specularmap,GA.envmap,GA.aomap,GA.lightmap,GA.fog]),vertexShader:ZA.meshbasic_vert,fragmentShader:ZA.meshbasic_frag},lambert:{uniforms:ie([GA.common,GA.specularmap,GA.envmap,GA.aomap,GA.lightmap,GA.emissivemap,GA.bumpmap,GA.normalmap,GA.displacementmap,GA.fog,GA.lights,{emissive:{value:new It(0)}}]),vertexShader:ZA.meshlambert_vert,fragmentShader:ZA.meshlambert_frag},phong:{uniforms:ie([GA.common,GA.specularmap,GA.envmap,GA.aomap,GA.lightmap,GA.emissivemap,GA.bumpmap,GA.normalmap,GA.displacementmap,GA.fog,GA.lights,{emissive:{value:new It(0)},specular:{value:new It(1118481)},shininess:{value:30}}]),vertexShader:ZA.meshphong_vert,fragmentShader:ZA.meshphong_frag},standard:{uniforms:ie([GA.common,GA.envmap,GA.aomap,GA.lightmap,GA.emissivemap,GA.bumpmap,GA.normalmap,GA.displacementmap,GA.roughnessmap,GA.metalnessmap,GA.fog,GA.lights,{emissive:{value:new It(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ZA.meshphysical_vert,fragmentShader:ZA.meshphysical_frag},toon:{uniforms:ie([GA.common,GA.aomap,GA.lightmap,GA.emissivemap,GA.bumpmap,GA.normalmap,GA.displacementmap,GA.gradientmap,GA.fog,GA.lights,{emissive:{value:new It(0)}}]),vertexShader:ZA.meshtoon_vert,fragmentShader:ZA.meshtoon_frag},matcap:{uniforms:ie([GA.common,GA.bumpmap,GA.normalmap,GA.displacementmap,GA.fog,{matcap:{value:null}}]),vertexShader:ZA.meshmatcap_vert,fragmentShader:ZA.meshmatcap_frag},points:{uniforms:ie([GA.points,GA.fog]),vertexShader:ZA.points_vert,fragmentShader:ZA.points_frag},dashed:{uniforms:ie([GA.common,GA.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ZA.linedashed_vert,fragmentShader:ZA.linedashed_frag},depth:{uniforms:ie([GA.common,GA.displacementmap]),vertexShader:ZA.depth_vert,fragmentShader:ZA.depth_frag},normal:{uniforms:ie([GA.common,GA.bumpmap,GA.normalmap,GA.displacementmap,{opacity:{value:1}}]),vertexShader:ZA.meshnormal_vert,fragmentShader:ZA.meshnormal_frag},sprite:{uniforms:ie([GA.sprite,GA.fog]),vertexShader:ZA.sprite_vert,fragmentShader:ZA.sprite_frag},background:{uniforms:{uvTransform:{value:new re},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:ZA.background_vert,fragmentShader:ZA.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:ZA.backgroundCube_vert,fragmentShader:ZA.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:ZA.cube_vert,fragmentShader:ZA.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ZA.equirect_vert,fragmentShader:ZA.equirect_frag},distanceRGBA:{uniforms:ie([GA.common,GA.displacementmap,{referencePosition:{value:new cA},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ZA.distanceRGBA_vert,fragmentShader:ZA.distanceRGBA_frag},shadow:{uniforms:ie([GA.lights,GA.fog,{color:{value:new It(0)},opacity:{value:1}}]),vertexShader:ZA.shadow_vert,fragmentShader:ZA.shadow_frag}};ti.physical={uniforms:ie([ti.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Bt(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new It(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Bt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new It(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new It(1,1,1)},specularColorMap:{value:null}}]),vertexShader:ZA.meshphysical_vert,fragmentShader:ZA.meshphysical_frag};const er={r:0,b:0,g:0};function jw(i,A,t,e,n,a,o){const s=new It(0);let I=a===!0?0:1,r,g,C=null,B=0,c=null;function Q(l,E){let f=!1,u=E.isScene===!0?E.background:null;u&&u.isTexture&&(u=(E.backgroundBlurriness>0?t:A).get(u));const d=i.xr,m=d.getSession&&d.getSession();m&&m.environmentBlendMode==="additive"&&(u=null),u===null?h(s,I):u&&u.isColor&&(h(u,1),f=!0),(i.autoClear||f)&&i.clear(i.autoClearColor,i.autoClearDepth,i.autoClearStencil),u&&(u.isCubeTexture||u.mapping===Hr)?(g===void 0&&(g=new Oe(new ls(1,1,1),new Wn({name:"BackgroundCubeMaterial",uniforms:as(ti.backgroundCube.uniforms),vertexShader:ti.backgroundCube.vertexShader,fragmentShader:ti.backgroundCube.fragmentShader,side:ce,depthTest:!1,depthWrite:!1,fog:!1})),g.geometry.deleteAttribute("normal"),g.geometry.deleteAttribute("uv"),g.onBeforeRender=function(S,D,p){this.matrixWorld.copyPosition(p.matrixWorld)},Object.defineProperty(g.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(g)),g.material.uniforms.envMap.value=u,g.material.uniforms.flipEnvMap.value=u.isCubeTexture&&u.isRenderTargetTexture===!1?-1:1,g.material.uniforms.backgroundBlurriness.value=E.backgroundBlurriness,g.material.uniforms.backgroundIntensity.value=E.backgroundIntensity,g.material.toneMapped=u.encoding!==ht,(C!==u||B!==u.version||c!==i.toneMapping)&&(g.material.needsUpdate=!0,C=u,B=u.version,c=i.toneMapping),g.layers.enableAll(),l.unshift(g,g.geometry,g.material,0,0,null)):u&&u.isTexture&&(r===void 0&&(r=new Oe(new wl(2,2),new Wn({name:"BackgroundMaterial",uniforms:as(ti.background.uniforms),vertexShader:ti.background.vertexShader,fragmentShader:ti.background.fragmentShader,side:In,depthTest:!1,depthWrite:!1,fog:!1})),r.geometry.deleteAttribute("normal"),Object.defineProperty(r.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(r)),r.material.uniforms.t2D.value=u,r.material.uniforms.backgroundIntensity.value=E.backgroundIntensity,r.material.toneMapped=u.encoding!==ht,u.matrixAutoUpdate===!0&&u.updateMatrix(),r.material.uniforms.uvTransform.value.copy(u.matrix),(C!==u||B!==u.version||c!==i.toneMapping)&&(r.material.needsUpdate=!0,C=u,B=u.version,c=i.toneMapping),r.layers.enableAll(),l.unshift(r,r.geometry,r.material,0,0,null))}function h(l,E){l.getRGB(er,uE(i)),e.buffers.color.setClear(er.r,er.g,er.b,E,o)}return{getClearColor:function(){return s},setClearColor:function(l,E=1){s.set(l),I=E,h(s,I)},getClearAlpha:function(){return I},setClearAlpha:function(l){I=l,h(s,I)},render:Q}}function $w(i,A,t,e){const n=i.getParameter(34921),a=e.isWebGL2?null:A.get("OES_vertex_array_object"),o=e.isWebGL2||a!==null,s={},I=l(null);let r=I,g=!1;function C(G,T,V,tA,z){let W=!1;if(o){const Y=h(tA,V,T);r!==Y&&(r=Y,c(r.object)),W=E(G,tA,V,z),W&&f(G,tA,V,z)}else{const Y=T.wireframe===!0;(r.geometry!==tA.id||r.program!==V.id||r.wireframe!==Y)&&(r.geometry=tA.id,r.program=V.id,r.wireframe=Y,W=!0)}z!==null&&t.update(z,34963),(W||g)&&(g=!1,p(G,T,V,tA),z!==null&&i.bindBuffer(34963,t.get(z).buffer))}function B(){return e.isWebGL2?i.createVertexArray():a.createVertexArrayOES()}function c(G){return e.isWebGL2?i.bindVertexArray(G):a.bindVertexArrayOES(G)}function Q(G){return e.isWebGL2?i.deleteVertexArray(G):a.deleteVertexArrayOES(G)}function h(G,T,V){const tA=V.wireframe===!0;let z=s[G.id];z===void 0&&(z={},s[G.id]=z);let W=z[T.id];W===void 0&&(W={},z[T.id]=W);let Y=W[tA];return Y===void 0&&(Y=l(B()),W[tA]=Y),Y}function l(G){const T=[],V=[],tA=[];for(let z=0;z<n;z++)T[z]=0,V[z]=0,tA[z]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:T,enabledAttributes:V,attributeDivisors:tA,object:G,attributes:{},index:null}}function E(G,T,V,tA){const z=r.attributes,W=T.attributes;let Y=0;const CA=V.getAttributes();for(const K in CA)if(CA[K].location>=0){const lA=z[K];let Z=W[K];if(Z===void 0&&(K==="instanceMatrix"&&G.instanceMatrix&&(Z=G.instanceMatrix),K==="instanceColor"&&G.instanceColor&&(Z=G.instanceColor)),lA===void 0||lA.attribute!==Z||Z&&lA.data!==Z.data)return!0;Y++}return r.attributesNum!==Y||r.index!==tA}function f(G,T,V,tA){const z={},W=T.attributes;let Y=0;const CA=V.getAttributes();for(const K in CA)if(CA[K].location>=0){let lA=W[K];lA===void 0&&(K==="instanceMatrix"&&G.instanceMatrix&&(lA=G.instanceMatrix),K==="instanceColor"&&G.instanceColor&&(lA=G.instanceColor));const Z={};Z.attribute=lA,lA&&lA.data&&(Z.data=lA.data),z[K]=Z,Y++}r.attributes=z,r.attributesNum=Y,r.index=tA}function u(){const G=r.newAttributes;for(let T=0,V=G.length;T<V;T++)G[T]=0}function d(G){m(G,0)}function m(G,T){const V=r.newAttributes,tA=r.enabledAttributes,z=r.attributeDivisors;V[G]=1,tA[G]===0&&(i.enableVertexAttribArray(G),tA[G]=1),z[G]!==T&&((e.isWebGL2?i:A.get("ANGLE_instanced_arrays"))[e.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](G,T),z[G]=T)}function S(){const G=r.newAttributes,T=r.enabledAttributes;for(let V=0,tA=T.length;V<tA;V++)T[V]!==G[V]&&(i.disableVertexAttribArray(V),T[V]=0)}function D(G,T,V,tA,z,W){e.isWebGL2===!0&&(V===5124||V===5125)?i.vertexAttribIPointer(G,T,V,z,W):i.vertexAttribPointer(G,T,V,tA,z,W)}function p(G,T,V,tA){if(e.isWebGL2===!1&&(G.isInstancedMesh||tA.isInstancedBufferGeometry)&&A.get("ANGLE_instanced_arrays")===null)return;u();const z=tA.attributes,W=V.getAttributes(),Y=T.defaultAttributeValues;for(const CA in W){const K=W[CA];if(K.location>=0){let AA=z[CA];if(AA===void 0&&(CA==="instanceMatrix"&&G.instanceMatrix&&(AA=G.instanceMatrix),CA==="instanceColor"&&G.instanceColor&&(AA=G.instanceColor)),AA!==void 0){const lA=AA.normalized,Z=AA.itemSize,oA=t.get(AA);if(oA===void 0)continue;const wA=oA.buffer,uA=oA.type,mA=oA.bytesPerElement;if(AA.isInterleavedBufferAttribute){const fA=AA.data,RA=fA.stride,MA=AA.offset;if(fA.isInstancedInterleavedBuffer){for(let SA=0;SA<K.locationSize;SA++)m(K.location+SA,fA.meshPerAttribute);G.isInstancedMesh!==!0&&tA._maxInstanceCount===void 0&&(tA._maxInstanceCount=fA.meshPerAttribute*fA.count)}else for(let SA=0;SA<K.locationSize;SA++)d(K.location+SA);i.bindBuffer(34962,wA);for(let SA=0;SA<K.locationSize;SA++)D(K.location+SA,Z/K.locationSize,uA,lA,RA*mA,(MA+Z/K.locationSize*SA)*mA)}else{if(AA.isInstancedBufferAttribute){for(let fA=0;fA<K.locationSize;fA++)m(K.location+fA,AA.meshPerAttribute);G.isInstancedMesh!==!0&&tA._maxInstanceCount===void 0&&(tA._maxInstanceCount=AA.meshPerAttribute*AA.count)}else for(let fA=0;fA<K.locationSize;fA++)d(K.location+fA);i.bindBuffer(34962,wA);for(let fA=0;fA<K.locationSize;fA++)D(K.location+fA,Z/K.locationSize,uA,lA,Z*mA,Z/K.locationSize*fA*mA)}}else if(Y!==void 0){const lA=Y[CA];if(lA!==void 0)switch(lA.length){case 2:i.vertexAttrib2fv(K.location,lA);break;case 3:i.vertexAttrib3fv(K.location,lA);break;case 4:i.vertexAttrib4fv(K.location,lA);break;default:i.vertexAttrib1fv(K.location,lA)}}}}S()}function w(){U();for(const G in s){const T=s[G];for(const V in T){const tA=T[V];for(const z in tA)Q(tA[z].object),delete tA[z];delete T[V]}delete s[G]}}function M(G){if(s[G.id]===void 0)return;const T=s[G.id];for(const V in T){const tA=T[V];for(const z in tA)Q(tA[z].object),delete tA[z];delete T[V]}delete s[G.id]}function R(G){for(const T in s){const V=s[T];if(V[G.id]===void 0)continue;const tA=V[G.id];for(const z in tA)Q(tA[z].object),delete tA[z];delete V[G.id]}}function U(){N(),g=!0,r!==I&&(r=I,c(r.object))}function N(){I.geometry=null,I.program=null,I.wireframe=!1}return{setup:C,reset:U,resetDefaultState:N,dispose:w,releaseStatesOfGeometry:M,releaseStatesOfProgram:R,initAttributes:u,enableAttribute:d,disableUnusedAttributes:S}}function A_(i,A,t,e){const n=e.isWebGL2;let a;function o(r){a=r}function s(r,g){i.drawArrays(a,r,g),t.update(g,a,1)}function I(r,g,C){if(C===0)return;let B,c;if(n)B=i,c="drawArraysInstanced";else if(B=A.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",B===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}B[c](a,r,g,C),t.update(g,a,C)}this.setMode=o,this.render=s,this.renderInstances=I}function t_(i,A,t){let e;function n(){if(e!==void 0)return e;if(A.has("EXT_texture_filter_anisotropic")===!0){const D=A.get("EXT_texture_filter_anisotropic");e=i.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else e=0;return e}function a(D){if(D==="highp"){if(i.getShaderPrecisionFormat(35633,36338).precision>0&&i.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";D="mediump"}return D==="mediump"&&i.getShaderPrecisionFormat(35633,36337).precision>0&&i.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&i instanceof WebGL2RenderingContext;let s=t.precision!==void 0?t.precision:"highp";const I=a(s);I!==s&&(console.warn("THREE.WebGLRenderer:",s,"not supported, using",I,"instead."),s=I);const r=o||A.has("WEBGL_draw_buffers"),g=t.logarithmicDepthBuffer===!0,C=i.getParameter(34930),B=i.getParameter(35660),c=i.getParameter(3379),Q=i.getParameter(34076),h=i.getParameter(34921),l=i.getParameter(36347),E=i.getParameter(36348),f=i.getParameter(36349),u=B>0,d=o||A.has("OES_texture_float"),m=u&&d,S=o?i.getParameter(36183):0;return{isWebGL2:o,drawBuffers:r,getMaxAnisotropy:n,getMaxPrecision:a,precision:s,logarithmicDepthBuffer:g,maxTextures:C,maxVertexTextures:B,maxTextureSize:c,maxCubemapSize:Q,maxAttributes:h,maxVertexUniforms:l,maxVaryings:E,maxFragmentUniforms:f,vertexTextures:u,floatFragmentTextures:d,floatVertexTextures:m,maxSamples:S}}function e_(i){const A=this;let t=null,e=0,n=!1,a=!1;const o=new yn,s=new re,I={value:null,needsUpdate:!1};this.uniform=I,this.numPlanes=0,this.numIntersection=0,this.init=function(C,B){const c=C.length!==0||B||e!==0||n;return n=B,e=C.length,c},this.beginShadows=function(){a=!0,g(null)},this.endShadows=function(){a=!1},this.setGlobalState=function(C,B){t=g(C,B,0)},this.setState=function(C,B,c){const Q=C.clippingPlanes,h=C.clipIntersection,l=C.clipShadows,E=i.get(C);if(!n||Q===null||Q.length===0||a&&!l)a?g(null):r();else{const f=a?0:e,u=f*4;let d=E.clippingState||null;I.value=d,d=g(Q,B,u,c);for(let m=0;m!==u;++m)d[m]=t[m];E.clippingState=d,this.numIntersection=h?this.numPlanes:0,this.numPlanes+=f}};function r(){I.value!==t&&(I.value=t,I.needsUpdate=e>0),A.numPlanes=e,A.numIntersection=0}function g(C,B,c,Q){const h=C!==null?C.length:0;let l=null;if(h!==0){if(l=I.value,Q!==!0||l===null){const E=c+h*4,f=B.matrixWorldInverse;s.getNormalMatrix(f),(l===null||l.length<E)&&(l=new Float32Array(E));for(let u=0,d=c;u!==h;++u,d+=4)o.copy(C[u]).applyMatrix4(f,s),o.normal.toArray(l,d),l[d+3]=o.constant}I.value=l,I.needsUpdate=!0}return A.numPlanes=h,A.numIntersection=0,l}}function i_(i){let A=new WeakMap;function t(o,s){return s===TI?o.mapping=es:s===HI&&(o.mapping=is),o}function e(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const s=o.mapping;if(s===TI||s===HI)if(A.has(o)){const I=A.get(o).texture;return t(I,o.mapping)}else{const I=o.image;if(I&&I.height>0){const r=new ED(I.height/2);return r.fromEquirectangularTexture(i,o),A.set(o,r),o.addEventListener("dispose",n),t(r.texture,o.mapping)}else return null}}return o}function n(o){const s=o.target;s.removeEventListener("dispose",n);const I=A.get(s);I!==void 0&&(A.delete(s),I.dispose())}function a(){A=new WeakMap}return{get:e,dispose:a}}class n_ extends pE{constructor(A=-1,t=1,e=1,n=-1,a=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=A,this.right=t,this.top=e,this.bottom=n,this.near=a,this.far=o,this.updateProjectionMatrix()}copy(A,t){return super.copy(A,t),this.left=A.left,this.right=A.right,this.top=A.top,this.bottom=A.bottom,this.near=A.near,this.far=A.far,this.zoom=A.zoom,this.view=A.view===null?null:Object.assign({},A.view),this}setViewOffset(A,t,e,n,a,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=A,this.view.fullHeight=t,this.view.offsetX=e,this.view.offsetY=n,this.view.width=a,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const A=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),e=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let a=e-A,o=e+A,s=n+t,I=n-t;if(this.view!==null&&this.view.enabled){const r=(this.right-this.left)/this.view.fullWidth/this.zoom,g=(this.top-this.bottom)/this.view.fullHeight/this.zoom;a+=r*this.view.offsetX,o=a+r*this.view.width,s-=g*this.view.offsetY,I=s-g*this.view.height}this.projectionMatrix.makeOrthographic(a,o,s,I,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(A){const t=super.toJSON(A);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const qa=4,zB=[.125,.215,.35,.446,.526,.582],xn=20,AI=new n_,XB=new It;let tI=null;const Dn=(1+Math.sqrt(5))/2,va=1/Dn,ZB=[new cA(1,1,1),new cA(-1,1,1),new cA(1,1,-1),new cA(-1,1,-1),new cA(0,Dn,va),new cA(0,Dn,-va),new cA(va,0,Dn),new cA(-va,0,Dn),new cA(Dn,va,0),new cA(-Dn,va,0)];class jB{constructor(A){this._renderer=A,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(A,t=0,e=.1,n=100){tI=this._renderer.getRenderTarget(),this._setSize(256);const a=this._allocateTargets();return a.depthBuffer=!0,this._sceneToCubeUV(A,e,n,a),t>0&&this._blur(a,0,0,t),this._applyPMREM(a),this._cleanup(a),a}fromEquirectangular(A,t=null){return this._fromTexture(A,t)}fromCubemap(A,t=null){return this._fromTexture(A,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=th(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=Ah(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(A){this._lodMax=Math.floor(Math.log2(A)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let A=0;A<this._lodPlanes.length;A++)this._lodPlanes[A].dispose()}_cleanup(A){this._renderer.setRenderTarget(tI),A.scissorTest=!1,ir(A,0,0,A.width,A.height)}_fromTexture(A,t){A.mapping===es||A.mapping===is?this._setSize(A.image.length===0?16:A.image[0].width||A.image[0].image.width):this._setSize(A.image.width/4),tI=this._renderer.getRenderTarget();const e=t||this._allocateTargets();return this._textureToCubeUV(A,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(){const A=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,e={magFilter:te,minFilter:te,generateMipmaps:!1,type:Vs,format:Ke,encoding:Kn,depthBuffer:!1},n=$B(A,t,e);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==A||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=$B(A,t,e);const{_lodMax:a}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=a_(a)),this._blurMaterial=s_(a,A,t)}return n}_compileMaterial(A){const t=new Oe(this._lodPlanes[0],A);this._renderer.compile(t,AI)}_sceneToCubeUV(A,t,e,n){const s=new Ye(90,1,t,e),I=[1,-1,1,1,1,1],r=[1,1,1,-1,-1,-1],g=this._renderer,C=g.autoClear,B=g.toneMapping;g.getClearColor(XB),g.toneMapping=Ni,g.autoClear=!1;const c=new Sl({name:"PMREM.Background",side:ce,depthWrite:!1,depthTest:!1}),Q=new Oe(new ls,c);let h=!1;const l=A.background;l?l.isColor&&(c.color.copy(l),A.background=null,h=!0):(c.color.copy(XB),h=!0);for(let E=0;E<6;E++){const f=E%3;f===0?(s.up.set(0,I[E],0),s.lookAt(r[E],0,0)):f===1?(s.up.set(0,0,I[E]),s.lookAt(0,r[E],0)):(s.up.set(0,I[E],0),s.lookAt(0,0,r[E]));const u=this._cubeSize;ir(n,f*u,E>2?u:0,u,u),g.setRenderTarget(n),h&&g.render(Q,s),g.render(A,s)}Q.geometry.dispose(),Q.material.dispose(),g.toneMapping=B,g.autoClear=C,A.background=l}_textureToCubeUV(A,t){const e=this._renderer,n=A.mapping===es||A.mapping===is;n?(this._cubemapMaterial===null&&(this._cubemapMaterial=th()),this._cubemapMaterial.uniforms.flipEnvMap.value=A.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=Ah());const a=n?this._cubemapMaterial:this._equirectMaterial,o=new Oe(this._lodPlanes[0],a),s=a.uniforms;s.envMap.value=A;const I=this._cubeSize;ir(t,0,0,3*I,2*I),e.setRenderTarget(t),e.render(o,AI)}_applyPMREM(A){const t=this._renderer,e=t.autoClear;t.autoClear=!1;for(let n=1;n<this._lodPlanes.length;n++){const a=Math.sqrt(this._sigmas[n]*this._sigmas[n]-this._sigmas[n-1]*this._sigmas[n-1]),o=ZB[(n-1)%ZB.length];this._blur(A,n-1,n,a,o)}t.autoClear=e}_blur(A,t,e,n,a){const o=this._pingPongRenderTarget;this._halfBlur(A,o,t,e,n,"latitudinal",a),this._halfBlur(o,A,e,e,n,"longitudinal",a)}_halfBlur(A,t,e,n,a,o,s){const I=this._renderer,r=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const g=3,C=new Oe(this._lodPlanes[n],r),B=r.uniforms,c=this._sizeLods[e]-1,Q=isFinite(a)?Math.PI/(2*c):2*Math.PI/(2*xn-1),h=a/Q,l=isFinite(a)?1+Math.floor(g*h):xn;l>xn&&console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${l} samples when the maximum is set to ${xn}`);const E=[];let f=0;for(let D=0;D<xn;++D){const p=D/h,w=Math.exp(-p*p/2);E.push(w),D===0?f+=w:D<l&&(f+=2*w)}for(let D=0;D<E.length;D++)E[D]=E[D]/f;B.envMap.value=A.texture,B.samples.value=l,B.weights.value=E,B.latitudinal.value=o==="latitudinal",s&&(B.poleAxis.value=s);const{_lodMax:u}=this;B.dTheta.value=Q,B.mipInt.value=u-e;const d=this._sizeLods[n],m=3*d*(n>u-qa?n-u+qa:0),S=4*(this._cubeSize-d);ir(t,m,S,3*d,2*d),I.setRenderTarget(t),I.render(C,AI)}}function a_(i){const A=[],t=[],e=[];let n=i;const a=i-qa+1+zB.length;for(let o=0;o<a;o++){const s=Math.pow(2,n);t.push(s);let I=1/s;o>i-qa?I=zB[o-i+qa-1]:o===0&&(I=0),e.push(I);const r=1/(s-2),g=-r,C=1+r,B=[g,g,C,g,C,C,g,g,C,C,g,C],c=6,Q=6,h=3,l=2,E=1,f=new Float32Array(h*Q*c),u=new Float32Array(l*Q*c),d=new Float32Array(E*Q*c);for(let S=0;S<c;S++){const D=S%3*2/3-1,p=S>2?0:-1,w=[D,p,0,D+2/3,p,0,D+2/3,p+1,0,D,p,0,D+2/3,p+1,0,D,p+1,0];f.set(w,h*Q*S),u.set(B,l*Q*S);const M=[S,S,S,S,S,S];d.set(M,E*Q*S)}const m=new Bn;m.setAttribute("position",new We(f,h)),m.setAttribute("uv",new We(u,l)),m.setAttribute("faceIndex",new We(d,E)),A.push(m),n>qa&&n--}return{lodPlanes:A,sizeLods:t,sigmas:e}}function $B(i,A,t){const e=new On(i,A,t);return e.texture.mapping=Hr,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function ir(i,A,t,e,n){i.viewport.set(A,t,e,n),i.scissor.set(A,t,e,n)}function s_(i,A,t){const e=new Float32Array(xn),n=new cA(0,1,0);return new Wn({name:"SphericalGaussianBlur",defines:{n:xn,CUBEUV_TEXEL_WIDTH:1/A,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${i}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n}},vertexShader:_l(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:an,depthTest:!1,depthWrite:!1})}function Ah(){return new Wn({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:_l(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:an,depthTest:!1,depthWrite:!1})}function th(){return new Wn({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_l(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:an,depthTest:!1,depthWrite:!1})}function _l(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function o_(i){let A=new WeakMap,t=null;function e(s){if(s&&s.isTexture){const I=s.mapping,r=I===TI||I===HI,g=I===es||I===is;if(r||g)if(s.isRenderTargetTexture&&s.needsPMREMUpdate===!0){s.needsPMREMUpdate=!1;let C=A.get(s);return t===null&&(t=new jB(i)),C=r?t.fromEquirectangular(s,C):t.fromCubemap(s,C),A.set(s,C),C.texture}else{if(A.has(s))return A.get(s).texture;{const C=s.image;if(r&&C&&C.height>0||g&&C&&n(C)){t===null&&(t=new jB(i));const B=r?t.fromEquirectangular(s):t.fromCubemap(s);return A.set(s,B),s.addEventListener("dispose",a),B.texture}else return null}}}return s}function n(s){let I=0;const r=6;for(let g=0;g<r;g++)s[g]!==void 0&&I++;return I===r}function a(s){const I=s.target;I.removeEventListener("dispose",a);const r=A.get(I);r!==void 0&&(A.delete(I),r.dispose())}function o(){A=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:e,dispose:o}}function r_(i){const A={};function t(e){if(A[e]!==void 0)return A[e];let n;switch(e){case"WEBGL_depth_texture":n=i.getExtension("WEBGL_depth_texture")||i.getExtension("MOZ_WEBGL_depth_texture")||i.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=i.getExtension("EXT_texture_filter_anisotropic")||i.getExtension("MOZ_EXT_texture_filter_anisotropic")||i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=i.getExtension("WEBGL_compressed_texture_s3tc")||i.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=i.getExtension("WEBGL_compressed_texture_pvrtc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=i.getExtension(e)}return A[e]=n,n}return{has:function(e){return t(e)!==null},init:function(e){e.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(e){const n=t(e);return n===null&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),n}}}function g_(i,A,t,e){const n={},a=new WeakMap;function o(C){const B=C.target;B.index!==null&&A.remove(B.index);for(const Q in B.attributes)A.remove(B.attributes[Q]);B.removeEventListener("dispose",o),delete n[B.id];const c=a.get(B);c&&(A.remove(c),a.delete(B)),e.releaseStatesOfGeometry(B),B.isInstancedBufferGeometry===!0&&delete B._maxInstanceCount,t.memory.geometries--}function s(C,B){return n[B.id]===!0||(B.addEventListener("dispose",o),n[B.id]=!0,t.memory.geometries++),B}function I(C){const B=C.attributes;for(const Q in B)A.update(B[Q],34962);const c=C.morphAttributes;for(const Q in c){const h=c[Q];for(let l=0,E=h.length;l<E;l++)A.update(h[l],34962)}}function r(C){const B=[],c=C.index,Q=C.attributes.position;let h=0;if(c!==null){const f=c.array;h=c.version;for(let u=0,d=f.length;u<d;u+=3){const m=f[u+0],S=f[u+1],D=f[u+2];B.push(m,S,S,D,D,m)}}else{const f=Q.array;h=Q.version;for(let u=0,d=f.length/3-1;u<d;u+=3){const m=u+0,S=u+1,D=u+2;B.push(m,S,S,D,D,m)}}const l=new(CE(B)?fE:dE)(B,1);l.version=h;const E=a.get(C);E&&A.remove(E),a.set(C,l)}function g(C){const B=a.get(C);if(B){const c=C.index;c!==null&&B.version<c.version&&r(C)}else r(C);return a.get(C)}return{get:s,update:I,getWireframeAttribute:g}}function I_(i,A,t,e){const n=e.isWebGL2;let a;function o(B){a=B}let s,I;function r(B){s=B.type,I=B.bytesPerElement}function g(B,c){i.drawElements(a,c,s,B*I),t.update(c,a,1)}function C(B,c,Q){if(Q===0)return;let h,l;if(n)h=i,l="drawElementsInstanced";else if(h=A.get("ANGLE_instanced_arrays"),l="drawElementsInstancedANGLE",h===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}h[l](a,c,s,B*I,Q),t.update(c,a,Q)}this.setMode=o,this.setIndex=r,this.render=g,this.renderInstances=C}function l_(i){const A={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function e(a,o,s){switch(t.calls++,o){case 4:t.triangles+=s*(a/3);break;case 1:t.lines+=s*(a/2);break;case 3:t.lines+=s*(a-1);break;case 2:t.lines+=s*a;break;case 0:t.points+=s*a;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function n(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:A,render:t,programs:null,autoReset:!0,reset:n,update:e}}function C_(i,A){return i[0]-A[0]}function B_(i,A){return Math.abs(A[1])-Math.abs(i[1])}function h_(i,A,t){const e={},n=new Float32Array(8),a=new WeakMap,o=new Vt,s=[];for(let r=0;r<8;r++)s[r]=[r,0];function I(r,g,C){const B=r.morphTargetInfluences;if(A.isWebGL2===!0){const Q=g.morphAttributes.position||g.morphAttributes.normal||g.morphAttributes.color,h=Q!==void 0?Q.length:0;let l=a.get(g);if(l===void 0||l.count!==h){let T=function(){N.dispose(),a.delete(g),g.removeEventListener("dispose",T)};var c=T;l!==void 0&&l.texture.dispose();const u=g.morphAttributes.position!==void 0,d=g.morphAttributes.normal!==void 0,m=g.morphAttributes.color!==void 0,S=g.morphAttributes.position||[],D=g.morphAttributes.normal||[],p=g.morphAttributes.color||[];let w=0;u===!0&&(w=1),d===!0&&(w=2),m===!0&&(w=3);let M=g.attributes.position.count*w,R=1;M>A.maxTextureSize&&(R=Math.ceil(M/A.maxTextureSize),M=A.maxTextureSize);const U=new Float32Array(M*R*4*h),N=new cE(U,M,R,h);N.type=vn,N.needsUpdate=!0;const G=w*4;for(let V=0;V<h;V++){const tA=S[V],z=D[V],W=p[V],Y=M*R*4*V;for(let CA=0;CA<tA.count;CA++){const K=CA*G;u===!0&&(o.fromBufferAttribute(tA,CA),U[Y+K+0]=o.x,U[Y+K+1]=o.y,U[Y+K+2]=o.z,U[Y+K+3]=0),d===!0&&(o.fromBufferAttribute(z,CA),U[Y+K+4]=o.x,U[Y+K+5]=o.y,U[Y+K+6]=o.z,U[Y+K+7]=0),m===!0&&(o.fromBufferAttribute(W,CA),U[Y+K+8]=o.x,U[Y+K+9]=o.y,U[Y+K+10]=o.z,U[Y+K+11]=W.itemSize===4?o.w:1)}}l={count:h,texture:N,size:new Bt(M,R)},a.set(g,l),g.addEventListener("dispose",T)}let E=0;for(let u=0;u<B.length;u++)E+=B[u];const f=g.morphTargetsRelative?1:1-E;C.getUniforms().setValue(i,"morphTargetBaseInfluence",f),C.getUniforms().setValue(i,"morphTargetInfluences",B),C.getUniforms().setValue(i,"morphTargetsTexture",l.texture,t),C.getUniforms().setValue(i,"morphTargetsTextureSize",l.size)}else{const Q=B===void 0?0:B.length;let h=e[g.id];if(h===void 0||h.length!==Q){h=[];for(let d=0;d<Q;d++)h[d]=[d,0];e[g.id]=h}for(let d=0;d<Q;d++){const m=h[d];m[0]=d,m[1]=B[d]}h.sort(B_);for(let d=0;d<8;d++)d<Q&&h[d][1]?(s[d][0]=h[d][0],s[d][1]=h[d][1]):(s[d][0]=Number.MAX_SAFE_INTEGER,s[d][1]=0);s.sort(C_);const l=g.morphAttributes.position,E=g.morphAttributes.normal;let f=0;for(let d=0;d<8;d++){const m=s[d],S=m[0],D=m[1];S!==Number.MAX_SAFE_INTEGER&&D?(l&&g.getAttribute("morphTarget"+d)!==l[S]&&g.setAttribute("morphTarget"+d,l[S]),E&&g.getAttribute("morphNormal"+d)!==E[S]&&g.setAttribute("morphNormal"+d,E[S]),n[d]=D,f+=D):(l&&g.hasAttribute("morphTarget"+d)===!0&&g.deleteAttribute("morphTarget"+d),E&&g.hasAttribute("morphNormal"+d)===!0&&g.deleteAttribute("morphNormal"+d),n[d]=0)}const u=g.morphTargetsRelative?1:1-f;C.getUniforms().setValue(i,"morphTargetBaseInfluence",u),C.getUniforms().setValue(i,"morphTargetInfluences",n)}}return{update:I}}function c_(i,A,t,e){let n=new WeakMap;function a(I){const r=e.render.frame,g=I.geometry,C=A.get(I,g);return n.get(C)!==r&&(A.update(C),n.set(C,r)),I.isInstancedMesh&&(I.hasEventListener("dispose",s)===!1&&I.addEventListener("dispose",s),t.update(I.instanceMatrix,34962),I.instanceColor!==null&&t.update(I.instanceColor,34962)),C}function o(){n=new WeakMap}function s(I){const r=I.target;r.removeEventListener("dispose",s),t.remove(r.instanceMatrix),r.instanceColor!==null&&t.remove(r.instanceColor)}return{update:a,dispose:o}}const SE=new Ee,wE=new cE,_E=new OI,xE=new mE,eh=[],ih=[],nh=new Float32Array(16),ah=new Float32Array(9),sh=new Float32Array(4);function Cs(i,A,t){const e=i[0];if(e<=0||e>0)return i;const n=A*t;let a=eh[n];if(a===void 0&&(a=new Float32Array(n),eh[n]=a),A!==0){e.toArray(a,0);for(let o=1,s=0;o!==A;++o)s+=t,i[o].toArray(a,s)}return a}function Lt(i,A){if(i.length!==A.length)return!1;for(let t=0,e=i.length;t<e;t++)if(i[t]!==A[t])return!1;return!0}function bt(i,A){for(let t=0,e=A.length;t<e;t++)i[t]=A[t]}function Jr(i,A){let t=ih[A];t===void 0&&(t=new Int32Array(A),ih[A]=t);for(let e=0;e!==A;++e)t[e]=i.allocateTextureUnit();return t}function E_(i,A){const t=this.cache;t[0]!==A&&(i.uniform1f(this.addr,A),t[0]=A)}function Q_(i,A){const t=this.cache;if(A.x!==void 0)(t[0]!==A.x||t[1]!==A.y)&&(i.uniform2f(this.addr,A.x,A.y),t[0]=A.x,t[1]=A.y);else{if(Lt(t,A))return;i.uniform2fv(this.addr,A),bt(t,A)}}function d_(i,A){const t=this.cache;if(A.x!==void 0)(t[0]!==A.x||t[1]!==A.y||t[2]!==A.z)&&(i.uniform3f(this.addr,A.x,A.y,A.z),t[0]=A.x,t[1]=A.y,t[2]=A.z);else if(A.r!==void 0)(t[0]!==A.r||t[1]!==A.g||t[2]!==A.b)&&(i.uniform3f(this.addr,A.r,A.g,A.b),t[0]=A.r,t[1]=A.g,t[2]=A.b);else{if(Lt(t,A))return;i.uniform3fv(this.addr,A),bt(t,A)}}function f_(i,A){const t=this.cache;if(A.x!==void 0)(t[0]!==A.x||t[1]!==A.y||t[2]!==A.z||t[3]!==A.w)&&(i.uniform4f(this.addr,A.x,A.y,A.z,A.w),t[0]=A.x,t[1]=A.y,t[2]=A.z,t[3]=A.w);else{if(Lt(t,A))return;i.uniform4fv(this.addr,A),bt(t,A)}}function u_(i,A){const t=this.cache,e=A.elements;if(e===void 0){if(Lt(t,A))return;i.uniformMatrix2fv(this.addr,!1,A),bt(t,A)}else{if(Lt(t,e))return;sh.set(e),i.uniformMatrix2fv(this.addr,!1,sh),bt(t,e)}}function p_(i,A){const t=this.cache,e=A.elements;if(e===void 0){if(Lt(t,A))return;i.uniformMatrix3fv(this.addr,!1,A),bt(t,A)}else{if(Lt(t,e))return;ah.set(e),i.uniformMatrix3fv(this.addr,!1,ah),bt(t,e)}}function m_(i,A){const t=this.cache,e=A.elements;if(e===void 0){if(Lt(t,A))return;i.uniformMatrix4fv(this.addr,!1,A),bt(t,A)}else{if(Lt(t,e))return;nh.set(e),i.uniformMatrix4fv(this.addr,!1,nh),bt(t,e)}}function y_(i,A){const t=this.cache;t[0]!==A&&(i.uniform1i(this.addr,A),t[0]=A)}function D_(i,A){const t=this.cache;if(A.x!==void 0)(t[0]!==A.x||t[1]!==A.y)&&(i.uniform2i(this.addr,A.x,A.y),t[0]=A.x,t[1]=A.y);else{if(Lt(t,A))return;i.uniform2iv(this.addr,A),bt(t,A)}}function S_(i,A){const t=this.cache;if(A.x!==void 0)(t[0]!==A.x||t[1]!==A.y||t[2]!==A.z)&&(i.uniform3i(this.addr,A.x,A.y,A.z),t[0]=A.x,t[1]=A.y,t[2]=A.z);else{if(Lt(t,A))return;i.uniform3iv(this.addr,A),bt(t,A)}}function w_(i,A){const t=this.cache;if(A.x!==void 0)(t[0]!==A.x||t[1]!==A.y||t[2]!==A.z||t[3]!==A.w)&&(i.uniform4i(this.addr,A.x,A.y,A.z,A.w),t[0]=A.x,t[1]=A.y,t[2]=A.z,t[3]=A.w);else{if(Lt(t,A))return;i.uniform4iv(this.addr,A),bt(t,A)}}function __(i,A){const t=this.cache;t[0]!==A&&(i.uniform1ui(this.addr,A),t[0]=A)}function x_(i,A){const t=this.cache;if(A.x!==void 0)(t[0]!==A.x||t[1]!==A.y)&&(i.uniform2ui(this.addr,A.x,A.y),t[0]=A.x,t[1]=A.y);else{if(Lt(t,A))return;i.uniform2uiv(this.addr,A),bt(t,A)}}function M_(i,A){const t=this.cache;if(A.x!==void 0)(t[0]!==A.x||t[1]!==A.y||t[2]!==A.z)&&(i.uniform3ui(this.addr,A.x,A.y,A.z),t[0]=A.x,t[1]=A.y,t[2]=A.z);else{if(Lt(t,A))return;i.uniform3uiv(this.addr,A),bt(t,A)}}function F_(i,A){const t=this.cache;if(A.x!==void 0)(t[0]!==A.x||t[1]!==A.y||t[2]!==A.z||t[3]!==A.w)&&(i.uniform4ui(this.addr,A.x,A.y,A.z,A.w),t[0]=A.x,t[1]=A.y,t[2]=A.z,t[3]=A.w);else{if(Lt(t,A))return;i.uniform4uiv(this.addr,A),bt(t,A)}}function R_(i,A,t){const e=this.cache,n=t.allocateTextureUnit();e[0]!==n&&(i.uniform1i(this.addr,n),e[0]=n),t.setTexture2D(A||SE,n)}function v_(i,A,t){const e=this.cache,n=t.allocateTextureUnit();e[0]!==n&&(i.uniform1i(this.addr,n),e[0]=n),t.setTexture3D(A||_E,n)}function G_(i,A,t){const e=this.cache,n=t.allocateTextureUnit();e[0]!==n&&(i.uniform1i(this.addr,n),e[0]=n),t.setTextureCube(A||xE,n)}function N_(i,A,t){const e=this.cache,n=t.allocateTextureUnit();e[0]!==n&&(i.uniform1i(this.addr,n),e[0]=n),t.setTexture2DArray(A||wE,n)}function L_(i){switch(i){case 5126:return E_;case 35664:return Q_;case 35665:return d_;case 35666:return f_;case 35674:return u_;case 35675:return p_;case 35676:return m_;case 5124:case 35670:return y_;case 35667:case 35671:return D_;case 35668:case 35672:return S_;case 35669:case 35673:return w_;case 5125:return __;case 36294:return x_;case 36295:return M_;case 36296:return F_;case 35678:case 36198:case 36298:case 36306:case 35682:return R_;case 35679:case 36299:case 36307:return v_;case 35680:case 36300:case 36308:case 36293:return G_;case 36289:case 36303:case 36311:case 36292:return N_}}function b_(i,A){i.uniform1fv(this.addr,A)}function U_(i,A){const t=Cs(A,this.size,2);i.uniform2fv(this.addr,t)}function k_(i,A){const t=Cs(A,this.size,3);i.uniform3fv(this.addr,t)}function T_(i,A){const t=Cs(A,this.size,4);i.uniform4fv(this.addr,t)}function H_(i,A){const t=Cs(A,this.size,4);i.uniformMatrix2fv(this.addr,!1,t)}function q_(i,A){const t=Cs(A,this.size,9);i.uniformMatrix3fv(this.addr,!1,t)}function J_(i,A){const t=Cs(A,this.size,16);i.uniformMatrix4fv(this.addr,!1,t)}function P_(i,A){i.uniform1iv(this.addr,A)}function Y_(i,A){i.uniform2iv(this.addr,A)}function K_(i,A){i.uniform3iv(this.addr,A)}function O_(i,A){i.uniform4iv(this.addr,A)}function W_(i,A){i.uniform1uiv(this.addr,A)}function V_(i,A){i.uniform2uiv(this.addr,A)}function z_(i,A){i.uniform3uiv(this.addr,A)}function X_(i,A){i.uniform4uiv(this.addr,A)}function Z_(i,A,t){const e=this.cache,n=A.length,a=Jr(t,n);Lt(e,a)||(i.uniform1iv(this.addr,a),bt(e,a));for(let o=0;o!==n;++o)t.setTexture2D(A[o]||SE,a[o])}function j_(i,A,t){const e=this.cache,n=A.length,a=Jr(t,n);Lt(e,a)||(i.uniform1iv(this.addr,a),bt(e,a));for(let o=0;o!==n;++o)t.setTexture3D(A[o]||_E,a[o])}function $_(i,A,t){const e=this.cache,n=A.length,a=Jr(t,n);Lt(e,a)||(i.uniform1iv(this.addr,a),bt(e,a));for(let o=0;o!==n;++o)t.setTextureCube(A[o]||xE,a[o])}function Ax(i,A,t){const e=this.cache,n=A.length,a=Jr(t,n);Lt(e,a)||(i.uniform1iv(this.addr,a),bt(e,a));for(let o=0;o!==n;++o)t.setTexture2DArray(A[o]||wE,a[o])}function tx(i){switch(i){case 5126:return b_;case 35664:return U_;case 35665:return k_;case 35666:return T_;case 35674:return H_;case 35675:return q_;case 35676:return J_;case 5124:case 35670:return P_;case 35667:case 35671:return Y_;case 35668:case 35672:return K_;case 35669:case 35673:return O_;case 5125:return W_;case 36294:return V_;case 36295:return z_;case 36296:return X_;case 35678:case 36198:case 36298:case 36306:case 35682:return Z_;case 35679:case 36299:case 36307:return j_;case 35680:case 36300:case 36308:case 36293:return $_;case 36289:case 36303:case 36311:case 36292:return Ax}}class ex{constructor(A,t,e){this.id=A,this.addr=e,this.cache=[],this.setValue=L_(t.type)}}class ix{constructor(A,t,e){this.id=A,this.addr=e,this.cache=[],this.size=t.size,this.setValue=tx(t.type)}}class nx{constructor(A){this.id=A,this.seq=[],this.map={}}setValue(A,t,e){const n=this.seq;for(let a=0,o=n.length;a!==o;++a){const s=n[a];s.setValue(A,t[s.id],e)}}}const eI=/(\w+)(\])?(\[|\.)?/g;function oh(i,A){i.seq.push(A),i.map[A.id]=A}function ax(i,A,t){const e=i.name,n=e.length;for(eI.lastIndex=0;;){const a=eI.exec(e),o=eI.lastIndex;let s=a[1];const I=a[2]==="]",r=a[3];if(I&&(s=s|0),r===void 0||r==="["&&o+2===n){oh(t,r===void 0?new ex(s,i,A):new ix(s,i,A));break}else{let C=t.map[s];C===void 0&&(C=new nx(s),oh(t,C)),t=C}}}class cr{constructor(A,t){this.seq=[],this.map={};const e=A.getProgramParameter(t,35718);for(let n=0;n<e;++n){const a=A.getActiveUniform(t,n),o=A.getUniformLocation(t,a.name);ax(a,o,this)}}setValue(A,t,e,n){const a=this.map[t];a!==void 0&&a.setValue(A,e,n)}setOptional(A,t,e){const n=t[e];n!==void 0&&this.setValue(A,e,n)}static upload(A,t,e,n){for(let a=0,o=t.length;a!==o;++a){const s=t[a],I=e[s.id];I.needsUpdate!==!1&&s.setValue(A,I.value,n)}}static seqWithValue(A,t){const e=[];for(let n=0,a=A.length;n!==a;++n){const o=A[n];o.id in t&&e.push(o)}return e}}function rh(i,A,t){const e=i.createShader(A);return i.shaderSource(e,t),i.compileShader(e),e}let sx=0;function ox(i,A){const t=i.split(`
`),e=[],n=Math.max(A-6,0),a=Math.min(A+6,t.length);for(let o=n;o<a;o++){const s=o+1;e.push(`${s===A?">":" "} ${s}: ${t[o]}`)}return e.join(`
`)}function rx(i){switch(i){case Kn:return["Linear","( value )"];case ht:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",i),["Linear","( value )"]}}function gh(i,A,t){const e=i.getShaderParameter(A,35713),n=i.getShaderInfoLog(A).trim();if(e&&n==="")return"";const a=/ERROR: 0:(\d+)/.exec(n);if(a){const o=parseInt(a[1]);return t.toUpperCase()+`

`+n+`

`+ox(i.getShaderSource(A),o)}else return n}function gx(i,A){const t=rx(A);return"vec4 "+i+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function Ix(i,A){let t;switch(A){case ry:t="Linear";break;case gy:t="Reinhard";break;case Iy:t="OptimizedCineon";break;case ly:t="ACESFilmic";break;case Cy:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",A),t="Linear"}return"vec3 "+i+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function lx(i){return[i.extensionDerivatives||!!i.envMapCubeUVHeight||i.bumpMap||i.tangentSpaceNormalMap||i.clearcoatNormalMap||i.flatShading||i.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(i.extensionFragDepth||i.logarithmicDepthBuffer)&&i.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",i.extensionDrawBuffers&&i.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(i.extensionShaderTextureLOD||i.envMap||i.transmission)&&i.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Ls).join(`
`)}function Cx(i){const A=[];for(const t in i){const e=i[t];e!==!1&&A.push("#define "+t+" "+e)}return A.join(`
`)}function Bx(i,A){const t={},e=i.getProgramParameter(A,35721);for(let n=0;n<e;n++){const a=i.getActiveAttrib(A,n),o=a.name;let s=1;a.type===35674&&(s=2),a.type===35675&&(s=3),a.type===35676&&(s=4),t[o]={type:a.type,location:i.getAttribLocation(A,o),locationSize:s}}return t}function Ls(i){return i!==""}function Ih(i,A){const t=A.numSpotLightShadows+A.numSpotLightMaps-A.numSpotLightShadowsWithMaps;return i.replace(/NUM_DIR_LIGHTS/g,A.numDirLights).replace(/NUM_SPOT_LIGHTS/g,A.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,A.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,A.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,A.numPointLights).replace(/NUM_HEMI_LIGHTS/g,A.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,A.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,A.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,A.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,A.numPointLightShadows)}function lh(i,A){return i.replace(/NUM_CLIPPING_PLANES/g,A.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,A.numClippingPlanes-A.numClipIntersection)}const hx=/^[ \t]*#include +<([\w\d./]+)>/gm;function WI(i){return i.replace(hx,cx)}function cx(i,A){const t=ZA[A];if(t===void 0)throw new Error("Can not resolve #include <"+A+">");return WI(t)}const Ex=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Ch(i){return i.replace(Ex,Qx)}function Qx(i,A,t,e){let n="";for(let a=parseInt(A);a<parseInt(t);a++)n+=e.replace(/\[\s*i\s*\]/g,"[ "+a+" ]").replace(/UNROLLED_LOOP_INDEX/g,a);return n}function Bh(i){let A="precision "+i.precision+` float;
precision `+i.precision+" int;";return i.precision==="highp"?A+=`
#define HIGH_PRECISION`:i.precision==="mediump"?A+=`
#define MEDIUM_PRECISION`:i.precision==="lowp"&&(A+=`
#define LOW_PRECISION`),A}function dx(i){let A="SHADOWMAP_TYPE_BASIC";return i.shadowMapType===nE?A="SHADOWMAP_TYPE_PCF":i.shadowMapType===Hm?A="SHADOWMAP_TYPE_PCF_SOFT":i.shadowMapType===Gs&&(A="SHADOWMAP_TYPE_VSM"),A}function fx(i){let A="ENVMAP_TYPE_CUBE";if(i.envMap)switch(i.envMapMode){case es:case is:A="ENVMAP_TYPE_CUBE";break;case Hr:A="ENVMAP_TYPE_CUBE_UV";break}return A}function ux(i){let A="ENVMAP_MODE_REFLECTION";if(i.envMap)switch(i.envMapMode){case is:A="ENVMAP_MODE_REFRACTION";break}return A}function px(i){let A="ENVMAP_BLENDING_NONE";if(i.envMap)switch(i.combine){case ml:A="ENVMAP_BLENDING_MULTIPLY";break;case sy:A="ENVMAP_BLENDING_MIX";break;case oy:A="ENVMAP_BLENDING_ADD";break}return A}function mx(i){const A=i.envMapCubeUVHeight;if(A===null)return null;const t=Math.log2(A)-2,e=1/A;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:e,maxMip:t}}function yx(i,A,t,e){const n=i.getContext(),a=t.defines;let o=t.vertexShader,s=t.fragmentShader;const I=dx(t),r=fx(t),g=ux(t),C=px(t),B=mx(t),c=t.isWebGL2?"":lx(t),Q=Cx(a),h=n.createProgram();let l,E,f=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(l=[Q].filter(Ls).join(`
`),l.length>0&&(l+=`
`),E=[c,Q].filter(Ls).join(`
`),E.length>0&&(E+=`
`)):(l=[Bh(t),"#define SHADER_NAME "+t.shaderName,Q,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+g:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+I:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Ls).join(`
`),E=[c,Bh(t),"#define SHADER_NAME "+t.shaderName,Q,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+r:"",t.envMap?"#define "+g:"",t.envMap?"#define "+C:"",B?"#define CUBEUV_TEXEL_WIDTH "+B.texelWidth:"",B?"#define CUBEUV_TEXEL_HEIGHT "+B.texelHeight:"",B?"#define CUBEUV_MAX_MIP "+B.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+I:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Ni?"#define TONE_MAPPING":"",t.toneMapping!==Ni?ZA.tonemapping_pars_fragment:"",t.toneMapping!==Ni?Ix("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",ZA.encodings_pars_fragment,gx("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Ls).join(`
`)),o=WI(o),o=Ih(o,t),o=lh(o,t),s=WI(s),s=Ih(s,t),s=lh(s,t),o=Ch(o),s=Ch(s),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(f=`#version 300 es
`,l=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+l,E=["#define varying in",t.glslVersion===bB?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===bB?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+E);const u=f+l+o,d=f+E+s,m=rh(n,35633,u),S=rh(n,35632,d);if(n.attachShader(h,m),n.attachShader(h,S),t.index0AttributeName!==void 0?n.bindAttribLocation(h,0,t.index0AttributeName):t.morphTargets===!0&&n.bindAttribLocation(h,0,"position"),n.linkProgram(h),i.debug.checkShaderErrors){const w=n.getProgramInfoLog(h).trim(),M=n.getShaderInfoLog(m).trim(),R=n.getShaderInfoLog(S).trim();let U=!0,N=!0;if(n.getProgramParameter(h,35714)===!1){U=!1;const G=gh(n,m,"vertex"),T=gh(n,S,"fragment");console.error("THREE.WebGLProgram: Shader Error "+n.getError()+" - VALIDATE_STATUS "+n.getProgramParameter(h,35715)+`

Program Info Log: `+w+`
`+G+`
`+T)}else w!==""?console.warn("THREE.WebGLProgram: Program Info Log:",w):(M===""||R==="")&&(N=!1);N&&(this.diagnostics={runnable:U,programLog:w,vertexShader:{log:M,prefix:l},fragmentShader:{log:R,prefix:E}})}n.deleteShader(m),n.deleteShader(S);let D;this.getUniforms=function(){return D===void 0&&(D=new cr(n,h)),D};let p;return this.getAttributes=function(){return p===void 0&&(p=Bx(n,h)),p},this.destroy=function(){e.releaseStatesOfProgram(this),n.deleteProgram(h),this.program=void 0},this.name=t.shaderName,this.id=sx++,this.cacheKey=A,this.usedTimes=1,this.program=h,this.vertexShader=m,this.fragmentShader=S,this}let Dx=0;class Sx{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(A){const t=A.vertexShader,e=A.fragmentShader,n=this._getShaderStage(t),a=this._getShaderStage(e),o=this._getShaderCacheForMaterial(A);return o.has(n)===!1&&(o.add(n),n.usedTimes++),o.has(a)===!1&&(o.add(a),a.usedTimes++),this}remove(A){const t=this.materialCache.get(A);for(const e of t)e.usedTimes--,e.usedTimes===0&&this.shaderCache.delete(e.code);return this.materialCache.delete(A),this}getVertexShaderID(A){return this._getShaderStage(A.vertexShader).id}getFragmentShaderID(A){return this._getShaderStage(A.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(A){const t=this.materialCache;let e=t.get(A);return e===void 0&&(e=new Set,t.set(A,e)),e}_getShaderStage(A){const t=this.shaderCache;let e=t.get(A);return e===void 0&&(e=new wx(A),t.set(A,e)),e}}class wx{constructor(A){this.id=Dx++,this.code=A,this.usedTimes=0}}function _x(i,A,t,e,n,a,o){const s=new EE,I=new Sx,r=[],g=n.isWebGL2,C=n.logarithmicDepthBuffer,B=n.vertexTextures;let c=n.precision;const Q={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function h(p,w,M,R,U){const N=R.fog,G=U.geometry,T=p.isMeshStandardMaterial?R.environment:null,V=(p.isMeshStandardMaterial?t:A).get(p.envMap||T),tA=!!V&&V.mapping===Hr?V.image.height:null,z=Q[p.type];p.precision!==null&&(c=n.getMaxPrecision(p.precision),c!==p.precision&&console.warn("THREE.WebGLProgram.getParameters:",p.precision,"not supported, using",c,"instead."));const W=G.morphAttributes.position||G.morphAttributes.normal||G.morphAttributes.color,Y=W!==void 0?W.length:0;let CA=0;G.morphAttributes.position!==void 0&&(CA=1),G.morphAttributes.normal!==void 0&&(CA=2),G.morphAttributes.color!==void 0&&(CA=3);let K,AA,lA,Z;if(z){const RA=ti[z];K=RA.vertexShader,AA=RA.fragmentShader}else K=p.vertexShader,AA=p.fragmentShader,I.update(p),lA=I.getVertexShaderID(p),Z=I.getFragmentShaderID(p);const oA=i.getRenderTarget(),wA=p.alphaTest>0,uA=p.clearcoat>0,mA=p.iridescence>0;return{isWebGL2:g,shaderID:z,shaderName:p.type,vertexShader:K,fragmentShader:AA,defines:p.defines,customVertexShaderID:lA,customFragmentShaderID:Z,isRawShaderMaterial:p.isRawShaderMaterial===!0,glslVersion:p.glslVersion,precision:c,instancing:U.isInstancedMesh===!0,instancingColor:U.isInstancedMesh===!0&&U.instanceColor!==null,supportsVertexTextures:B,outputEncoding:oA===null?i.outputEncoding:oA.isXRRenderTarget===!0?oA.texture.encoding:Kn,map:!!p.map,matcap:!!p.matcap,envMap:!!V,envMapMode:V&&V.mapping,envMapCubeUVHeight:tA,lightMap:!!p.lightMap,aoMap:!!p.aoMap,emissiveMap:!!p.emissiveMap,bumpMap:!!p.bumpMap,normalMap:!!p.normalMap,objectSpaceNormalMap:p.normalMapType===Fy,tangentSpaceNormalMap:p.normalMapType===gE,decodeVideoTexture:!!p.map&&p.map.isVideoTexture===!0&&p.map.encoding===ht,clearcoat:uA,clearcoatMap:uA&&!!p.clearcoatMap,clearcoatRoughnessMap:uA&&!!p.clearcoatRoughnessMap,clearcoatNormalMap:uA&&!!p.clearcoatNormalMap,iridescence:mA,iridescenceMap:mA&&!!p.iridescenceMap,iridescenceThicknessMap:mA&&!!p.iridescenceThicknessMap,displacementMap:!!p.displacementMap,roughnessMap:!!p.roughnessMap,metalnessMap:!!p.metalnessMap,specularMap:!!p.specularMap,specularIntensityMap:!!p.specularIntensityMap,specularColorMap:!!p.specularColorMap,opaque:p.transparent===!1&&p.blending===Oa,alphaMap:!!p.alphaMap,alphaTest:wA,gradientMap:!!p.gradientMap,sheen:p.sheen>0,sheenColorMap:!!p.sheenColorMap,sheenRoughnessMap:!!p.sheenRoughnessMap,transmission:p.transmission>0,transmissionMap:!!p.transmissionMap,thicknessMap:!!p.thicknessMap,combine:p.combine,vertexTangents:!!p.normalMap&&!!G.attributes.tangent,vertexColors:p.vertexColors,vertexAlphas:p.vertexColors===!0&&!!G.attributes.color&&G.attributes.color.itemSize===4,vertexUvs:!!p.map||!!p.bumpMap||!!p.normalMap||!!p.specularMap||!!p.alphaMap||!!p.emissiveMap||!!p.roughnessMap||!!p.metalnessMap||!!p.clearcoatMap||!!p.clearcoatRoughnessMap||!!p.clearcoatNormalMap||!!p.iridescenceMap||!!p.iridescenceThicknessMap||!!p.displacementMap||!!p.transmissionMap||!!p.thicknessMap||!!p.specularIntensityMap||!!p.specularColorMap||!!p.sheenColorMap||!!p.sheenRoughnessMap,uvsVertexOnly:!(!!p.map||!!p.bumpMap||!!p.normalMap||!!p.specularMap||!!p.alphaMap||!!p.emissiveMap||!!p.roughnessMap||!!p.metalnessMap||!!p.clearcoatNormalMap||!!p.iridescenceMap||!!p.iridescenceThicknessMap||p.transmission>0||!!p.transmissionMap||!!p.thicknessMap||!!p.specularIntensityMap||!!p.specularColorMap||p.sheen>0||!!p.sheenColorMap||!!p.sheenRoughnessMap)&&!!p.displacementMap,fog:!!N,useFog:p.fog===!0,fogExp2:N&&N.isFogExp2,flatShading:!!p.flatShading,sizeAttenuation:p.sizeAttenuation,logarithmicDepthBuffer:C,skinning:U.isSkinnedMesh===!0,morphTargets:G.morphAttributes.position!==void 0,morphNormals:G.morphAttributes.normal!==void 0,morphColors:G.morphAttributes.color!==void 0,morphTargetsCount:Y,morphTextureStride:CA,numDirLights:w.directional.length,numPointLights:w.point.length,numSpotLights:w.spot.length,numSpotLightMaps:w.spotLightMap.length,numRectAreaLights:w.rectArea.length,numHemiLights:w.hemi.length,numDirLightShadows:w.directionalShadowMap.length,numPointLightShadows:w.pointShadowMap.length,numSpotLightShadows:w.spotShadowMap.length,numSpotLightShadowsWithMaps:w.numSpotLightShadowsWithMaps,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:p.dithering,shadowMapEnabled:i.shadowMap.enabled&&M.length>0,shadowMapType:i.shadowMap.type,toneMapping:p.toneMapped?i.toneMapping:Ni,useLegacyLights:i.useLegacyLights,premultipliedAlpha:p.premultipliedAlpha,doubleSided:p.side===ji,flipSided:p.side===ce,useDepthPacking:!!p.depthPacking,depthPacking:p.depthPacking||0,index0AttributeName:p.index0AttributeName,extensionDerivatives:p.extensions&&p.extensions.derivatives,extensionFragDepth:p.extensions&&p.extensions.fragDepth,extensionDrawBuffers:p.extensions&&p.extensions.drawBuffers,extensionShaderTextureLOD:p.extensions&&p.extensions.shaderTextureLOD,rendererExtensionFragDepth:g||e.has("EXT_frag_depth"),rendererExtensionDrawBuffers:g||e.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:g||e.has("EXT_shader_texture_lod"),customProgramCacheKey:p.customProgramCacheKey()}}function l(p){const w=[];if(p.shaderID?w.push(p.shaderID):(w.push(p.customVertexShaderID),w.push(p.customFragmentShaderID)),p.defines!==void 0)for(const M in p.defines)w.push(M),w.push(p.defines[M]);return p.isRawShaderMaterial===!1&&(E(w,p),f(w,p),w.push(i.outputEncoding)),w.push(p.customProgramCacheKey),w.join()}function E(p,w){p.push(w.precision),p.push(w.outputEncoding),p.push(w.envMapMode),p.push(w.envMapCubeUVHeight),p.push(w.combine),p.push(w.vertexUvs),p.push(w.fogExp2),p.push(w.sizeAttenuation),p.push(w.morphTargetsCount),p.push(w.morphAttributeCount),p.push(w.numDirLights),p.push(w.numPointLights),p.push(w.numSpotLights),p.push(w.numSpotLightMaps),p.push(w.numHemiLights),p.push(w.numRectAreaLights),p.push(w.numDirLightShadows),p.push(w.numPointLightShadows),p.push(w.numSpotLightShadows),p.push(w.numSpotLightShadowsWithMaps),p.push(w.shadowMapType),p.push(w.toneMapping),p.push(w.numClippingPlanes),p.push(w.numClipIntersection),p.push(w.depthPacking)}function f(p,w){s.disableAll(),w.isWebGL2&&s.enable(0),w.supportsVertexTextures&&s.enable(1),w.instancing&&s.enable(2),w.instancingColor&&s.enable(3),w.map&&s.enable(4),w.matcap&&s.enable(5),w.envMap&&s.enable(6),w.lightMap&&s.enable(7),w.aoMap&&s.enable(8),w.emissiveMap&&s.enable(9),w.bumpMap&&s.enable(10),w.normalMap&&s.enable(11),w.objectSpaceNormalMap&&s.enable(12),w.tangentSpaceNormalMap&&s.enable(13),w.clearcoat&&s.enable(14),w.clearcoatMap&&s.enable(15),w.clearcoatRoughnessMap&&s.enable(16),w.clearcoatNormalMap&&s.enable(17),w.iridescence&&s.enable(18),w.iridescenceMap&&s.enable(19),w.iridescenceThicknessMap&&s.enable(20),w.displacementMap&&s.enable(21),w.specularMap&&s.enable(22),w.roughnessMap&&s.enable(23),w.metalnessMap&&s.enable(24),w.gradientMap&&s.enable(25),w.alphaMap&&s.enable(26),w.alphaTest&&s.enable(27),w.vertexColors&&s.enable(28),w.vertexAlphas&&s.enable(29),w.vertexUvs&&s.enable(30),w.vertexTangents&&s.enable(31),w.uvsVertexOnly&&s.enable(32),p.push(s.mask),s.disableAll(),w.fog&&s.enable(0),w.useFog&&s.enable(1),w.flatShading&&s.enable(2),w.logarithmicDepthBuffer&&s.enable(3),w.skinning&&s.enable(4),w.morphTargets&&s.enable(5),w.morphNormals&&s.enable(6),w.morphColors&&s.enable(7),w.premultipliedAlpha&&s.enable(8),w.shadowMapEnabled&&s.enable(9),w.useLegacyLights&&s.enable(10),w.doubleSided&&s.enable(11),w.flipSided&&s.enable(12),w.useDepthPacking&&s.enable(13),w.dithering&&s.enable(14),w.specularIntensityMap&&s.enable(15),w.specularColorMap&&s.enable(16),w.transmission&&s.enable(17),w.transmissionMap&&s.enable(18),w.thicknessMap&&s.enable(19),w.sheen&&s.enable(20),w.sheenColorMap&&s.enable(21),w.sheenRoughnessMap&&s.enable(22),w.decodeVideoTexture&&s.enable(23),w.opaque&&s.enable(24),p.push(s.mask)}function u(p){const w=Q[p.type];let M;if(w){const R=ti[w];M=CD.clone(R.uniforms)}else M=p.uniforms;return M}function d(p,w){let M;for(let R=0,U=r.length;R<U;R++){const N=r[R];if(N.cacheKey===w){M=N,++M.usedTimes;break}}return M===void 0&&(M=new yx(i,w,p,a),r.push(M)),M}function m(p){if(--p.usedTimes===0){const w=r.indexOf(p);r[w]=r[r.length-1],r.pop(),p.destroy()}}function S(p){I.remove(p)}function D(){I.dispose()}return{getParameters:h,getProgramCacheKey:l,getUniforms:u,acquireProgram:d,releaseProgram:m,releaseShaderCache:S,programs:r,dispose:D}}function xx(){let i=new WeakMap;function A(a){let o=i.get(a);return o===void 0&&(o={},i.set(a,o)),o}function t(a){i.delete(a)}function e(a,o,s){i.get(a)[o]=s}function n(){i=new WeakMap}return{get:A,remove:t,update:e,dispose:n}}function Mx(i,A){return i.groupOrder!==A.groupOrder?i.groupOrder-A.groupOrder:i.renderOrder!==A.renderOrder?i.renderOrder-A.renderOrder:i.material.id!==A.material.id?i.material.id-A.material.id:i.z!==A.z?i.z-A.z:i.id-A.id}function hh(i,A){return i.groupOrder!==A.groupOrder?i.groupOrder-A.groupOrder:i.renderOrder!==A.renderOrder?i.renderOrder-A.renderOrder:i.z!==A.z?A.z-i.z:i.id-A.id}function ch(){const i=[];let A=0;const t=[],e=[],n=[];function a(){A=0,t.length=0,e.length=0,n.length=0}function o(C,B,c,Q,h,l){let E=i[A];return E===void 0?(E={id:C.id,object:C,geometry:B,material:c,groupOrder:Q,renderOrder:C.renderOrder,z:h,group:l},i[A]=E):(E.id=C.id,E.object=C,E.geometry=B,E.material=c,E.groupOrder=Q,E.renderOrder=C.renderOrder,E.z=h,E.group=l),A++,E}function s(C,B,c,Q,h,l){const E=o(C,B,c,Q,h,l);c.transmission>0?e.push(E):c.transparent===!0?n.push(E):t.push(E)}function I(C,B,c,Q,h,l){const E=o(C,B,c,Q,h,l);c.transmission>0?e.unshift(E):c.transparent===!0?n.unshift(E):t.unshift(E)}function r(C,B){t.length>1&&t.sort(C||Mx),e.length>1&&e.sort(B||hh),n.length>1&&n.sort(B||hh)}function g(){for(let C=A,B=i.length;C<B;C++){const c=i[C];if(c.id===null)break;c.id=null,c.object=null,c.geometry=null,c.material=null,c.group=null}}return{opaque:t,transmissive:e,transparent:n,init:a,push:s,unshift:I,finish:g,sort:r}}function Fx(){let i=new WeakMap;function A(e,n){const a=i.get(e);let o;return a===void 0?(o=new ch,i.set(e,[o])):n>=a.length?(o=new ch,a.push(o)):o=a[n],o}function t(){i=new WeakMap}return{get:A,dispose:t}}function Rx(){const i={};return{get:function(A){if(i[A.id]!==void 0)return i[A.id];let t;switch(A.type){case"DirectionalLight":t={direction:new cA,color:new It};break;case"SpotLight":t={position:new cA,direction:new cA,color:new It,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new cA,color:new It,distance:0,decay:0};break;case"HemisphereLight":t={direction:new cA,skyColor:new It,groundColor:new It};break;case"RectAreaLight":t={color:new It,position:new cA,halfWidth:new cA,halfHeight:new cA};break}return i[A.id]=t,t}}}function vx(){const i={};return{get:function(A){if(i[A.id]!==void 0)return i[A.id];let t;switch(A.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Bt};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Bt};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Bt,shadowCameraNear:1,shadowCameraFar:1e3};break}return i[A.id]=t,t}}}let Gx=0;function Nx(i,A){return(A.castShadow?2:0)-(i.castShadow?2:0)+(A.map?1:0)-(i.map?1:0)}function Lx(i,A){const t=new Rx,e=vx(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let g=0;g<9;g++)n.probe.push(new cA);const a=new cA,o=new xt,s=new xt;function I(g,C){let B=0,c=0,Q=0;for(let R=0;R<9;R++)n.probe[R].set(0,0,0);let h=0,l=0,E=0,f=0,u=0,d=0,m=0,S=0,D=0,p=0;g.sort(Nx);const w=C===!0?Math.PI:1;for(let R=0,U=g.length;R<U;R++){const N=g[R],G=N.color,T=N.intensity,V=N.distance,tA=N.shadow&&N.shadow.map?N.shadow.map.texture:null;if(N.isAmbientLight)B+=G.r*T*w,c+=G.g*T*w,Q+=G.b*T*w;else if(N.isLightProbe)for(let z=0;z<9;z++)n.probe[z].addScaledVector(N.sh.coefficients[z],T);else if(N.isDirectionalLight){const z=t.get(N);if(z.color.copy(N.color).multiplyScalar(N.intensity*w),N.castShadow){const W=N.shadow,Y=e.get(N);Y.shadowBias=W.bias,Y.shadowNormalBias=W.normalBias,Y.shadowRadius=W.radius,Y.shadowMapSize=W.mapSize,n.directionalShadow[h]=Y,n.directionalShadowMap[h]=tA,n.directionalShadowMatrix[h]=N.shadow.matrix,d++}n.directional[h]=z,h++}else if(N.isSpotLight){const z=t.get(N);z.position.setFromMatrixPosition(N.matrixWorld),z.color.copy(G).multiplyScalar(T*w),z.distance=V,z.coneCos=Math.cos(N.angle),z.penumbraCos=Math.cos(N.angle*(1-N.penumbra)),z.decay=N.decay,n.spot[E]=z;const W=N.shadow;if(N.map&&(n.spotLightMap[D]=N.map,D++,W.updateMatrices(N),N.castShadow&&p++),n.spotLightMatrix[E]=W.matrix,N.castShadow){const Y=e.get(N);Y.shadowBias=W.bias,Y.shadowNormalBias=W.normalBias,Y.shadowRadius=W.radius,Y.shadowMapSize=W.mapSize,n.spotShadow[E]=Y,n.spotShadowMap[E]=tA,S++}E++}else if(N.isRectAreaLight){const z=t.get(N);z.color.copy(G).multiplyScalar(T),z.halfWidth.set(N.width*.5,0,0),z.halfHeight.set(0,N.height*.5,0),n.rectArea[f]=z,f++}else if(N.isPointLight){const z=t.get(N);if(z.color.copy(N.color).multiplyScalar(N.intensity*w),z.distance=N.distance,z.decay=N.decay,N.castShadow){const W=N.shadow,Y=e.get(N);Y.shadowBias=W.bias,Y.shadowNormalBias=W.normalBias,Y.shadowRadius=W.radius,Y.shadowMapSize=W.mapSize,Y.shadowCameraNear=W.camera.near,Y.shadowCameraFar=W.camera.far,n.pointShadow[l]=Y,n.pointShadowMap[l]=tA,n.pointShadowMatrix[l]=N.shadow.matrix,m++}n.point[l]=z,l++}else if(N.isHemisphereLight){const z=t.get(N);z.skyColor.copy(N.color).multiplyScalar(T*w),z.groundColor.copy(N.groundColor).multiplyScalar(T*w),n.hemi[u]=z,u++}}f>0&&(A.isWebGL2||i.has("OES_texture_float_linear")===!0?(n.rectAreaLTC1=GA.LTC_FLOAT_1,n.rectAreaLTC2=GA.LTC_FLOAT_2):i.has("OES_texture_half_float_linear")===!0?(n.rectAreaLTC1=GA.LTC_HALF_1,n.rectAreaLTC2=GA.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),n.ambient[0]=B,n.ambient[1]=c,n.ambient[2]=Q;const M=n.hash;(M.directionalLength!==h||M.pointLength!==l||M.spotLength!==E||M.rectAreaLength!==f||M.hemiLength!==u||M.numDirectionalShadows!==d||M.numPointShadows!==m||M.numSpotShadows!==S||M.numSpotMaps!==D)&&(n.directional.length=h,n.spot.length=E,n.rectArea.length=f,n.point.length=l,n.hemi.length=u,n.directionalShadow.length=d,n.directionalShadowMap.length=d,n.pointShadow.length=m,n.pointShadowMap.length=m,n.spotShadow.length=S,n.spotShadowMap.length=S,n.directionalShadowMatrix.length=d,n.pointShadowMatrix.length=m,n.spotLightMatrix.length=S+D-p,n.spotLightMap.length=D,n.numSpotLightShadowsWithMaps=p,M.directionalLength=h,M.pointLength=l,M.spotLength=E,M.rectAreaLength=f,M.hemiLength=u,M.numDirectionalShadows=d,M.numPointShadows=m,M.numSpotShadows=S,M.numSpotMaps=D,n.version=Gx++)}function r(g,C){let B=0,c=0,Q=0,h=0,l=0;const E=C.matrixWorldInverse;for(let f=0,u=g.length;f<u;f++){const d=g[f];if(d.isDirectionalLight){const m=n.directional[B];m.direction.setFromMatrixPosition(d.matrixWorld),a.setFromMatrixPosition(d.target.matrixWorld),m.direction.sub(a),m.direction.transformDirection(E),B++}else if(d.isSpotLight){const m=n.spot[Q];m.position.setFromMatrixPosition(d.matrixWorld),m.position.applyMatrix4(E),m.direction.setFromMatrixPosition(d.matrixWorld),a.setFromMatrixPosition(d.target.matrixWorld),m.direction.sub(a),m.direction.transformDirection(E),Q++}else if(d.isRectAreaLight){const m=n.rectArea[h];m.position.setFromMatrixPosition(d.matrixWorld),m.position.applyMatrix4(E),s.identity(),o.copy(d.matrixWorld),o.premultiply(E),s.extractRotation(o),m.halfWidth.set(d.width*.5,0,0),m.halfHeight.set(0,d.height*.5,0),m.halfWidth.applyMatrix4(s),m.halfHeight.applyMatrix4(s),h++}else if(d.isPointLight){const m=n.point[c];m.position.setFromMatrixPosition(d.matrixWorld),m.position.applyMatrix4(E),c++}else if(d.isHemisphereLight){const m=n.hemi[l];m.direction.setFromMatrixPosition(d.matrixWorld),m.direction.transformDirection(E),l++}}}return{setup:I,setupView:r,state:n}}function Eh(i,A){const t=new Lx(i,A),e=[],n=[];function a(){e.length=0,n.length=0}function o(C){e.push(C)}function s(C){n.push(C)}function I(C){t.setup(e,C)}function r(C){t.setupView(e,C)}return{init:a,state:{lightsArray:e,shadowsArray:n,lights:t},setupLights:I,setupLightsView:r,pushLight:o,pushShadow:s}}function bx(i,A){let t=new WeakMap;function e(a,o=0){const s=t.get(a);let I;return s===void 0?(I=new Eh(i,A),t.set(a,[I])):o>=s.length?(I=new Eh(i,A),s.push(I)):I=s[o],I}function n(){t=new WeakMap}return{get:e,dispose:n}}class Ux extends Io{constructor(A){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=xy,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(A)}copy(A){return super.copy(A),this.depthPacking=A.depthPacking,this.map=A.map,this.alphaMap=A.alphaMap,this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this}}class kx extends Io{constructor(A){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new cA,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(A)}copy(A){return super.copy(A),this.referencePosition.copy(A.referencePosition),this.nearDistance=A.nearDistance,this.farDistance=A.farDistance,this.map=A.map,this.alphaMap=A.alphaMap,this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this}}const Tx=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Hx=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function qx(i,A,t){let e=new yE;const n=new Bt,a=new Bt,o=new Vt,s=new Ux({depthPacking:My}),I=new kx,r={},g=t.maxTextureSize,C={[In]:ce,[ce]:In,[ji]:ji},B=new Wn({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Bt},radius:{value:4}},vertexShader:Tx,fragmentShader:Hx}),c=B.clone();c.defines.HORIZONTAL_PASS=1;const Q=new Bn;Q.setAttribute("position",new We(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const h=new Oe(Q,B),l=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=nE,this.render=function(d,m,S){if(l.enabled===!1||l.autoUpdate===!1&&l.needsUpdate===!1||d.length===0)return;const D=i.getRenderTarget(),p=i.getActiveCubeFace(),w=i.getActiveMipmapLevel(),M=i.state;M.setBlending(an),M.buffers.color.setClear(1,1,1,1),M.buffers.depth.setTest(!0),M.setScissorTest(!1);for(let R=0,U=d.length;R<U;R++){const N=d[R],G=N.shadow;if(G===void 0){console.warn("THREE.WebGLShadowMap:",N,"has no shadow.");continue}if(G.autoUpdate===!1&&G.needsUpdate===!1)continue;n.copy(G.mapSize);const T=G.getFrameExtents();if(n.multiply(T),a.copy(G.mapSize),(n.x>g||n.y>g)&&(n.x>g&&(a.x=Math.floor(g/T.x),n.x=a.x*T.x,G.mapSize.x=a.x),n.y>g&&(a.y=Math.floor(g/T.y),n.y=a.y*T.y,G.mapSize.y=a.y)),G.map===null){const tA=this.type!==Gs?{minFilter:ne,magFilter:ne}:{};G.map=new On(n.x,n.y,tA),G.map.texture.name=N.name+".shadowMap",G.camera.updateProjectionMatrix()}i.setRenderTarget(G.map),i.clear();const V=G.getViewportCount();for(let tA=0;tA<V;tA++){const z=G.getViewport(tA);o.set(a.x*z.x,a.y*z.y,a.x*z.z,a.y*z.w),M.viewport(o),G.updateMatrices(N,tA),e=G.getFrustum(),u(m,S,G.camera,N,this.type)}G.isPointLightShadow!==!0&&this.type===Gs&&E(G,S),G.needsUpdate=!1}l.needsUpdate=!1,i.setRenderTarget(D,p,w)};function E(d,m){const S=A.update(h);B.defines.VSM_SAMPLES!==d.blurSamples&&(B.defines.VSM_SAMPLES=d.blurSamples,c.defines.VSM_SAMPLES=d.blurSamples,B.needsUpdate=!0,c.needsUpdate=!0),d.mapPass===null&&(d.mapPass=new On(n.x,n.y)),B.uniforms.shadow_pass.value=d.map.texture,B.uniforms.resolution.value=d.mapSize,B.uniforms.radius.value=d.radius,i.setRenderTarget(d.mapPass),i.clear(),i.renderBufferDirect(m,null,S,B,h,null),c.uniforms.shadow_pass.value=d.mapPass.texture,c.uniforms.resolution.value=d.mapSize,c.uniforms.radius.value=d.radius,i.setRenderTarget(d.map),i.clear(),i.renderBufferDirect(m,null,S,c,h,null)}function f(d,m,S,D,p,w){let M=null;const R=S.isPointLight===!0?d.customDistanceMaterial:d.customDepthMaterial;if(R!==void 0)M=R;else if(M=S.isPointLight===!0?I:s,i.localClippingEnabled&&m.clipShadows===!0&&Array.isArray(m.clippingPlanes)&&m.clippingPlanes.length!==0||m.displacementMap&&m.displacementScale!==0||m.alphaMap&&m.alphaTest>0||m.map&&m.alphaTest>0){const U=M.uuid,N=m.uuid;let G=r[U];G===void 0&&(G={},r[U]=G);let T=G[N];T===void 0&&(T=M.clone(),G[N]=T),M=T}return M.visible=m.visible,M.wireframe=m.wireframe,w===Gs?M.side=m.shadowSide!==null?m.shadowSide:m.side:M.side=m.shadowSide!==null?m.shadowSide:C[m.side],M.alphaMap=m.alphaMap,M.alphaTest=m.alphaTest,M.map=m.map,M.clipShadows=m.clipShadows,M.clippingPlanes=m.clippingPlanes,M.clipIntersection=m.clipIntersection,M.displacementMap=m.displacementMap,M.displacementScale=m.displacementScale,M.displacementBias=m.displacementBias,M.wireframeLinewidth=m.wireframeLinewidth,M.linewidth=m.linewidth,S.isPointLight===!0&&M.isMeshDistanceMaterial===!0&&(M.referencePosition.setFromMatrixPosition(S.matrixWorld),M.nearDistance=D,M.farDistance=p),M}function u(d,m,S,D,p){if(d.visible===!1)return;if(d.layers.test(m.layers)&&(d.isMesh||d.isLine||d.isPoints)&&(d.castShadow||d.receiveShadow&&p===Gs)&&(!d.frustumCulled||e.intersectsObject(d))){d.modelViewMatrix.multiplyMatrices(S.matrixWorldInverse,d.matrixWorld);const R=A.update(d),U=d.material;if(Array.isArray(U)){const N=R.groups;for(let G=0,T=N.length;G<T;G++){const V=N[G],tA=U[V.materialIndex];if(tA&&tA.visible){const z=f(d,tA,D,S.near,S.far,p);i.renderBufferDirect(S,null,R,z,d,V)}}}else if(U.visible){const N=f(d,U,D,S.near,S.far,p);i.renderBufferDirect(S,null,R,N,d,null)}}const M=d.children;for(let R=0,U=M.length;R<U;R++)u(M[R],m,S,D,p)}}function Jx(i,A,t){const e=t.isWebGL2;function n(){let O=!1;const $=new Vt;let gA=null;const pA=new Vt(0,0,0,0);return{setMask:function(FA){gA!==FA&&!O&&(i.colorMask(FA,FA,FA,FA),gA=FA)},setLocked:function(FA){O=FA},setClear:function(FA,PA,ot,zA,Et){Et===!0&&(FA*=zA,PA*=zA,ot*=zA),$.set(FA,PA,ot,zA),pA.equals($)===!1&&(i.clearColor(FA,PA,ot,zA),pA.copy($))},reset:function(){O=!1,gA=null,pA.set(-1,0,0,0)}}}function a(){let O=!1,$=null,gA=null,pA=null;return{setTest:function(FA){FA?wA(2929):uA(2929)},setMask:function(FA){$!==FA&&!O&&(i.depthMask(FA),$=FA)},setFunc:function(FA){if(gA!==FA){switch(FA){case $m:i.depthFunc(512);break;case Ay:i.depthFunc(519);break;case ty:i.depthFunc(513);break;case kI:i.depthFunc(515);break;case ey:i.depthFunc(514);break;case iy:i.depthFunc(518);break;case ny:i.depthFunc(516);break;case ay:i.depthFunc(517);break;default:i.depthFunc(515)}gA=FA}},setLocked:function(FA){O=FA},setClear:function(FA){pA!==FA&&(i.clearDepth(FA),pA=FA)},reset:function(){O=!1,$=null,gA=null,pA=null}}}function o(){let O=!1,$=null,gA=null,pA=null,FA=null,PA=null,ot=null,zA=null,Et=null;return{setTest:function(tt){O||(tt?wA(2960):uA(2960))},setMask:function(tt){$!==tt&&!O&&(i.stencilMask(tt),$=tt)},setFunc:function(tt,Jt,yt){(gA!==tt||pA!==Jt||FA!==yt)&&(i.stencilFunc(tt,Jt,yt),gA=tt,pA=Jt,FA=yt)},setOp:function(tt,Jt,yt){(PA!==tt||ot!==Jt||zA!==yt)&&(i.stencilOp(tt,Jt,yt),PA=tt,ot=Jt,zA=yt)},setLocked:function(tt){O=tt},setClear:function(tt){Et!==tt&&(i.clearStencil(tt),Et=tt)},reset:function(){O=!1,$=null,gA=null,pA=null,FA=null,PA=null,ot=null,zA=null,Et=null}}}const s=new n,I=new a,r=new o,g=new WeakMap,C=new WeakMap;let B={},c={},Q=new WeakMap,h=[],l=null,E=!1,f=null,u=null,d=null,m=null,S=null,D=null,p=null,w=!1,M=null,R=null,U=null,N=null,G=null;const T=i.getParameter(35661);let V=!1,tA=0;const z=i.getParameter(7938);z.indexOf("WebGL")!==-1?(tA=parseFloat(/^WebGL (\d)/.exec(z)[1]),V=tA>=1):z.indexOf("OpenGL ES")!==-1&&(tA=parseFloat(/^OpenGL ES (\d)/.exec(z)[1]),V=tA>=2);let W=null,Y={};const CA=i.getParameter(3088),K=i.getParameter(2978),AA=new Vt().fromArray(CA),lA=new Vt().fromArray(K);function Z(O,$,gA){const pA=new Uint8Array(4),FA=i.createTexture();i.bindTexture(O,FA),i.texParameteri(O,10241,9728),i.texParameteri(O,10240,9728);for(let PA=0;PA<gA;PA++)i.texImage2D($+PA,0,6408,1,1,0,6408,5121,pA);return FA}const oA={};oA[3553]=Z(3553,3553,1),oA[34067]=Z(34067,34069,6),s.setClear(0,0,0,1),I.setClear(1),r.setClear(0),wA(2929),I.setFunc(kI),JA(!1),YA(aB),wA(2884),TA(an);function wA(O){B[O]!==!0&&(i.enable(O),B[O]=!0)}function uA(O){B[O]!==!1&&(i.disable(O),B[O]=!1)}function mA(O,$){return c[O]!==$?(i.bindFramebuffer(O,$),c[O]=$,e&&(O===36009&&(c[36160]=$),O===36160&&(c[36009]=$)),!0):!1}function fA(O,$){let gA=h,pA=!1;if(O)if(gA=Q.get($),gA===void 0&&(gA=[],Q.set($,gA)),O.isWebGLMultipleRenderTargets){const FA=O.texture;if(gA.length!==FA.length||gA[0]!==36064){for(let PA=0,ot=FA.length;PA<ot;PA++)gA[PA]=36064+PA;gA.length=FA.length,pA=!0}}else gA[0]!==36064&&(gA[0]=36064,pA=!0);else gA[0]!==1029&&(gA[0]=1029,pA=!0);pA&&(t.isWebGL2?i.drawBuffers(gA):A.get("WEBGL_draw_buffers").drawBuffersWEBGL(gA))}function RA(O){return l!==O?(i.useProgram(O),l=O,!0):!1}const MA={[ka]:32774,[Jm]:32778,[Pm]:32779};if(e)MA[gB]=32775,MA[IB]=32776;else{const O=A.get("EXT_blend_minmax");O!==null&&(MA[gB]=O.MIN_EXT,MA[IB]=O.MAX_EXT)}const SA={[Ym]:0,[Km]:1,[Om]:768,[aE]:770,[jm]:776,[Xm]:774,[Vm]:772,[Wm]:769,[sE]:771,[Zm]:775,[zm]:773};function TA(O,$,gA,pA,FA,PA,ot,zA){if(O===an){E===!0&&(uA(3042),E=!1);return}if(E===!1&&(wA(3042),E=!0),O!==qm){if(O!==f||zA!==w){if((u!==ka||S!==ka)&&(i.blendEquation(32774),u=ka,S=ka),zA)switch(O){case Oa:i.blendFuncSeparate(1,771,1,771);break;case sB:i.blendFunc(1,1);break;case oB:i.blendFuncSeparate(0,769,0,1);break;case rB:i.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",O);break}else switch(O){case Oa:i.blendFuncSeparate(770,771,1,771);break;case sB:i.blendFunc(770,1);break;case oB:i.blendFuncSeparate(0,769,0,1);break;case rB:i.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",O);break}d=null,m=null,D=null,p=null,f=O,w=zA}return}FA=FA||$,PA=PA||gA,ot=ot||pA,($!==u||FA!==S)&&(i.blendEquationSeparate(MA[$],MA[FA]),u=$,S=FA),(gA!==d||pA!==m||PA!==D||ot!==p)&&(i.blendFuncSeparate(SA[gA],SA[pA],SA[PA],SA[ot]),d=gA,m=pA,D=PA,p=ot),f=O,w=!1}function OA(O,$){O.side===ji?uA(2884):wA(2884);let gA=O.side===ce;$&&(gA=!gA),JA(gA),O.blending===Oa&&O.transparent===!1?TA(an):TA(O.blending,O.blendEquation,O.blendSrc,O.blendDst,O.blendEquationAlpha,O.blendSrcAlpha,O.blendDstAlpha,O.premultipliedAlpha),I.setFunc(O.depthFunc),I.setTest(O.depthTest),I.setMask(O.depthWrite),s.setMask(O.colorWrite);const pA=O.stencilWrite;r.setTest(pA),pA&&(r.setMask(O.stencilWriteMask),r.setFunc(O.stencilFunc,O.stencilRef,O.stencilFuncMask),r.setOp(O.stencilFail,O.stencilZFail,O.stencilZPass)),kA(O.polygonOffset,O.polygonOffsetFactor,O.polygonOffsetUnits),O.alphaToCoverage===!0?wA(32926):uA(32926)}function JA(O){M!==O&&(O?i.frontFace(2304):i.frontFace(2305),M=O)}function YA(O){O!==km?(wA(2884),O!==R&&(O===aB?i.cullFace(1029):O===Tm?i.cullFace(1028):i.cullFace(1032))):uA(2884),R=O}function HA(O){O!==U&&(V&&i.lineWidth(O),U=O)}function kA(O,$,gA){O?(wA(32823),(N!==$||G!==gA)&&(i.polygonOffset($,gA),N=$,G=gA)):uA(32823)}function rt(O){O?wA(3089):uA(3089)}function $A(O){O===void 0&&(O=33984+T-1),W!==O&&(i.activeTexture(O),W=O)}function x(O,$,gA){gA===void 0&&(W===null?gA=33984+T-1:gA=W);let pA=Y[gA];pA===void 0&&(pA={type:void 0,texture:void 0},Y[gA]=pA),(pA.type!==O||pA.texture!==$)&&(W!==gA&&(i.activeTexture(gA),W=gA),i.bindTexture(O,$||oA[O]),pA.type=O,pA.texture=$)}function y(){const O=Y[W];O!==void 0&&O.type!==void 0&&(i.bindTexture(O.type,null),O.type=void 0,O.texture=void 0)}function b(){try{i.compressedTexImage2D.apply(i,arguments)}catch(O){console.error("THREE.WebGLState:",O)}}function X(){try{i.compressedTexImage3D.apply(i,arguments)}catch(O){console.error("THREE.WebGLState:",O)}}function j(){try{i.texSubImage2D.apply(i,arguments)}catch(O){console.error("THREE.WebGLState:",O)}}function eA(){try{i.texSubImage3D.apply(i,arguments)}catch(O){console.error("THREE.WebGLState:",O)}}function sA(){try{i.compressedTexSubImage2D.apply(i,arguments)}catch(O){console.error("THREE.WebGLState:",O)}}function L(){try{i.compressedTexSubImage3D.apply(i,arguments)}catch(O){console.error("THREE.WebGLState:",O)}}function k(){try{i.texStorage2D.apply(i,arguments)}catch(O){console.error("THREE.WebGLState:",O)}}function hA(){try{i.texStorage3D.apply(i,arguments)}catch(O){console.error("THREE.WebGLState:",O)}}function BA(){try{i.texImage2D.apply(i,arguments)}catch(O){console.error("THREE.WebGLState:",O)}}function EA(){try{i.texImage3D.apply(i,arguments)}catch(O){console.error("THREE.WebGLState:",O)}}function dA(O){AA.equals(O)===!1&&(i.scissor(O.x,O.y,O.z,O.w),AA.copy(O))}function yA(O){lA.equals(O)===!1&&(i.viewport(O.x,O.y,O.z,O.w),lA.copy(O))}function bA(O,$){let gA=C.get($);gA===void 0&&(gA=new WeakMap,C.set($,gA));let pA=gA.get(O);pA===void 0&&(pA=i.getUniformBlockIndex($,O.name),gA.set(O,pA))}function nA(O,$){const pA=C.get($).get(O);g.get($)!==pA&&(i.uniformBlockBinding($,pA,O.__bindingPointIndex),g.set($,pA))}function xA(){i.disable(3042),i.disable(2884),i.disable(2929),i.disable(32823),i.disable(3089),i.disable(2960),i.disable(32926),i.blendEquation(32774),i.blendFunc(1,0),i.blendFuncSeparate(1,0,1,0),i.colorMask(!0,!0,!0,!0),i.clearColor(0,0,0,0),i.depthMask(!0),i.depthFunc(513),i.clearDepth(1),i.stencilMask(4294967295),i.stencilFunc(519,0,4294967295),i.stencilOp(7680,7680,7680),i.clearStencil(0),i.cullFace(1029),i.frontFace(2305),i.polygonOffset(0,0),i.activeTexture(33984),i.bindFramebuffer(36160,null),e===!0&&(i.bindFramebuffer(36009,null),i.bindFramebuffer(36008,null)),i.useProgram(null),i.lineWidth(1),i.scissor(0,0,i.canvas.width,i.canvas.height),i.viewport(0,0,i.canvas.width,i.canvas.height),B={},W=null,Y={},c={},Q=new WeakMap,h=[],l=null,E=!1,f=null,u=null,d=null,m=null,S=null,D=null,p=null,w=!1,M=null,R=null,U=null,N=null,G=null,AA.set(0,0,i.canvas.width,i.canvas.height),lA.set(0,0,i.canvas.width,i.canvas.height),s.reset(),I.reset(),r.reset()}return{buffers:{color:s,depth:I,stencil:r},enable:wA,disable:uA,bindFramebuffer:mA,drawBuffers:fA,useProgram:RA,setBlending:TA,setMaterial:OA,setFlipSided:JA,setCullFace:YA,setLineWidth:HA,setPolygonOffset:kA,setScissorTest:rt,activeTexture:$A,bindTexture:x,unbindTexture:y,compressedTexImage2D:b,compressedTexImage3D:X,texImage2D:BA,texImage3D:EA,updateUBOMapping:bA,uniformBlockBinding:nA,texStorage2D:k,texStorage3D:hA,texSubImage2D:j,texSubImage3D:eA,compressedTexSubImage2D:sA,compressedTexSubImage3D:L,scissor:dA,viewport:yA,reset:xA}}function Px(i,A,t,e,n,a,o){const s=n.isWebGL2,I=n.maxTextures,r=n.maxCubemapSize,g=n.maxTextureSize,C=n.maxSamples,B=A.has("WEBGL_multisampled_render_to_texture")?A.get("WEBGL_multisampled_render_to_texture"):null,c=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),Q=new WeakMap;let h;const l=new WeakMap;let E=!1;try{E=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function f(x,y){return E?new OffscreenCanvas(x,y):wr("canvas")}function u(x,y,b,X){let j=1;if((x.width>X||x.height>X)&&(j=X/Math.max(x.width,x.height)),j<1||y===!0)if(typeof HTMLImageElement<"u"&&x instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&x instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&x instanceof ImageBitmap){const eA=y?lE:Math.floor,sA=eA(j*x.width),L=eA(j*x.height);h===void 0&&(h=f(sA,L));const k=b?f(sA,L):h;return k.width=sA,k.height=L,k.getContext("2d").drawImage(x,0,0,sA,L),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+x.width+"x"+x.height+") to ("+sA+"x"+L+")."),k}else return"data"in x&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+x.width+"x"+x.height+")."),x;return x}function d(x){return KI(x.width)&&KI(x.height)}function m(x){return s?!1:x.wrapS!==Fe||x.wrapT!==Fe||x.minFilter!==ne&&x.minFilter!==te}function S(x,y){return x.generateMipmaps&&y&&x.minFilter!==ne&&x.minFilter!==te}function D(x){i.generateMipmap(x)}function p(x,y,b,X,j=!1){if(s===!1)return y;if(x!==null){if(i[x]!==void 0)return i[x];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+x+"'")}let eA=y;return y===6403&&(b===5126&&(eA=33326),b===5131&&(eA=33325),b===5121&&(eA=33321)),y===33319&&(b===5126&&(eA=33328),b===5131&&(eA=33327),b===5121&&(eA=33323)),y===6408&&(b===5126&&(eA=34836),b===5131&&(eA=34842),b===5121&&(eA=X===ht&&j===!1?35907:32856),b===32819&&(eA=32854),b===32820&&(eA=32855)),(eA===33325||eA===33326||eA===33327||eA===33328||eA===34842||eA===34836)&&A.get("EXT_color_buffer_float"),eA}function w(x,y,b){return S(x,b)===!0||x.isFramebufferTexture&&x.minFilter!==ne&&x.minFilter!==te?Math.log2(Math.max(y.width,y.height))+1:x.mipmaps!==void 0&&x.mipmaps.length>0?x.mipmaps.length:x.isCompressedTexture&&Array.isArray(x.image)?y.mipmaps.length:1}function M(x){return x===ne||x===lB||x===xg?9728:9729}function R(x){const y=x.target;y.removeEventListener("dispose",R),N(y),y.isVideoTexture&&Q.delete(y)}function U(x){const y=x.target;y.removeEventListener("dispose",U),T(y)}function N(x){const y=e.get(x);if(y.__webglInit===void 0)return;const b=x.source,X=l.get(b);if(X){const j=X[y.__cacheKey];j.usedTimes--,j.usedTimes===0&&G(x),Object.keys(X).length===0&&l.delete(b)}e.remove(x)}function G(x){const y=e.get(x);i.deleteTexture(y.__webglTexture);const b=x.source,X=l.get(b);delete X[y.__cacheKey],o.memory.textures--}function T(x){const y=x.texture,b=e.get(x),X=e.get(y);if(X.__webglTexture!==void 0&&(i.deleteTexture(X.__webglTexture),o.memory.textures--),x.depthTexture&&x.depthTexture.dispose(),x.isWebGLCubeRenderTarget)for(let j=0;j<6;j++)i.deleteFramebuffer(b.__webglFramebuffer[j]),b.__webglDepthbuffer&&i.deleteRenderbuffer(b.__webglDepthbuffer[j]);else{if(i.deleteFramebuffer(b.__webglFramebuffer),b.__webglDepthbuffer&&i.deleteRenderbuffer(b.__webglDepthbuffer),b.__webglMultisampledFramebuffer&&i.deleteFramebuffer(b.__webglMultisampledFramebuffer),b.__webglColorRenderbuffer)for(let j=0;j<b.__webglColorRenderbuffer.length;j++)b.__webglColorRenderbuffer[j]&&i.deleteRenderbuffer(b.__webglColorRenderbuffer[j]);b.__webglDepthRenderbuffer&&i.deleteRenderbuffer(b.__webglDepthRenderbuffer)}if(x.isWebGLMultipleRenderTargets)for(let j=0,eA=y.length;j<eA;j++){const sA=e.get(y[j]);sA.__webglTexture&&(i.deleteTexture(sA.__webglTexture),o.memory.textures--),e.remove(y[j])}e.remove(y),e.remove(x)}let V=0;function tA(){V=0}function z(){const x=V;return x>=I&&console.warn("THREE.WebGLTextures: Trying to use "+x+" texture units while this GPU supports only "+I),V+=1,x}function W(x){const y=[];return y.push(x.wrapS),y.push(x.wrapT),y.push(x.wrapR||0),y.push(x.magFilter),y.push(x.minFilter),y.push(x.anisotropy),y.push(x.internalFormat),y.push(x.format),y.push(x.type),y.push(x.generateMipmaps),y.push(x.premultiplyAlpha),y.push(x.flipY),y.push(x.unpackAlignment),y.push(x.encoding),y.join()}function Y(x,y){const b=e.get(x);if(x.isVideoTexture&&rt(x),x.isRenderTargetTexture===!1&&x.version>0&&b.__version!==x.version){const X=x.image;if(X===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(X.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{uA(b,x,y);return}}t.bindTexture(3553,b.__webglTexture,33984+y)}function CA(x,y){const b=e.get(x);if(x.version>0&&b.__version!==x.version){uA(b,x,y);return}t.bindTexture(35866,b.__webglTexture,33984+y)}function K(x,y){const b=e.get(x);if(x.version>0&&b.__version!==x.version){uA(b,x,y);return}t.bindTexture(32879,b.__webglTexture,33984+y)}function AA(x,y){const b=e.get(x);if(x.version>0&&b.__version!==x.version){mA(b,x,y);return}t.bindTexture(34067,b.__webglTexture,33984+y)}const lA={[qI]:10497,[Fe]:33071,[JI]:33648},Z={[ne]:9728,[lB]:9984,[xg]:9986,[te]:9729,[By]:9985,[Ws]:9987};function oA(x,y,b){if(b?(i.texParameteri(x,10242,lA[y.wrapS]),i.texParameteri(x,10243,lA[y.wrapT]),(x===32879||x===35866)&&i.texParameteri(x,32882,lA[y.wrapR]),i.texParameteri(x,10240,Z[y.magFilter]),i.texParameteri(x,10241,Z[y.minFilter])):(i.texParameteri(x,10242,33071),i.texParameteri(x,10243,33071),(x===32879||x===35866)&&i.texParameteri(x,32882,33071),(y.wrapS!==Fe||y.wrapT!==Fe)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),i.texParameteri(x,10240,M(y.magFilter)),i.texParameteri(x,10241,M(y.minFilter)),y.minFilter!==ne&&y.minFilter!==te&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),A.has("EXT_texture_filter_anisotropic")===!0){const X=A.get("EXT_texture_filter_anisotropic");if(y.magFilter===ne||y.minFilter!==xg&&y.minFilter!==Ws||y.type===vn&&A.has("OES_texture_float_linear")===!1||s===!1&&y.type===Vs&&A.has("OES_texture_half_float_linear")===!1)return;(y.anisotropy>1||e.get(y).__currentAnisotropy)&&(i.texParameterf(x,X.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(y.anisotropy,n.getMaxAnisotropy())),e.get(y).__currentAnisotropy=y.anisotropy)}}function wA(x,y){let b=!1;x.__webglInit===void 0&&(x.__webglInit=!0,y.addEventListener("dispose",R));const X=y.source;let j=l.get(X);j===void 0&&(j={},l.set(X,j));const eA=W(y);if(eA!==x.__cacheKey){j[eA]===void 0&&(j[eA]={texture:i.createTexture(),usedTimes:0},o.memory.textures++,b=!0),j[eA].usedTimes++;const sA=j[x.__cacheKey];sA!==void 0&&(j[x.__cacheKey].usedTimes--,sA.usedTimes===0&&G(y)),x.__cacheKey=eA,x.__webglTexture=j[eA].texture}return b}function uA(x,y,b){let X=3553;(y.isDataArrayTexture||y.isCompressedArrayTexture)&&(X=35866),y.isData3DTexture&&(X=32879);const j=wA(x,y),eA=y.source;t.bindTexture(X,x.__webglTexture,33984+b);const sA=e.get(eA);if(eA.version!==sA.__version||j===!0){t.activeTexture(33984+b),i.pixelStorei(37440,y.flipY),i.pixelStorei(37441,y.premultiplyAlpha),i.pixelStorei(3317,y.unpackAlignment),i.pixelStorei(37443,0);const L=m(y)&&d(y.image)===!1;let k=u(y.image,L,!1,g);k=$A(y,k);const hA=d(k)||s,BA=a.convert(y.format,y.encoding);let EA=a.convert(y.type),dA=p(y.internalFormat,BA,EA,y.encoding,y.isVideoTexture);oA(X,y,hA);let yA;const bA=y.mipmaps,nA=s&&y.isVideoTexture!==!0,xA=sA.__version===void 0||j===!0,O=w(y,k,hA);if(y.isDepthTexture)dA=6402,s?y.type===vn?dA=36012:y.type===Rn?dA=33190:y.type===Wa?dA=35056:dA=33189:y.type===vn&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),y.format===Un&&dA===6402&&y.type!==rE&&y.type!==Rn&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),y.type=Rn,EA=a.convert(y.type)),y.format===ns&&dA===6402&&(dA=34041,y.type!==Wa&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),y.type=Wa,EA=a.convert(y.type))),xA&&(nA?t.texStorage2D(3553,1,dA,k.width,k.height):t.texImage2D(3553,0,dA,k.width,k.height,0,BA,EA,null));else if(y.isDataTexture)if(bA.length>0&&hA){nA&&xA&&t.texStorage2D(3553,O,dA,bA[0].width,bA[0].height);for(let $=0,gA=bA.length;$<gA;$++)yA=bA[$],nA?t.texSubImage2D(3553,$,0,0,yA.width,yA.height,BA,EA,yA.data):t.texImage2D(3553,$,dA,yA.width,yA.height,0,BA,EA,yA.data);y.generateMipmaps=!1}else nA?(xA&&t.texStorage2D(3553,O,dA,k.width,k.height),t.texSubImage2D(3553,0,0,0,k.width,k.height,BA,EA,k.data)):t.texImage2D(3553,0,dA,k.width,k.height,0,BA,EA,k.data);else if(y.isCompressedTexture)if(y.isCompressedArrayTexture){nA&&xA&&t.texStorage3D(35866,O,dA,bA[0].width,bA[0].height,k.depth);for(let $=0,gA=bA.length;$<gA;$++)yA=bA[$],y.format!==Ke?BA!==null?nA?t.compressedTexSubImage3D(35866,$,0,0,0,yA.width,yA.height,k.depth,BA,yA.data,0,0):t.compressedTexImage3D(35866,$,dA,yA.width,yA.height,k.depth,0,yA.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):nA?t.texSubImage3D(35866,$,0,0,0,yA.width,yA.height,k.depth,BA,EA,yA.data):t.texImage3D(35866,$,dA,yA.width,yA.height,k.depth,0,BA,EA,yA.data)}else{nA&&xA&&t.texStorage2D(3553,O,dA,bA[0].width,bA[0].height);for(let $=0,gA=bA.length;$<gA;$++)yA=bA[$],y.format!==Ke?BA!==null?nA?t.compressedTexSubImage2D(3553,$,0,0,yA.width,yA.height,BA,yA.data):t.compressedTexImage2D(3553,$,dA,yA.width,yA.height,0,yA.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):nA?t.texSubImage2D(3553,$,0,0,yA.width,yA.height,BA,EA,yA.data):t.texImage2D(3553,$,dA,yA.width,yA.height,0,BA,EA,yA.data)}else if(y.isDataArrayTexture)nA?(xA&&t.texStorage3D(35866,O,dA,k.width,k.height,k.depth),t.texSubImage3D(35866,0,0,0,0,k.width,k.height,k.depth,BA,EA,k.data)):t.texImage3D(35866,0,dA,k.width,k.height,k.depth,0,BA,EA,k.data);else if(y.isData3DTexture)nA?(xA&&t.texStorage3D(32879,O,dA,k.width,k.height,k.depth),t.texSubImage3D(32879,0,0,0,0,k.width,k.height,k.depth,BA,EA,k.data)):t.texImage3D(32879,0,dA,k.width,k.height,k.depth,0,BA,EA,k.data);else if(y.isFramebufferTexture){if(xA)if(nA)t.texStorage2D(3553,O,dA,k.width,k.height);else{let $=k.width,gA=k.height;for(let pA=0;pA<O;pA++)t.texImage2D(3553,pA,dA,$,gA,0,BA,EA,null),$>>=1,gA>>=1}}else if(bA.length>0&&hA){nA&&xA&&t.texStorage2D(3553,O,dA,bA[0].width,bA[0].height);for(let $=0,gA=bA.length;$<gA;$++)yA=bA[$],nA?t.texSubImage2D(3553,$,0,0,BA,EA,yA):t.texImage2D(3553,$,dA,BA,EA,yA);y.generateMipmaps=!1}else nA?(xA&&t.texStorage2D(3553,O,dA,k.width,k.height),t.texSubImage2D(3553,0,0,0,BA,EA,k)):t.texImage2D(3553,0,dA,BA,EA,k);S(y,hA)&&D(X),sA.__version=eA.version,y.onUpdate&&y.onUpdate(y)}x.__version=y.version}function mA(x,y,b){if(y.image.length!==6)return;const X=wA(x,y),j=y.source;t.bindTexture(34067,x.__webglTexture,33984+b);const eA=e.get(j);if(j.version!==eA.__version||X===!0){t.activeTexture(33984+b),i.pixelStorei(37440,y.flipY),i.pixelStorei(37441,y.premultiplyAlpha),i.pixelStorei(3317,y.unpackAlignment),i.pixelStorei(37443,0);const sA=y.isCompressedTexture||y.image[0].isCompressedTexture,L=y.image[0]&&y.image[0].isDataTexture,k=[];for(let $=0;$<6;$++)!sA&&!L?k[$]=u(y.image[$],!1,!0,r):k[$]=L?y.image[$].image:y.image[$],k[$]=$A(y,k[$]);const hA=k[0],BA=d(hA)||s,EA=a.convert(y.format,y.encoding),dA=a.convert(y.type),yA=p(y.internalFormat,EA,dA,y.encoding),bA=s&&y.isVideoTexture!==!0,nA=eA.__version===void 0||X===!0;let xA=w(y,hA,BA);oA(34067,y,BA);let O;if(sA){bA&&nA&&t.texStorage2D(34067,xA,yA,hA.width,hA.height);for(let $=0;$<6;$++){O=k[$].mipmaps;for(let gA=0;gA<O.length;gA++){const pA=O[gA];y.format!==Ke?EA!==null?bA?t.compressedTexSubImage2D(34069+$,gA,0,0,pA.width,pA.height,EA,pA.data):t.compressedTexImage2D(34069+$,gA,yA,pA.width,pA.height,0,pA.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):bA?t.texSubImage2D(34069+$,gA,0,0,pA.width,pA.height,EA,dA,pA.data):t.texImage2D(34069+$,gA,yA,pA.width,pA.height,0,EA,dA,pA.data)}}}else{O=y.mipmaps,bA&&nA&&(O.length>0&&xA++,t.texStorage2D(34067,xA,yA,k[0].width,k[0].height));for(let $=0;$<6;$++)if(L){bA?t.texSubImage2D(34069+$,0,0,0,k[$].width,k[$].height,EA,dA,k[$].data):t.texImage2D(34069+$,0,yA,k[$].width,k[$].height,0,EA,dA,k[$].data);for(let gA=0;gA<O.length;gA++){const FA=O[gA].image[$].image;bA?t.texSubImage2D(34069+$,gA+1,0,0,FA.width,FA.height,EA,dA,FA.data):t.texImage2D(34069+$,gA+1,yA,FA.width,FA.height,0,EA,dA,FA.data)}}else{bA?t.texSubImage2D(34069+$,0,0,0,EA,dA,k[$]):t.texImage2D(34069+$,0,yA,EA,dA,k[$]);for(let gA=0;gA<O.length;gA++){const pA=O[gA];bA?t.texSubImage2D(34069+$,gA+1,0,0,EA,dA,pA.image[$]):t.texImage2D(34069+$,gA+1,yA,EA,dA,pA.image[$])}}}S(y,BA)&&D(34067),eA.__version=j.version,y.onUpdate&&y.onUpdate(y)}x.__version=y.version}function fA(x,y,b,X,j){const eA=a.convert(b.format,b.encoding),sA=a.convert(b.type),L=p(b.internalFormat,eA,sA,b.encoding);e.get(y).__hasExternalTextures||(j===32879||j===35866?t.texImage3D(j,0,L,y.width,y.height,y.depth,0,eA,sA,null):t.texImage2D(j,0,L,y.width,y.height,0,eA,sA,null)),t.bindFramebuffer(36160,x),kA(y)?B.framebufferTexture2DMultisampleEXT(36160,X,j,e.get(b).__webglTexture,0,HA(y)):(j===3553||j>=34069&&j<=34074)&&i.framebufferTexture2D(36160,X,j,e.get(b).__webglTexture,0),t.bindFramebuffer(36160,null)}function RA(x,y,b){if(i.bindRenderbuffer(36161,x),y.depthBuffer&&!y.stencilBuffer){let X=33189;if(b||kA(y)){const j=y.depthTexture;j&&j.isDepthTexture&&(j.type===vn?X=36012:j.type===Rn&&(X=33190));const eA=HA(y);kA(y)?B.renderbufferStorageMultisampleEXT(36161,eA,X,y.width,y.height):i.renderbufferStorageMultisample(36161,eA,X,y.width,y.height)}else i.renderbufferStorage(36161,X,y.width,y.height);i.framebufferRenderbuffer(36160,36096,36161,x)}else if(y.depthBuffer&&y.stencilBuffer){const X=HA(y);b&&kA(y)===!1?i.renderbufferStorageMultisample(36161,X,35056,y.width,y.height):kA(y)?B.renderbufferStorageMultisampleEXT(36161,X,35056,y.width,y.height):i.renderbufferStorage(36161,34041,y.width,y.height),i.framebufferRenderbuffer(36160,33306,36161,x)}else{const X=y.isWebGLMultipleRenderTargets===!0?y.texture:[y.texture];for(let j=0;j<X.length;j++){const eA=X[j],sA=a.convert(eA.format,eA.encoding),L=a.convert(eA.type),k=p(eA.internalFormat,sA,L,eA.encoding),hA=HA(y);b&&kA(y)===!1?i.renderbufferStorageMultisample(36161,hA,k,y.width,y.height):kA(y)?B.renderbufferStorageMultisampleEXT(36161,hA,k,y.width,y.height):i.renderbufferStorage(36161,k,y.width,y.height)}}i.bindRenderbuffer(36161,null)}function MA(x,y){if(y&&y.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,x),!(y.depthTexture&&y.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!e.get(y.depthTexture).__webglTexture||y.depthTexture.image.width!==y.width||y.depthTexture.image.height!==y.height)&&(y.depthTexture.image.width=y.width,y.depthTexture.image.height=y.height,y.depthTexture.needsUpdate=!0),Y(y.depthTexture,0);const X=e.get(y.depthTexture).__webglTexture,j=HA(y);if(y.depthTexture.format===Un)kA(y)?B.framebufferTexture2DMultisampleEXT(36160,36096,3553,X,0,j):i.framebufferTexture2D(36160,36096,3553,X,0);else if(y.depthTexture.format===ns)kA(y)?B.framebufferTexture2DMultisampleEXT(36160,33306,3553,X,0,j):i.framebufferTexture2D(36160,33306,3553,X,0);else throw new Error("Unknown depthTexture format")}function SA(x){const y=e.get(x),b=x.isWebGLCubeRenderTarget===!0;if(x.depthTexture&&!y.__autoAllocateDepthBuffer){if(b)throw new Error("target.depthTexture not supported in Cube render targets");MA(y.__webglFramebuffer,x)}else if(b){y.__webglDepthbuffer=[];for(let X=0;X<6;X++)t.bindFramebuffer(36160,y.__webglFramebuffer[X]),y.__webglDepthbuffer[X]=i.createRenderbuffer(),RA(y.__webglDepthbuffer[X],x,!1)}else t.bindFramebuffer(36160,y.__webglFramebuffer),y.__webglDepthbuffer=i.createRenderbuffer(),RA(y.__webglDepthbuffer,x,!1);t.bindFramebuffer(36160,null)}function TA(x,y,b){const X=e.get(x);y!==void 0&&fA(X.__webglFramebuffer,x,x.texture,36064,3553),b!==void 0&&SA(x)}function OA(x){const y=x.texture,b=e.get(x),X=e.get(y);x.addEventListener("dispose",U),x.isWebGLMultipleRenderTargets!==!0&&(X.__webglTexture===void 0&&(X.__webglTexture=i.createTexture()),X.__version=y.version,o.memory.textures++);const j=x.isWebGLCubeRenderTarget===!0,eA=x.isWebGLMultipleRenderTargets===!0,sA=d(x)||s;if(j){b.__webglFramebuffer=[];for(let L=0;L<6;L++)b.__webglFramebuffer[L]=i.createFramebuffer()}else{if(b.__webglFramebuffer=i.createFramebuffer(),eA)if(n.drawBuffers){const L=x.texture;for(let k=0,hA=L.length;k<hA;k++){const BA=e.get(L[k]);BA.__webglTexture===void 0&&(BA.__webglTexture=i.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(s&&x.samples>0&&kA(x)===!1){const L=eA?y:[y];b.__webglMultisampledFramebuffer=i.createFramebuffer(),b.__webglColorRenderbuffer=[],t.bindFramebuffer(36160,b.__webglMultisampledFramebuffer);for(let k=0;k<L.length;k++){const hA=L[k];b.__webglColorRenderbuffer[k]=i.createRenderbuffer(),i.bindRenderbuffer(36161,b.__webglColorRenderbuffer[k]);const BA=a.convert(hA.format,hA.encoding),EA=a.convert(hA.type),dA=p(hA.internalFormat,BA,EA,hA.encoding,x.isXRRenderTarget===!0),yA=HA(x);i.renderbufferStorageMultisample(36161,yA,dA,x.width,x.height),i.framebufferRenderbuffer(36160,36064+k,36161,b.__webglColorRenderbuffer[k])}i.bindRenderbuffer(36161,null),x.depthBuffer&&(b.__webglDepthRenderbuffer=i.createRenderbuffer(),RA(b.__webglDepthRenderbuffer,x,!0)),t.bindFramebuffer(36160,null)}}if(j){t.bindTexture(34067,X.__webglTexture),oA(34067,y,sA);for(let L=0;L<6;L++)fA(b.__webglFramebuffer[L],x,y,36064,34069+L);S(y,sA)&&D(34067),t.unbindTexture()}else if(eA){const L=x.texture;for(let k=0,hA=L.length;k<hA;k++){const BA=L[k],EA=e.get(BA);t.bindTexture(3553,EA.__webglTexture),oA(3553,BA,sA),fA(b.__webglFramebuffer,x,BA,36064+k,3553),S(BA,sA)&&D(3553)}t.unbindTexture()}else{let L=3553;(x.isWebGL3DRenderTarget||x.isWebGLArrayRenderTarget)&&(s?L=x.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(L,X.__webglTexture),oA(L,y,sA),fA(b.__webglFramebuffer,x,y,36064,L),S(y,sA)&&D(L),t.unbindTexture()}x.depthBuffer&&SA(x)}function JA(x){const y=d(x)||s,b=x.isWebGLMultipleRenderTargets===!0?x.texture:[x.texture];for(let X=0,j=b.length;X<j;X++){const eA=b[X];if(S(eA,y)){const sA=x.isWebGLCubeRenderTarget?34067:3553,L=e.get(eA).__webglTexture;t.bindTexture(sA,L),D(sA),t.unbindTexture()}}}function YA(x){if(s&&x.samples>0&&kA(x)===!1){const y=x.isWebGLMultipleRenderTargets?x.texture:[x.texture],b=x.width,X=x.height;let j=16384;const eA=[],sA=x.stencilBuffer?33306:36096,L=e.get(x),k=x.isWebGLMultipleRenderTargets===!0;if(k)for(let hA=0;hA<y.length;hA++)t.bindFramebuffer(36160,L.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(36160,36064+hA,36161,null),t.bindFramebuffer(36160,L.__webglFramebuffer),i.framebufferTexture2D(36009,36064+hA,3553,null,0);t.bindFramebuffer(36008,L.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,L.__webglFramebuffer);for(let hA=0;hA<y.length;hA++){eA.push(36064+hA),x.depthBuffer&&eA.push(sA);const BA=L.__ignoreDepthValues!==void 0?L.__ignoreDepthValues:!1;if(BA===!1&&(x.depthBuffer&&(j|=256),x.stencilBuffer&&(j|=1024)),k&&i.framebufferRenderbuffer(36008,36064,36161,L.__webglColorRenderbuffer[hA]),BA===!0&&(i.invalidateFramebuffer(36008,[sA]),i.invalidateFramebuffer(36009,[sA])),k){const EA=e.get(y[hA]).__webglTexture;i.framebufferTexture2D(36009,36064,3553,EA,0)}i.blitFramebuffer(0,0,b,X,0,0,b,X,j,9728),c&&i.invalidateFramebuffer(36008,eA)}if(t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,null),k)for(let hA=0;hA<y.length;hA++){t.bindFramebuffer(36160,L.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(36160,36064+hA,36161,L.__webglColorRenderbuffer[hA]);const BA=e.get(y[hA]).__webglTexture;t.bindFramebuffer(36160,L.__webglFramebuffer),i.framebufferTexture2D(36009,36064+hA,3553,BA,0)}t.bindFramebuffer(36009,L.__webglMultisampledFramebuffer)}}function HA(x){return Math.min(C,x.samples)}function kA(x){const y=e.get(x);return s&&x.samples>0&&A.has("WEBGL_multisampled_render_to_texture")===!0&&y.__useRenderToTexture!==!1}function rt(x){const y=o.render.frame;Q.get(x)!==y&&(Q.set(x,y),x.update())}function $A(x,y){const b=x.encoding,X=x.format,j=x.type;return x.isCompressedTexture===!0||x.isVideoTexture===!0||x.format===YI||b!==Kn&&(b===ht?s===!1?A.has("EXT_sRGB")===!0&&X===Ke?(x.format=YI,x.minFilter=te,x.generateMipmaps=!1):y=BE.sRGBToLinear(y):(X!==Ke||j!==Yn)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",b)),y}this.allocateTextureUnit=z,this.resetTextureUnits=tA,this.setTexture2D=Y,this.setTexture2DArray=CA,this.setTexture3D=K,this.setTextureCube=AA,this.rebindTextures=TA,this.setupRenderTarget=OA,this.updateRenderTargetMipmap=JA,this.updateMultisampleRenderTarget=YA,this.setupDepthRenderbuffer=SA,this.setupFrameBufferTexture=fA,this.useMultisampledRTT=kA}function Yx(i,A,t){const e=t.isWebGL2;function n(a,o=null){let s;if(a===Yn)return 5121;if(a===Qy)return 32819;if(a===dy)return 32820;if(a===hy)return 5120;if(a===cy)return 5122;if(a===rE)return 5123;if(a===Ey)return 5124;if(a===Rn)return 5125;if(a===vn)return 5126;if(a===Vs)return e?5131:(s=A.get("OES_texture_half_float"),s!==null?s.HALF_FLOAT_OES:null);if(a===fy)return 6406;if(a===Ke)return 6408;if(a===uy)return 6409;if(a===py)return 6410;if(a===Un)return 6402;if(a===ns)return 34041;if(a===YI)return s=A.get("EXT_sRGB"),s!==null?s.SRGB_ALPHA_EXT:null;if(a===PI)return 6403;if(a===my)return 36244;if(a===yy)return 33319;if(a===Dy)return 33320;if(a===Sy)return 36249;if(a===Mg||a===Fg||a===Rg||a===vg)if(o===ht)if(s=A.get("WEBGL_compressed_texture_s3tc_srgb"),s!==null){if(a===Mg)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(a===Fg)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(a===Rg)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(a===vg)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(s=A.get("WEBGL_compressed_texture_s3tc"),s!==null){if(a===Mg)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(a===Fg)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(a===Rg)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(a===vg)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(a===CB||a===BB||a===hB||a===cB)if(s=A.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(a===CB)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(a===BB)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(a===hB)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(a===cB)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(a===wy)return s=A.get("WEBGL_compressed_texture_etc1"),s!==null?s.COMPRESSED_RGB_ETC1_WEBGL:null;if(a===EB||a===QB)if(s=A.get("WEBGL_compressed_texture_etc"),s!==null){if(a===EB)return o===ht?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(a===QB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(a===dB||a===fB||a===uB||a===pB||a===mB||a===yB||a===DB||a===SB||a===wB||a===_B||a===xB||a===MB||a===FB||a===RB)if(s=A.get("WEBGL_compressed_texture_astc"),s!==null){if(a===dB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(a===fB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(a===uB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(a===pB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(a===mB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(a===yB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(a===DB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(a===SB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(a===wB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(a===_B)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(a===xB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(a===MB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(a===FB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(a===RB)return o===ht?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(a===Gg)if(s=A.get("EXT_texture_compression_bptc"),s!==null){if(a===Gg)return o===ht?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;if(a===_y||a===vB||a===GB||a===NB)if(s=A.get("EXT_texture_compression_rgtc"),s!==null){if(a===Gg)return s.COMPRESSED_RED_RGTC1_EXT;if(a===vB)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(a===GB)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(a===NB)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return a===Wa?e?34042:(s=A.get("WEBGL_depth_texture"),s!==null?s.UNSIGNED_INT_24_8_WEBGL:null):i[a]!==void 0?i[a]:null}return{convert:n}}class Kx extends Ye{constructor(A=[]){super(),this.isArrayCamera=!0,this.cameras=A}}class Ja extends De{constructor(){super(),this.isGroup=!0,this.type="Group"}}const Ox={type:"move"};class iI{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Ja,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Ja,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new cA,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new cA),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Ja,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new cA,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new cA),this._grip}dispatchEvent(A){return this._targetRay!==null&&this._targetRay.dispatchEvent(A),this._grip!==null&&this._grip.dispatchEvent(A),this._hand!==null&&this._hand.dispatchEvent(A),this}connect(A){if(A&&A.hand){const t=this._hand;if(t)for(const e of A.hand.values())this._getHandJoint(t,e)}return this.dispatchEvent({type:"connected",data:A}),this}disconnect(A){return this.dispatchEvent({type:"disconnected",data:A}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(A,t,e){let n=null,a=null,o=null;const s=this._targetRay,I=this._grip,r=this._hand;if(A&&t.session.visibilityState!=="visible-blurred"){if(r&&A.hand){o=!0;for(const h of A.hand.values()){const l=t.getJointPose(h,e),E=this._getHandJoint(r,h);l!==null&&(E.matrix.fromArray(l.transform.matrix),E.matrix.decompose(E.position,E.rotation,E.scale),E.jointRadius=l.radius),E.visible=l!==null}const g=r.joints["index-finger-tip"],C=r.joints["thumb-tip"],B=g.position.distanceTo(C.position),c=.02,Q=.005;r.inputState.pinching&&B>c+Q?(r.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:A.handedness,target:this})):!r.inputState.pinching&&B<=c-Q&&(r.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:A.handedness,target:this}))}else I!==null&&A.gripSpace&&(a=t.getPose(A.gripSpace,e),a!==null&&(I.matrix.fromArray(a.transform.matrix),I.matrix.decompose(I.position,I.rotation,I.scale),a.linearVelocity?(I.hasLinearVelocity=!0,I.linearVelocity.copy(a.linearVelocity)):I.hasLinearVelocity=!1,a.angularVelocity?(I.hasAngularVelocity=!0,I.angularVelocity.copy(a.angularVelocity)):I.hasAngularVelocity=!1));s!==null&&(n=t.getPose(A.targetRaySpace,e),n===null&&a!==null&&(n=a),n!==null&&(s.matrix.fromArray(n.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),n.linearVelocity?(s.hasLinearVelocity=!0,s.linearVelocity.copy(n.linearVelocity)):s.hasLinearVelocity=!1,n.angularVelocity?(s.hasAngularVelocity=!0,s.angularVelocity.copy(n.angularVelocity)):s.hasAngularVelocity=!1,this.dispatchEvent(Ox)))}return s!==null&&(s.visible=n!==null),I!==null&&(I.visible=a!==null),r!==null&&(r.visible=o!==null),this}_getHandJoint(A,t){if(A.joints[t.jointName]===void 0){const e=new Ja;e.matrixAutoUpdate=!1,e.visible=!1,A.joints[t.jointName]=e,A.add(e)}return A.joints[t.jointName]}}class Wx extends Ee{constructor(A,t,e,n,a,o,s,I,r,g){if(g=g!==void 0?g:Un,g!==Un&&g!==ns)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");e===void 0&&g===Un&&(e=Rn),e===void 0&&g===ns&&(e=Wa),super(null,n,a,o,s,I,g,e,r),this.isDepthTexture=!0,this.image={width:A,height:t},this.magFilter=s!==void 0?s:ne,this.minFilter=I!==void 0?I:ne,this.flipY=!1,this.generateMipmaps=!1}}class Vx extends rs{constructor(A,t){super();const e=this;let n=null,a=1,o=null,s="local-floor",I=1,r=null,g=null,C=null,B=null,c=null,Q=null;const h=t.getContextAttributes();let l=null,E=null;const f=[],u=[],d=new Set,m=new Map,S=new Ye;S.layers.enable(1),S.viewport=new Vt;const D=new Ye;D.layers.enable(2),D.viewport=new Vt;const p=[S,D],w=new Kx;w.layers.enable(1),w.layers.enable(2);let M=null,R=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(K){let AA=f[K];return AA===void 0&&(AA=new iI,f[K]=AA),AA.getTargetRaySpace()},this.getControllerGrip=function(K){let AA=f[K];return AA===void 0&&(AA=new iI,f[K]=AA),AA.getGripSpace()},this.getHand=function(K){let AA=f[K];return AA===void 0&&(AA=new iI,f[K]=AA),AA.getHandSpace()};function U(K){const AA=u.indexOf(K.inputSource);if(AA===-1)return;const lA=f[AA];lA!==void 0&&lA.dispatchEvent({type:K.type,data:K.inputSource})}function N(){n.removeEventListener("select",U),n.removeEventListener("selectstart",U),n.removeEventListener("selectend",U),n.removeEventListener("squeeze",U),n.removeEventListener("squeezestart",U),n.removeEventListener("squeezeend",U),n.removeEventListener("end",N),n.removeEventListener("inputsourceschange",G);for(let K=0;K<f.length;K++){const AA=u[K];AA!==null&&(u[K]=null,f[K].disconnect(AA))}M=null,R=null,A.setRenderTarget(l),c=null,B=null,C=null,n=null,E=null,CA.stop(),e.isPresenting=!1,e.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(K){a=K,e.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(K){s=K,e.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return r||o},this.setReferenceSpace=function(K){r=K},this.getBaseLayer=function(){return B!==null?B:c},this.getBinding=function(){return C},this.getFrame=function(){return Q},this.getSession=function(){return n},this.setSession=async function(K){if(n=K,n!==null){if(l=A.getRenderTarget(),n.addEventListener("select",U),n.addEventListener("selectstart",U),n.addEventListener("selectend",U),n.addEventListener("squeeze",U),n.addEventListener("squeezestart",U),n.addEventListener("squeezeend",U),n.addEventListener("end",N),n.addEventListener("inputsourceschange",G),h.xrCompatible!==!0&&await t.makeXRCompatible(),n.renderState.layers===void 0||A.capabilities.isWebGL2===!1){const AA={antialias:n.renderState.layers===void 0?h.antialias:!0,alpha:h.alpha,depth:h.depth,stencil:h.stencil,framebufferScaleFactor:a};c=new XRWebGLLayer(n,t,AA),n.updateRenderState({baseLayer:c}),E=new On(c.framebufferWidth,c.framebufferHeight,{format:Ke,type:Yn,encoding:A.outputEncoding,stencilBuffer:h.stencil})}else{let AA=null,lA=null,Z=null;h.depth&&(Z=h.stencil?35056:33190,AA=h.stencil?ns:Un,lA=h.stencil?Wa:Rn);const oA={colorFormat:32856,depthFormat:Z,scaleFactor:a};C=new XRWebGLBinding(n,t),B=C.createProjectionLayer(oA),n.updateRenderState({layers:[B]}),E=new On(B.textureWidth,B.textureHeight,{format:Ke,type:Yn,depthTexture:new Wx(B.textureWidth,B.textureHeight,lA,void 0,void 0,void 0,void 0,void 0,void 0,AA),stencilBuffer:h.stencil,encoding:A.outputEncoding,samples:h.antialias?4:0});const wA=A.properties.get(E);wA.__ignoreDepthValues=B.ignoreDepthValues}E.isXRRenderTarget=!0,this.setFoveation(I),r=null,o=await n.requestReferenceSpace(s),CA.setContext(n),CA.start(),e.isPresenting=!0,e.dispatchEvent({type:"sessionstart"})}};function G(K){for(let AA=0;AA<K.removed.length;AA++){const lA=K.removed[AA],Z=u.indexOf(lA);Z>=0&&(u[Z]=null,f[Z].disconnect(lA))}for(let AA=0;AA<K.added.length;AA++){const lA=K.added[AA];let Z=u.indexOf(lA);if(Z===-1){for(let wA=0;wA<f.length;wA++)if(wA>=u.length){u.push(lA),Z=wA;break}else if(u[wA]===null){u[wA]=lA,Z=wA;break}if(Z===-1)break}const oA=f[Z];oA&&oA.connect(lA)}}const T=new cA,V=new cA;function tA(K,AA,lA){T.setFromMatrixPosition(AA.matrixWorld),V.setFromMatrixPosition(lA.matrixWorld);const Z=T.distanceTo(V),oA=AA.projectionMatrix.elements,wA=lA.projectionMatrix.elements,uA=oA[14]/(oA[10]-1),mA=oA[14]/(oA[10]+1),fA=(oA[9]+1)/oA[5],RA=(oA[9]-1)/oA[5],MA=(oA[8]-1)/oA[0],SA=(wA[8]+1)/wA[0],TA=uA*MA,OA=uA*SA,JA=Z/(-MA+SA),YA=JA*-MA;AA.matrixWorld.decompose(K.position,K.quaternion,K.scale),K.translateX(YA),K.translateZ(JA),K.matrixWorld.compose(K.position,K.quaternion,K.scale),K.matrixWorldInverse.copy(K.matrixWorld).invert();const HA=uA+JA,kA=mA+JA,rt=TA-YA,$A=OA+(Z-YA),x=fA*mA/kA*HA,y=RA*mA/kA*HA;K.projectionMatrix.makePerspective(rt,$A,x,y,HA,kA)}function z(K,AA){AA===null?K.matrixWorld.copy(K.matrix):K.matrixWorld.multiplyMatrices(AA.matrixWorld,K.matrix),K.matrixWorldInverse.copy(K.matrixWorld).invert()}this.updateCamera=function(K){if(n===null)return;w.near=D.near=S.near=K.near,w.far=D.far=S.far=K.far,(M!==w.near||R!==w.far)&&(n.updateRenderState({depthNear:w.near,depthFar:w.far}),M=w.near,R=w.far);const AA=K.parent,lA=w.cameras;z(w,AA);for(let oA=0;oA<lA.length;oA++)z(lA[oA],AA);w.matrixWorld.decompose(w.position,w.quaternion,w.scale),K.matrix.copy(w.matrix),K.matrix.decompose(K.position,K.quaternion,K.scale);const Z=K.children;for(let oA=0,wA=Z.length;oA<wA;oA++)Z[oA].updateMatrixWorld(!0);lA.length===2?tA(w,S,D):w.projectionMatrix.copy(S.projectionMatrix)},this.getCamera=function(){return w},this.getFoveation=function(){if(!(B===null&&c===null))return I},this.setFoveation=function(K){I=K,B!==null&&(B.fixedFoveation=K),c!==null&&c.fixedFoveation!==void 0&&(c.fixedFoveation=K)},this.getPlanes=function(){return d};let W=null;function Y(K,AA){if(g=AA.getViewerPose(r||o),Q=AA,g!==null){const lA=g.views;c!==null&&(A.setRenderTargetFramebuffer(E,c.framebuffer),A.setRenderTarget(E));let Z=!1;lA.length!==w.cameras.length&&(w.cameras.length=0,Z=!0);for(let oA=0;oA<lA.length;oA++){const wA=lA[oA];let uA=null;if(c!==null)uA=c.getViewport(wA);else{const fA=C.getViewSubImage(B,wA);uA=fA.viewport,oA===0&&(A.setRenderTargetTextures(E,fA.colorTexture,B.ignoreDepthValues?void 0:fA.depthStencilTexture),A.setRenderTarget(E))}let mA=p[oA];mA===void 0&&(mA=new Ye,mA.layers.enable(oA),mA.viewport=new Vt,p[oA]=mA),mA.matrix.fromArray(wA.transform.matrix),mA.projectionMatrix.fromArray(wA.projectionMatrix),mA.viewport.set(uA.x,uA.y,uA.width,uA.height),oA===0&&w.matrix.copy(mA.matrix),Z===!0&&w.cameras.push(mA)}}for(let lA=0;lA<f.length;lA++){const Z=u[lA],oA=f[lA];Z!==null&&oA!==void 0&&oA.update(Z,AA,r||o)}if(W&&W(K,AA),AA.detectedPlanes){e.dispatchEvent({type:"planesdetected",data:AA.detectedPlanes});let lA=null;for(const Z of d)AA.detectedPlanes.has(Z)||(lA===null&&(lA=[]),lA.push(Z));if(lA!==null)for(const Z of lA)d.delete(Z),m.delete(Z),e.dispatchEvent({type:"planeremoved",data:Z});for(const Z of AA.detectedPlanes)if(!d.has(Z))d.add(Z),m.set(Z,AA.lastChangedTime),e.dispatchEvent({type:"planeadded",data:Z});else{const oA=m.get(Z);Z.lastChangedTime>oA&&(m.set(Z,Z.lastChangedTime),e.dispatchEvent({type:"planechanged",data:Z}))}}Q=null}const CA=new DE;CA.setAnimationLoop(Y),this.setAnimationLoop=function(K){W=K},this.dispose=function(){}}}function zx(i,A){function t(h,l){l.color.getRGB(h.fogColor.value,uE(i)),l.isFog?(h.fogNear.value=l.near,h.fogFar.value=l.far):l.isFogExp2&&(h.fogDensity.value=l.density)}function e(h,l,E,f,u){l.isMeshBasicMaterial||l.isMeshLambertMaterial?n(h,l):l.isMeshToonMaterial?(n(h,l),g(h,l)):l.isMeshPhongMaterial?(n(h,l),r(h,l)):l.isMeshStandardMaterial?(n(h,l),C(h,l),l.isMeshPhysicalMaterial&&B(h,l,u)):l.isMeshMatcapMaterial?(n(h,l),c(h,l)):l.isMeshDepthMaterial?n(h,l):l.isMeshDistanceMaterial?(n(h,l),Q(h,l)):l.isMeshNormalMaterial?n(h,l):l.isLineBasicMaterial?(a(h,l),l.isLineDashedMaterial&&o(h,l)):l.isPointsMaterial?s(h,l,E,f):l.isSpriteMaterial?I(h,l):l.isShadowMaterial?(h.color.value.copy(l.color),h.opacity.value=l.opacity):l.isShaderMaterial&&(l.uniformsNeedUpdate=!1)}function n(h,l){h.opacity.value=l.opacity,l.color&&h.diffuse.value.copy(l.color),l.emissive&&h.emissive.value.copy(l.emissive).multiplyScalar(l.emissiveIntensity),l.map&&(h.map.value=l.map),l.alphaMap&&(h.alphaMap.value=l.alphaMap),l.bumpMap&&(h.bumpMap.value=l.bumpMap,h.bumpScale.value=l.bumpScale,l.side===ce&&(h.bumpScale.value*=-1)),l.displacementMap&&(h.displacementMap.value=l.displacementMap,h.displacementScale.value=l.displacementScale,h.displacementBias.value=l.displacementBias),l.emissiveMap&&(h.emissiveMap.value=l.emissiveMap),l.normalMap&&(h.normalMap.value=l.normalMap,h.normalScale.value.copy(l.normalScale),l.side===ce&&h.normalScale.value.negate()),l.specularMap&&(h.specularMap.value=l.specularMap),l.alphaTest>0&&(h.alphaTest.value=l.alphaTest);const E=A.get(l).envMap;if(E&&(h.envMap.value=E,h.flipEnvMap.value=E.isCubeTexture&&E.isRenderTargetTexture===!1?-1:1,h.reflectivity.value=l.reflectivity,h.ior.value=l.ior,h.refractionRatio.value=l.refractionRatio),l.lightMap){h.lightMap.value=l.lightMap;const d=i.useLegacyLights===!0?Math.PI:1;h.lightMapIntensity.value=l.lightMapIntensity*d}l.aoMap&&(h.aoMap.value=l.aoMap,h.aoMapIntensity.value=l.aoMapIntensity);let f;l.map?f=l.map:l.specularMap?f=l.specularMap:l.displacementMap?f=l.displacementMap:l.normalMap?f=l.normalMap:l.bumpMap?f=l.bumpMap:l.roughnessMap?f=l.roughnessMap:l.metalnessMap?f=l.metalnessMap:l.alphaMap?f=l.alphaMap:l.emissiveMap?f=l.emissiveMap:l.clearcoatMap?f=l.clearcoatMap:l.clearcoatNormalMap?f=l.clearcoatNormalMap:l.clearcoatRoughnessMap?f=l.clearcoatRoughnessMap:l.iridescenceMap?f=l.iridescenceMap:l.iridescenceThicknessMap?f=l.iridescenceThicknessMap:l.specularIntensityMap?f=l.specularIntensityMap:l.specularColorMap?f=l.specularColorMap:l.transmissionMap?f=l.transmissionMap:l.thicknessMap?f=l.thicknessMap:l.sheenColorMap?f=l.sheenColorMap:l.sheenRoughnessMap&&(f=l.sheenRoughnessMap),f!==void 0&&(f.isWebGLRenderTarget&&(f=f.texture),f.matrixAutoUpdate===!0&&f.updateMatrix(),h.uvTransform.value.copy(f.matrix));let u;l.aoMap?u=l.aoMap:l.lightMap&&(u=l.lightMap),u!==void 0&&(u.isWebGLRenderTarget&&(u=u.texture),u.matrixAutoUpdate===!0&&u.updateMatrix(),h.uv2Transform.value.copy(u.matrix))}function a(h,l){h.diffuse.value.copy(l.color),h.opacity.value=l.opacity}function o(h,l){h.dashSize.value=l.dashSize,h.totalSize.value=l.dashSize+l.gapSize,h.scale.value=l.scale}function s(h,l,E,f){h.diffuse.value.copy(l.color),h.opacity.value=l.opacity,h.size.value=l.size*E,h.scale.value=f*.5,l.map&&(h.map.value=l.map),l.alphaMap&&(h.alphaMap.value=l.alphaMap),l.alphaTest>0&&(h.alphaTest.value=l.alphaTest);let u;l.map?u=l.map:l.alphaMap&&(u=l.alphaMap),u!==void 0&&(u.matrixAutoUpdate===!0&&u.updateMatrix(),h.uvTransform.value.copy(u.matrix))}function I(h,l){h.diffuse.value.copy(l.color),h.opacity.value=l.opacity,h.rotation.value=l.rotation,l.map&&(h.map.value=l.map),l.alphaMap&&(h.alphaMap.value=l.alphaMap),l.alphaTest>0&&(h.alphaTest.value=l.alphaTest);let E;l.map?E=l.map:l.alphaMap&&(E=l.alphaMap),E!==void 0&&(E.matrixAutoUpdate===!0&&E.updateMatrix(),h.uvTransform.value.copy(E.matrix))}function r(h,l){h.specular.value.copy(l.specular),h.shininess.value=Math.max(l.shininess,1e-4)}function g(h,l){l.gradientMap&&(h.gradientMap.value=l.gradientMap)}function C(h,l){h.roughness.value=l.roughness,h.metalness.value=l.metalness,l.roughnessMap&&(h.roughnessMap.value=l.roughnessMap),l.metalnessMap&&(h.metalnessMap.value=l.metalnessMap),A.get(l).envMap&&(h.envMapIntensity.value=l.envMapIntensity)}function B(h,l,E){h.ior.value=l.ior,l.sheen>0&&(h.sheenColor.value.copy(l.sheenColor).multiplyScalar(l.sheen),h.sheenRoughness.value=l.sheenRoughness,l.sheenColorMap&&(h.sheenColorMap.value=l.sheenColorMap),l.sheenRoughnessMap&&(h.sheenRoughnessMap.value=l.sheenRoughnessMap)),l.clearcoat>0&&(h.clearcoat.value=l.clearcoat,h.clearcoatRoughness.value=l.clearcoatRoughness,l.clearcoatMap&&(h.clearcoatMap.value=l.clearcoatMap),l.clearcoatRoughnessMap&&(h.clearcoatRoughnessMap.value=l.clearcoatRoughnessMap),l.clearcoatNormalMap&&(h.clearcoatNormalScale.value.copy(l.clearcoatNormalScale),h.clearcoatNormalMap.value=l.clearcoatNormalMap,l.side===ce&&h.clearcoatNormalScale.value.negate())),l.iridescence>0&&(h.iridescence.value=l.iridescence,h.iridescenceIOR.value=l.iridescenceIOR,h.iridescenceThicknessMinimum.value=l.iridescenceThicknessRange[0],h.iridescenceThicknessMaximum.value=l.iridescenceThicknessRange[1],l.iridescenceMap&&(h.iridescenceMap.value=l.iridescenceMap),l.iridescenceThicknessMap&&(h.iridescenceThicknessMap.value=l.iridescenceThicknessMap)),l.transmission>0&&(h.transmission.value=l.transmission,h.transmissionSamplerMap.value=E.texture,h.transmissionSamplerSize.value.set(E.width,E.height),l.transmissionMap&&(h.transmissionMap.value=l.transmissionMap),h.thickness.value=l.thickness,l.thicknessMap&&(h.thicknessMap.value=l.thicknessMap),h.attenuationDistance.value=l.attenuationDistance,h.attenuationColor.value.copy(l.attenuationColor)),h.specularIntensity.value=l.specularIntensity,h.specularColor.value.copy(l.specularColor),l.specularIntensityMap&&(h.specularIntensityMap.value=l.specularIntensityMap),l.specularColorMap&&(h.specularColorMap.value=l.specularColorMap)}function c(h,l){l.matcap&&(h.matcap.value=l.matcap)}function Q(h,l){h.referencePosition.value.copy(l.referencePosition),h.nearDistance.value=l.nearDistance,h.farDistance.value=l.farDistance}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function Xx(i,A,t,e){let n={},a={},o=[];const s=t.isWebGL2?i.getParameter(35375):0;function I(f,u){const d=u.program;e.uniformBlockBinding(f,d)}function r(f,u){let d=n[f.id];d===void 0&&(Q(f),d=g(f),n[f.id]=d,f.addEventListener("dispose",l));const m=u.program;e.updateUBOMapping(f,m);const S=A.render.frame;a[f.id]!==S&&(B(f),a[f.id]=S)}function g(f){const u=C();f.__bindingPointIndex=u;const d=i.createBuffer(),m=f.__size,S=f.usage;return i.bindBuffer(35345,d),i.bufferData(35345,m,S),i.bindBuffer(35345,null),i.bindBufferBase(35345,u,d),d}function C(){for(let f=0;f<s;f++)if(o.indexOf(f)===-1)return o.push(f),f;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function B(f){const u=n[f.id],d=f.uniforms,m=f.__cache;i.bindBuffer(35345,u);for(let S=0,D=d.length;S<D;S++){const p=d[S];if(c(p,S,m)===!0){const w=p.__offset,M=Array.isArray(p.value)?p.value:[p.value];let R=0;for(let U=0;U<M.length;U++){const N=M[U],G=h(N);typeof N=="number"?(p.__data[0]=N,i.bufferSubData(35345,w+R,p.__data)):N.isMatrix3?(p.__data[0]=N.elements[0],p.__data[1]=N.elements[1],p.__data[2]=N.elements[2],p.__data[3]=N.elements[0],p.__data[4]=N.elements[3],p.__data[5]=N.elements[4],p.__data[6]=N.elements[5],p.__data[7]=N.elements[0],p.__data[8]=N.elements[6],p.__data[9]=N.elements[7],p.__data[10]=N.elements[8],p.__data[11]=N.elements[0]):(N.toArray(p.__data,R),R+=G.storage/Float32Array.BYTES_PER_ELEMENT)}i.bufferSubData(35345,w,p.__data)}}i.bindBuffer(35345,null)}function c(f,u,d){const m=f.value;if(d[u]===void 0){if(typeof m=="number")d[u]=m;else{const S=Array.isArray(m)?m:[m],D=[];for(let p=0;p<S.length;p++)D.push(S[p].clone());d[u]=D}return!0}else if(typeof m=="number"){if(d[u]!==m)return d[u]=m,!0}else{const S=Array.isArray(d[u])?d[u]:[d[u]],D=Array.isArray(m)?m:[m];for(let p=0;p<S.length;p++){const w=S[p];if(w.equals(D[p])===!1)return w.copy(D[p]),!0}}return!1}function Q(f){const u=f.uniforms;let d=0;const m=16;let S=0;for(let D=0,p=u.length;D<p;D++){const w=u[D],M={boundary:0,storage:0},R=Array.isArray(w.value)?w.value:[w.value];for(let U=0,N=R.length;U<N;U++){const G=R[U],T=h(G);M.boundary+=T.boundary,M.storage+=T.storage}if(w.__data=new Float32Array(M.storage/Float32Array.BYTES_PER_ELEMENT),w.__offset=d,D>0){S=d%m;const U=m-S;S!==0&&U-M.boundary<0&&(d+=m-S,w.__offset=d)}d+=M.storage}return S=d%m,S>0&&(d+=m-S),f.__size=d,f.__cache={},this}function h(f){const u={boundary:0,storage:0};return typeof f=="number"?(u.boundary=4,u.storage=4):f.isVector2?(u.boundary=8,u.storage=8):f.isVector3||f.isColor?(u.boundary=16,u.storage=12):f.isVector4?(u.boundary=16,u.storage=16):f.isMatrix3?(u.boundary=48,u.storage=48):f.isMatrix4?(u.boundary=64,u.storage=64):f.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",f),u}function l(f){const u=f.target;u.removeEventListener("dispose",l);const d=o.indexOf(u.__bindingPointIndex);o.splice(d,1),i.deleteBuffer(n[u.id]),delete n[u.id],delete a[u.id]}function E(){for(const f in n)i.deleteBuffer(n[f]);o=[],n={},a={}}return{bind:I,update:r,dispose:E}}function Zx(){const i=wr("canvas");return i.style.display="block",i}function ME(i={}){this.isWebGLRenderer=!0;const A=i.canvas!==void 0?i.canvas:Zx(),t=i.context!==void 0?i.context:null,e=i.depth!==void 0?i.depth:!0,n=i.stencil!==void 0?i.stencil:!0,a=i.antialias!==void 0?i.antialias:!1,o=i.premultipliedAlpha!==void 0?i.premultipliedAlpha:!0,s=i.preserveDrawingBuffer!==void 0?i.preserveDrawingBuffer:!1,I=i.powerPreference!==void 0?i.powerPreference:"default",r=i.failIfMajorPerformanceCaveat!==void 0?i.failIfMajorPerformanceCaveat:!1;let g;t!==null?g=t.getContextAttributes().alpha:g=i.alpha!==void 0?i.alpha:!1;let C=null,B=null;const c=[],Q=[];this.domElement=A,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=Kn,this.useLegacyLights=!0,this.toneMapping=Ni,this.toneMappingExposure=1;const h=this;let l=!1,E=0,f=0,u=null,d=-1,m=null;const S=new Vt,D=new Vt;let p=null,w=A.width,M=A.height,R=1,U=null,N=null;const G=new Vt(0,0,w,M),T=new Vt(0,0,w,M);let V=!1;const tA=new yE;let z=!1,W=!1,Y=null;const CA=new xt,K=new cA,AA={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function lA(){return u===null?R:1}let Z=t;function oA(H,F){for(let J=0;J<H.length;J++){const q=H[J],_=A.getContext(q,F);if(_!==null)return _}return null}try{const H={alpha:!0,depth:e,stencil:n,antialias:a,premultipliedAlpha:o,preserveDrawingBuffer:s,powerPreference:I,failIfMajorPerformanceCaveat:r};if("setAttribute"in A&&A.setAttribute("data-engine",`three.js r${pl}`),A.addEventListener("webglcontextlost",EA,!1),A.addEventListener("webglcontextrestored",dA,!1),A.addEventListener("webglcontextcreationerror",yA,!1),Z===null){const F=["webgl2","webgl","experimental-webgl"];if(h.isWebGL1Renderer===!0&&F.shift(),Z=oA(F,H),Z===null)throw oA(F)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}Z.getShaderPrecisionFormat===void 0&&(Z.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(H){throw console.error("THREE.WebGLRenderer: "+H.message),H}let wA,uA,mA,fA,RA,MA,SA,TA,OA,JA,YA,HA,kA,rt,$A,x,y,b,X,j,eA,sA,L,k;function hA(){wA=new r_(Z),uA=new t_(Z,wA,i),wA.init(uA),sA=new Yx(Z,wA,uA),mA=new Jx(Z,wA,uA),fA=new l_,RA=new xx,MA=new Px(Z,wA,mA,RA,uA,sA,fA),SA=new i_(h),TA=new o_(h),OA=new fD(Z,uA),L=new $w(Z,wA,OA,uA),JA=new g_(Z,OA,fA,L),YA=new c_(Z,JA,OA,fA),X=new h_(Z,uA,MA),x=new e_(RA),HA=new _x(h,SA,TA,wA,uA,L,x),kA=new zx(h,RA),rt=new Fx,$A=new bx(wA,uA),b=new jw(h,SA,TA,mA,YA,g,o),y=new qx(h,YA,uA),k=new Xx(Z,fA,uA,mA),j=new A_(Z,wA,fA,uA),eA=new I_(Z,wA,fA,uA),fA.programs=HA.programs,h.capabilities=uA,h.extensions=wA,h.properties=RA,h.renderLists=rt,h.shadowMap=y,h.state=mA,h.info=fA}hA();const BA=new Vx(h,Z);this.xr=BA,this.getContext=function(){return Z},this.getContextAttributes=function(){return Z.getContextAttributes()},this.forceContextLoss=function(){const H=wA.get("WEBGL_lose_context");H&&H.loseContext()},this.forceContextRestore=function(){const H=wA.get("WEBGL_lose_context");H&&H.restoreContext()},this.getPixelRatio=function(){return R},this.setPixelRatio=function(H){H!==void 0&&(R=H,this.setSize(w,M,!1))},this.getSize=function(H){return H.set(w,M)},this.setSize=function(H,F,J=!0){if(BA.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}w=H,M=F,A.width=Math.floor(H*R),A.height=Math.floor(F*R),J===!0&&(A.style.width=H+"px",A.style.height=F+"px"),this.setViewport(0,0,H,F)},this.getDrawingBufferSize=function(H){return H.set(w*R,M*R).floor()},this.setDrawingBufferSize=function(H,F,J){w=H,M=F,R=J,A.width=Math.floor(H*J),A.height=Math.floor(F*J),this.setViewport(0,0,H,F)},this.getCurrentViewport=function(H){return H.copy(S)},this.getViewport=function(H){return H.copy(G)},this.setViewport=function(H,F,J,q){H.isVector4?G.set(H.x,H.y,H.z,H.w):G.set(H,F,J,q),mA.viewport(S.copy(G).multiplyScalar(R).floor())},this.getScissor=function(H){return H.copy(T)},this.setScissor=function(H,F,J,q){H.isVector4?T.set(H.x,H.y,H.z,H.w):T.set(H,F,J,q),mA.scissor(D.copy(T).multiplyScalar(R).floor())},this.getScissorTest=function(){return V},this.setScissorTest=function(H){mA.setScissorTest(V=H)},this.setOpaqueSort=function(H){U=H},this.setTransparentSort=function(H){N=H},this.getClearColor=function(H){return H.copy(b.getClearColor())},this.setClearColor=function(){b.setClearColor.apply(b,arguments)},this.getClearAlpha=function(){return b.getClearAlpha()},this.setClearAlpha=function(){b.setClearAlpha.apply(b,arguments)},this.clear=function(H=!0,F=!0,J=!0){let q=0;H&&(q|=16384),F&&(q|=256),J&&(q|=1024),Z.clear(q)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){A.removeEventListener("webglcontextlost",EA,!1),A.removeEventListener("webglcontextrestored",dA,!1),A.removeEventListener("webglcontextcreationerror",yA,!1),rt.dispose(),$A.dispose(),RA.dispose(),SA.dispose(),TA.dispose(),YA.dispose(),L.dispose(),k.dispose(),HA.dispose(),BA.dispose(),BA.removeEventListener("sessionstart",gA),BA.removeEventListener("sessionend",pA),Y&&(Y.dispose(),Y=null),FA.stop()};function EA(H){H.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),l=!0}function dA(){console.log("THREE.WebGLRenderer: Context Restored."),l=!1;const H=fA.autoReset,F=y.enabled,J=y.autoUpdate,q=y.needsUpdate,_=y.type;hA(),fA.autoReset=H,y.enabled=F,y.autoUpdate=J,y.needsUpdate=q,y.type=_}function yA(H){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",H.statusMessage)}function bA(H){const F=H.target;F.removeEventListener("dispose",bA),nA(F)}function nA(H){xA(H),RA.remove(H)}function xA(H){const F=RA.get(H).programs;F!==void 0&&(F.forEach(function(J){HA.releaseProgram(J)}),H.isShaderMaterial&&HA.releaseShaderCache(H))}this.renderBufferDirect=function(H,F,J,q,_,v){F===null&&(F=AA);const P=_.isMesh&&_.matrixWorld.determinant()<0,iA=ea(H,F,J,q,_);mA.setMaterial(q,P);let aA=J.index,IA=1;q.wireframe===!0&&(aA=JA.getWireframeAttribute(J),IA=2);const DA=J.drawRange,QA=J.attributes.position;let _A=DA.start*IA,NA=(DA.start+DA.count)*IA;v!==null&&(_A=Math.max(_A,v.start*IA),NA=Math.min(NA,(v.start+v.count)*IA)),aA!==null?(_A=Math.max(_A,0),NA=Math.min(NA,aA.count)):QA!=null&&(_A=Math.max(_A,0),NA=Math.min(NA,QA.count));const KA=NA-_A;if(KA<0||KA===1/0)return;L.setup(_,q,iA,J,aA);let WA,jA=j;if(aA!==null&&(WA=OA.get(aA),jA=eA,jA.setIndex(WA)),_.isMesh)q.wireframe===!0?(mA.setLineWidth(q.wireframeLinewidth*lA()),jA.setMode(1)):jA.setMode(4);else if(_.isLine){let qA=q.linewidth;qA===void 0&&(qA=1),mA.setLineWidth(qA*lA()),_.isLineSegments?jA.setMode(1):_.isLineLoop?jA.setMode(2):jA.setMode(3)}else _.isPoints?jA.setMode(0):_.isSprite&&jA.setMode(4);if(_.isInstancedMesh)jA.renderInstances(_A,KA,_.count);else if(J.isInstancedBufferGeometry){const qA=J._maxInstanceCount!==void 0?J._maxInstanceCount:1/0,LA=Math.min(J.instanceCount,qA);jA.renderInstances(_A,KA,LA)}else jA.render(_A,KA)},this.compile=function(H,F){function J(q,_,v){q.transparent===!0&&q.side===ji&&q.forceSinglePass===!1?(q.side=ce,q.needsUpdate=!0,Jt(q,_,v),q.side=In,q.needsUpdate=!0,Jt(q,_,v),q.side=ji):Jt(q,_,v)}B=$A.get(H),B.init(),Q.push(B),H.traverseVisible(function(q){q.isLight&&q.layers.test(F.layers)&&(B.pushLight(q),q.castShadow&&B.pushShadow(q))}),B.setupLights(h.useLegacyLights),H.traverse(function(q){const _=q.material;if(_)if(Array.isArray(_))for(let v=0;v<_.length;v++){const P=_[v];J(P,H,q)}else J(_,H,q)}),Q.pop(),B=null};let O=null;function $(H){O&&O(H)}function gA(){FA.stop()}function pA(){FA.start()}const FA=new DE;FA.setAnimationLoop($),typeof self<"u"&&FA.setContext(self),this.setAnimationLoop=function(H){O=H,BA.setAnimationLoop(H),H===null?FA.stop():FA.start()},BA.addEventListener("sessionstart",gA),BA.addEventListener("sessionend",pA),this.render=function(H,F){if(F!==void 0&&F.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(l===!0)return;H.matrixWorldAutoUpdate===!0&&H.updateMatrixWorld(),F.parent===null&&F.matrixWorldAutoUpdate===!0&&F.updateMatrixWorld(),BA.enabled===!0&&BA.isPresenting===!0&&(BA.cameraAutoUpdate===!0&&BA.updateCamera(F),F=BA.getCamera()),H.isScene===!0&&H.onBeforeRender(h,H,F,u),B=$A.get(H,Q.length),B.init(),Q.push(B),CA.multiplyMatrices(F.projectionMatrix,F.matrixWorldInverse),tA.setFromProjectionMatrix(CA),W=this.localClippingEnabled,z=x.init(this.clippingPlanes,W),C=rt.get(H,c.length),C.init(),c.push(C),PA(H,F,0,h.sortObjects),C.finish(),h.sortObjects===!0&&C.sort(U,N),z===!0&&x.beginShadows();const J=B.state.shadowsArray;if(y.render(J,H,F),z===!0&&x.endShadows(),this.info.autoReset===!0&&this.info.reset(),b.render(C,H),B.setupLights(h.useLegacyLights),F.isArrayCamera){const q=F.cameras;for(let _=0,v=q.length;_<v;_++){const P=q[_];ot(C,H,P,P.viewport)}}else ot(C,H,F);u!==null&&(MA.updateMultisampleRenderTarget(u),MA.updateRenderTargetMipmap(u)),H.isScene===!0&&H.onAfterRender(h,H,F),L.resetDefaultState(),d=-1,m=null,Q.pop(),Q.length>0?B=Q[Q.length-1]:B=null,c.pop(),c.length>0?C=c[c.length-1]:C=null};function PA(H,F,J,q){if(H.visible===!1)return;if(H.layers.test(F.layers)){if(H.isGroup)J=H.renderOrder;else if(H.isLOD)H.autoUpdate===!0&&H.update(F);else if(H.isLight)B.pushLight(H),H.castShadow&&B.pushShadow(H);else if(H.isSprite){if(!H.frustumCulled||tA.intersectsSprite(H)){q&&K.setFromMatrixPosition(H.matrixWorld).applyMatrix4(CA);const P=YA.update(H),iA=H.material;iA.visible&&C.push(H,P,iA,J,K.z,null)}}else if((H.isMesh||H.isLine||H.isPoints)&&(H.isSkinnedMesh&&H.skeleton.frame!==fA.render.frame&&(H.skeleton.update(),H.skeleton.frame=fA.render.frame),!H.frustumCulled||tA.intersectsObject(H))){q&&K.setFromMatrixPosition(H.matrixWorld).applyMatrix4(CA);const P=YA.update(H),iA=H.material;if(Array.isArray(iA)){const aA=P.groups;for(let IA=0,DA=aA.length;IA<DA;IA++){const QA=aA[IA],_A=iA[QA.materialIndex];_A&&_A.visible&&C.push(H,P,_A,J,K.z,QA)}}else iA.visible&&C.push(H,P,iA,J,K.z,null)}}const v=H.children;for(let P=0,iA=v.length;P<iA;P++)PA(v[P],F,J,q)}function ot(H,F,J,q){const _=H.opaque,v=H.transmissive,P=H.transparent;B.setupLightsView(J),z===!0&&x.setGlobalState(h.clippingPlanes,J),v.length>0&&zA(_,F,J),q&&mA.viewport(S.copy(q)),_.length>0&&Et(_,F,J),v.length>0&&Et(v,F,J),P.length>0&&Et(P,F,J),mA.buffers.depth.setTest(!0),mA.buffers.depth.setMask(!0),mA.buffers.color.setMask(!0),mA.setPolygonOffset(!1)}function zA(H,F,J){const q=uA.isWebGL2;Y===null&&(Y=new On(1024,1024,{generateMipmaps:!0,type:wA.has("EXT_color_buffer_half_float")?Vs:Yn,minFilter:Ws,samples:q&&a===!0?4:0}));const _=h.getRenderTarget();h.setRenderTarget(Y),h.clear();const v=h.toneMapping;h.toneMapping=Ni,Et(H,F,J),h.toneMapping=v,MA.updateMultisampleRenderTarget(Y),MA.updateRenderTargetMipmap(Y),h.setRenderTarget(_)}function Et(H,F,J){const q=F.isScene===!0?F.overrideMaterial:null;for(let _=0,v=H.length;_<v;_++){const P=H[_],iA=P.object,aA=P.geometry,IA=q===null?P.material:q,DA=P.group;iA.layers.test(J.layers)&&tt(iA,F,J,aA,IA,DA)}}function tt(H,F,J,q,_,v){H.onBeforeRender(h,F,J,q,_,v),H.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse,H.matrixWorld),H.normalMatrix.getNormalMatrix(H.modelViewMatrix),_.onBeforeRender(h,F,J,q,H,v),_.transparent===!0&&_.side===ji&&_.forceSinglePass===!1?(_.side=ce,_.needsUpdate=!0,h.renderBufferDirect(J,F,q,_,H,v),_.side=In,_.needsUpdate=!0,h.renderBufferDirect(J,F,q,_,H,v),_.side=ji):h.renderBufferDirect(J,F,q,_,H,v),H.onAfterRender(h,F,J,q,_,v)}function Jt(H,F,J){F.isScene!==!0&&(F=AA);const q=RA.get(H),_=B.state.lights,v=B.state.shadowsArray,P=_.state.version,iA=HA.getParameters(H,_.state,v,F,J),aA=HA.getProgramCacheKey(iA);let IA=q.programs;q.environment=H.isMeshStandardMaterial?F.environment:null,q.fog=F.fog,q.envMap=(H.isMeshStandardMaterial?TA:SA).get(H.envMap||q.environment),IA===void 0&&(H.addEventListener("dispose",bA),IA=new Map,q.programs=IA);let DA=IA.get(aA);if(DA!==void 0){if(q.currentProgram===DA&&q.lightsStateVersion===P)return yt(H,iA),DA}else iA.uniforms=HA.getUniforms(H),H.onBuild(J,iA,h),H.onBeforeCompile(iA,h),DA=HA.acquireProgram(iA,aA),IA.set(aA,DA),q.uniforms=iA.uniforms;const QA=q.uniforms;(!H.isShaderMaterial&&!H.isRawShaderMaterial||H.clipping===!0)&&(QA.clippingPlanes=x.uniform),yt(H,iA),q.needsLights=Li(H),q.lightsStateVersion=P,q.needsLights&&(QA.ambientLightColor.value=_.state.ambient,QA.lightProbe.value=_.state.probe,QA.directionalLights.value=_.state.directional,QA.directionalLightShadows.value=_.state.directionalShadow,QA.spotLights.value=_.state.spot,QA.spotLightShadows.value=_.state.spotShadow,QA.rectAreaLights.value=_.state.rectArea,QA.ltc_1.value=_.state.rectAreaLTC1,QA.ltc_2.value=_.state.rectAreaLTC2,QA.pointLights.value=_.state.point,QA.pointLightShadows.value=_.state.pointShadow,QA.hemisphereLights.value=_.state.hemi,QA.directionalShadowMap.value=_.state.directionalShadowMap,QA.directionalShadowMatrix.value=_.state.directionalShadowMatrix,QA.spotShadowMap.value=_.state.spotShadowMap,QA.spotLightMatrix.value=_.state.spotLightMatrix,QA.spotLightMap.value=_.state.spotLightMap,QA.pointShadowMap.value=_.state.pointShadowMap,QA.pointShadowMatrix.value=_.state.pointShadowMatrix);const _A=DA.getUniforms(),NA=cr.seqWithValue(_A.seq,QA);return q.currentProgram=DA,q.uniformsList=NA,DA}function yt(H,F){const J=RA.get(H);J.outputEncoding=F.outputEncoding,J.instancing=F.instancing,J.skinning=F.skinning,J.morphTargets=F.morphTargets,J.morphNormals=F.morphNormals,J.morphColors=F.morphColors,J.morphTargetsCount=F.morphTargetsCount,J.numClippingPlanes=F.numClippingPlanes,J.numIntersection=F.numClipIntersection,J.vertexAlphas=F.vertexAlphas,J.vertexTangents=F.vertexTangents,J.toneMapping=F.toneMapping}function ea(H,F,J,q,_){F.isScene!==!0&&(F=AA),MA.resetTextureUnits();const v=F.fog,P=q.isMeshStandardMaterial?F.environment:null,iA=u===null?h.outputEncoding:u.isXRRenderTarget===!0?u.texture.encoding:Kn,aA=(q.isMeshStandardMaterial?TA:SA).get(q.envMap||P),IA=q.vertexColors===!0&&!!J.attributes.color&&J.attributes.color.itemSize===4,DA=!!q.normalMap&&!!J.attributes.tangent,QA=!!J.morphAttributes.position,_A=!!J.morphAttributes.normal,NA=!!J.morphAttributes.color,KA=q.toneMapped?h.toneMapping:Ni,WA=J.morphAttributes.position||J.morphAttributes.normal||J.morphAttributes.color,jA=WA!==void 0?WA.length:0,qA=RA.get(q),LA=B.state.lights;if(z===!0&&(W===!0||H!==m)){const Yt=H===m&&q.id===d;x.setState(q,H,Yt)}let lt=!1;q.version===qA.__version?(qA.needsLights&&qA.lightsStateVersion!==LA.state.version||qA.outputEncoding!==iA||_.isInstancedMesh&&qA.instancing===!1||!_.isInstancedMesh&&qA.instancing===!0||_.isSkinnedMesh&&qA.skinning===!1||!_.isSkinnedMesh&&qA.skinning===!0||qA.envMap!==aA||q.fog===!0&&qA.fog!==v||qA.numClippingPlanes!==void 0&&(qA.numClippingPlanes!==x.numPlanes||qA.numIntersection!==x.numIntersection)||qA.vertexAlphas!==IA||qA.vertexTangents!==DA||qA.morphTargets!==QA||qA.morphNormals!==_A||qA.morphColors!==NA||qA.toneMapping!==KA||uA.isWebGL2===!0&&qA.morphTargetsCount!==jA)&&(lt=!0):(lt=!0,qA.__version=q.version);let et=qA.currentProgram;lt===!0&&(et=Jt(q,F,_));let pt=!1,Pt=!1,li=!1;const Mt=et.getUniforms(),ft=qA.uniforms;if(mA.useProgram(et.program)&&(pt=!0,Pt=!0,li=!0),q.id!==d&&(d=q.id,Pt=!0),pt||m!==H){if(Mt.setValue(Z,"projectionMatrix",H.projectionMatrix),uA.logarithmicDepthBuffer&&Mt.setValue(Z,"logDepthBufFC",2/(Math.log(H.far+1)/Math.LN2)),m!==H&&(m=H,Pt=!0,li=!0),q.isShaderMaterial||q.isMeshPhongMaterial||q.isMeshToonMaterial||q.isMeshStandardMaterial||q.envMap){const Yt=Mt.map.cameraPosition;Yt!==void 0&&Yt.setValue(Z,K.setFromMatrixPosition(H.matrixWorld))}(q.isMeshPhongMaterial||q.isMeshToonMaterial||q.isMeshLambertMaterial||q.isMeshBasicMaterial||q.isMeshStandardMaterial||q.isShaderMaterial)&&Mt.setValue(Z,"isOrthographic",H.isOrthographicCamera===!0),(q.isMeshPhongMaterial||q.isMeshToonMaterial||q.isMeshLambertMaterial||q.isMeshBasicMaterial||q.isMeshStandardMaterial||q.isShaderMaterial||q.isShadowMaterial||_.isSkinnedMesh)&&Mt.setValue(Z,"viewMatrix",H.matrixWorldInverse)}if(_.isSkinnedMesh){Mt.setOptional(Z,_,"bindMatrix"),Mt.setOptional(Z,_,"bindMatrixInverse");const Yt=_.skeleton;Yt&&(uA.floatVertexTextures?(Yt.boneTexture===null&&Yt.computeBoneTexture(),Mt.setValue(Z,"boneTexture",Yt.boneTexture,MA),Mt.setValue(Z,"boneTextureSize",Yt.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const Le=J.morphAttributes;if((Le.position!==void 0||Le.normal!==void 0||Le.color!==void 0&&uA.isWebGL2===!0)&&X.update(_,J,et),(Pt||qA.receiveShadow!==_.receiveShadow)&&(qA.receiveShadow=_.receiveShadow,Mt.setValue(Z,"receiveShadow",_.receiveShadow)),q.isMeshGouraudMaterial&&q.envMap!==null&&(ft.envMap.value=aA,ft.flipEnvMap.value=aA.isCubeTexture&&aA.isRenderTargetTexture===!1?-1:1),Pt&&(Mt.setValue(Z,"toneMappingExposure",h.toneMappingExposure),qA.needsLights&&ia(ft,li),v&&q.fog===!0&&kA.refreshFogUniforms(ft,v),kA.refreshMaterialUniforms(ft,q,R,M,Y),cr.upload(Z,qA.uniformsList,ft,MA)),q.isShaderMaterial&&q.uniformsNeedUpdate===!0&&(cr.upload(Z,qA.uniformsList,ft,MA),q.uniformsNeedUpdate=!1),q.isSpriteMaterial&&Mt.setValue(Z,"center",_.center),Mt.setValue(Z,"modelViewMatrix",_.modelViewMatrix),Mt.setValue(Z,"normalMatrix",_.normalMatrix),Mt.setValue(Z,"modelMatrix",_.matrixWorld),q.isShaderMaterial||q.isRawShaderMaterial){const Yt=q.uniformsGroups;for(let Kt=0,cs=Yt.length;Kt<cs;Kt++)if(uA.isWebGL2){const Eo=Yt[Kt];k.update(Eo,et),k.bind(Eo,et)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return et}function ia(H,F){H.ambientLightColor.needsUpdate=F,H.lightProbe.needsUpdate=F,H.directionalLights.needsUpdate=F,H.directionalLightShadows.needsUpdate=F,H.pointLights.needsUpdate=F,H.pointLightShadows.needsUpdate=F,H.spotLights.needsUpdate=F,H.spotLightShadows.needsUpdate=F,H.rectAreaLights.needsUpdate=F,H.hemisphereLights.needsUpdate=F}function Li(H){return H.isMeshLambertMaterial||H.isMeshToonMaterial||H.isMeshPhongMaterial||H.isMeshStandardMaterial||H.isShadowMaterial||H.isShaderMaterial&&H.lights===!0}this.getActiveCubeFace=function(){return E},this.getActiveMipmapLevel=function(){return f},this.getRenderTarget=function(){return u},this.setRenderTargetTextures=function(H,F,J){RA.get(H.texture).__webglTexture=F,RA.get(H.depthTexture).__webglTexture=J;const q=RA.get(H);q.__hasExternalTextures=!0,q.__hasExternalTextures&&(q.__autoAllocateDepthBuffer=J===void 0,q.__autoAllocateDepthBuffer||wA.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),q.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(H,F){const J=RA.get(H);J.__webglFramebuffer=F,J.__useDefaultFramebuffer=F===void 0},this.setRenderTarget=function(H,F=0,J=0){u=H,E=F,f=J;let q=!0,_=null,v=!1,P=!1;if(H){const aA=RA.get(H);aA.__useDefaultFramebuffer!==void 0?(mA.bindFramebuffer(36160,null),q=!1):aA.__webglFramebuffer===void 0?MA.setupRenderTarget(H):aA.__hasExternalTextures&&MA.rebindTextures(H,RA.get(H.texture).__webglTexture,RA.get(H.depthTexture).__webglTexture);const IA=H.texture;(IA.isData3DTexture||IA.isDataArrayTexture||IA.isCompressedArrayTexture)&&(P=!0);const DA=RA.get(H).__webglFramebuffer;H.isWebGLCubeRenderTarget?(_=DA[F],v=!0):uA.isWebGL2&&H.samples>0&&MA.useMultisampledRTT(H)===!1?_=RA.get(H).__webglMultisampledFramebuffer:_=DA,S.copy(H.viewport),D.copy(H.scissor),p=H.scissorTest}else S.copy(G).multiplyScalar(R).floor(),D.copy(T).multiplyScalar(R).floor(),p=V;if(mA.bindFramebuffer(36160,_)&&uA.drawBuffers&&q&&mA.drawBuffers(H,_),mA.viewport(S),mA.scissor(D),mA.setScissorTest(p),v){const aA=RA.get(H.texture);Z.framebufferTexture2D(36160,36064,34069+F,aA.__webglTexture,J)}else if(P){const aA=RA.get(H.texture),IA=F||0;Z.framebufferTextureLayer(36160,36064,aA.__webglTexture,J||0,IA)}d=-1},this.readRenderTargetPixels=function(H,F,J,q,_,v,P){if(!(H&&H.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let iA=RA.get(H).__webglFramebuffer;if(H.isWebGLCubeRenderTarget&&P!==void 0&&(iA=iA[P]),iA){mA.bindFramebuffer(36160,iA);try{const aA=H.texture,IA=aA.format,DA=aA.type;if(IA!==Ke&&sA.convert(IA)!==Z.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const QA=DA===Vs&&(wA.has("EXT_color_buffer_half_float")||uA.isWebGL2&&wA.has("EXT_color_buffer_float"));if(DA!==Yn&&sA.convert(DA)!==Z.getParameter(35738)&&!(DA===vn&&(uA.isWebGL2||wA.has("OES_texture_float")||wA.has("WEBGL_color_buffer_float")))&&!QA){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}F>=0&&F<=H.width-q&&J>=0&&J<=H.height-_&&Z.readPixels(F,J,q,_,sA.convert(IA),sA.convert(DA),v)}finally{const aA=u!==null?RA.get(u).__webglFramebuffer:null;mA.bindFramebuffer(36160,aA)}}},this.copyFramebufferToTexture=function(H,F,J=0){const q=Math.pow(2,-J),_=Math.floor(F.image.width*q),v=Math.floor(F.image.height*q);MA.setTexture2D(F,0),Z.copyTexSubImage2D(3553,J,0,0,H.x,H.y,_,v),mA.unbindTexture()},this.copyTextureToTexture=function(H,F,J,q=0){const _=F.image.width,v=F.image.height,P=sA.convert(J.format),iA=sA.convert(J.type);MA.setTexture2D(J,0),Z.pixelStorei(37440,J.flipY),Z.pixelStorei(37441,J.premultiplyAlpha),Z.pixelStorei(3317,J.unpackAlignment),F.isDataTexture?Z.texSubImage2D(3553,q,H.x,H.y,_,v,P,iA,F.image.data):F.isCompressedTexture?Z.compressedTexSubImage2D(3553,q,H.x,H.y,F.mipmaps[0].width,F.mipmaps[0].height,P,F.mipmaps[0].data):Z.texSubImage2D(3553,q,H.x,H.y,P,iA,F.image),q===0&&J.generateMipmaps&&Z.generateMipmap(3553),mA.unbindTexture()},this.copyTextureToTexture3D=function(H,F,J,q,_=0){if(h.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const v=H.max.x-H.min.x+1,P=H.max.y-H.min.y+1,iA=H.max.z-H.min.z+1,aA=sA.convert(q.format),IA=sA.convert(q.type);let DA;if(q.isData3DTexture)MA.setTexture3D(q,0),DA=32879;else if(q.isDataArrayTexture)MA.setTexture2DArray(q,0),DA=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}Z.pixelStorei(37440,q.flipY),Z.pixelStorei(37441,q.premultiplyAlpha),Z.pixelStorei(3317,q.unpackAlignment);const QA=Z.getParameter(3314),_A=Z.getParameter(32878),NA=Z.getParameter(3316),KA=Z.getParameter(3315),WA=Z.getParameter(32877),jA=J.isCompressedTexture?J.mipmaps[0]:J.image;Z.pixelStorei(3314,jA.width),Z.pixelStorei(32878,jA.height),Z.pixelStorei(3316,H.min.x),Z.pixelStorei(3315,H.min.y),Z.pixelStorei(32877,H.min.z),J.isDataTexture||J.isData3DTexture?Z.texSubImage3D(DA,_,F.x,F.y,F.z,v,P,iA,aA,IA,jA.data):J.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),Z.compressedTexSubImage3D(DA,_,F.x,F.y,F.z,v,P,iA,aA,jA.data)):Z.texSubImage3D(DA,_,F.x,F.y,F.z,v,P,iA,aA,IA,jA),Z.pixelStorei(3314,QA),Z.pixelStorei(32878,_A),Z.pixelStorei(3316,NA),Z.pixelStorei(3315,KA),Z.pixelStorei(32877,WA),_===0&&q.generateMipmaps&&Z.generateMipmap(DA),mA.unbindTexture()},this.initTexture=function(H){H.isCubeTexture?MA.setTextureCube(H,0):H.isData3DTexture?MA.setTexture3D(H,0):H.isDataArrayTexture||H.isCompressedArrayTexture?MA.setTexture2DArray(H,0):MA.setTexture2D(H,0),mA.unbindTexture()},this.resetState=function(){E=0,f=0,u=null,mA.reset(),L.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Object.defineProperties(ME.prototype,{physicallyCorrectLights:{get:function(){return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),!this.useLegacyLights},set:function(i){console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),this.useLegacyLights=!i}}});class jx extends ME{}jx.prototype.isWebGL1Renderer=!0;class Qh extends We{constructor(A,t,e,n=1){super(A,t,e),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=n}copy(A){return super.copy(A),this.meshPerAttribute=A.meshPerAttribute,this}toJSON(){const A=super.toJSON();return A.meshPerAttribute=this.meshPerAttribute,A.isInstancedBufferAttribute=!0,A}}const dh=new xt,fh=new xt,nr=[],$x=new xt,_s=new Oe;class AM extends Oe{constructor(A,t,e){super(A,t),this.isInstancedMesh=!0,this.instanceMatrix=new Qh(new Float32Array(e*16),16),this.instanceColor=null,this.count=e,this.frustumCulled=!1;for(let n=0;n<e;n++)this.setMatrixAt(n,$x)}copy(A,t){return super.copy(A,t),this.instanceMatrix.copy(A.instanceMatrix),A.instanceColor!==null&&(this.instanceColor=A.instanceColor.clone()),this.count=A.count,this}getColorAt(A,t){t.fromArray(this.instanceColor.array,A*3)}getMatrixAt(A,t){t.fromArray(this.instanceMatrix.array,A*16)}raycast(A,t){const e=this.matrixWorld,n=this.count;if(_s.geometry=this.geometry,_s.material=this.material,_s.material!==void 0)for(let a=0;a<n;a++){this.getMatrixAt(a,dh),fh.multiplyMatrices(e,dh),_s.matrixWorld=fh,_s.raycast(A,nr);for(let o=0,s=nr.length;o<s;o++){const I=nr[o];I.instanceId=a,I.object=this,t.push(I)}nr.length=0}}setColorAt(A,t){this.instanceColor===null&&(this.instanceColor=new Qh(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,A*3)}setMatrixAt(A,t){t.toArray(this.instanceMatrix.array,A*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class xl extends Bn{constructor(A=1,t=32,e=16,n=0,a=Math.PI*2,o=0,s=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:A,widthSegments:t,heightSegments:e,phiStart:n,phiLength:a,thetaStart:o,thetaLength:s},t=Math.max(3,Math.floor(t)),e=Math.max(2,Math.floor(e));const I=Math.min(o+s,Math.PI);let r=0;const g=[],C=new cA,B=new cA,c=[],Q=[],h=[],l=[];for(let E=0;E<=e;E++){const f=[],u=E/e;let d=0;E==0&&o==0?d=.5/t:E==e&&I==Math.PI&&(d=-.5/t);for(let m=0;m<=t;m++){const S=m/t;C.x=-A*Math.cos(n+S*a)*Math.sin(o+u*s),C.y=A*Math.cos(o+u*s),C.z=A*Math.sin(n+S*a)*Math.sin(o+u*s),Q.push(C.x,C.y,C.z),B.copy(C).normalize(),h.push(B.x,B.y,B.z),l.push(S+d,1-u),f.push(r++)}g.push(f)}for(let E=0;E<e;E++)for(let f=0;f<t;f++){const u=g[E][f+1],d=g[E][f],m=g[E+1][f],S=g[E+1][f+1];(E!==0||o>0)&&c.push(u,d,S),(E!==e-1||I<Math.PI)&&c.push(d,m,S)}this.setIndex(c),this.setAttribute("position",new gi(Q,3)),this.setAttribute("normal",new gi(h,3)),this.setAttribute("uv",new gi(l,2))}copy(A){return super.copy(A),this.parameters=Object.assign({},A.parameters),this}static fromJSON(A){return new xl(A.radius,A.widthSegments,A.heightSegments,A.phiStart,A.phiLength,A.thetaStart,A.thetaLength)}}class tM extends Io{constructor(A){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new It(16777215),this.specular=new It(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new It(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gE,this.normalScale=new Bt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ml,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.specular.copy(A.specular),this.shininess=A.shininess,this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.emissive.copy(A.emissive),this.emissiveMap=A.emissiveMap,this.emissiveIntensity=A.emissiveIntensity,this.bumpMap=A.bumpMap,this.bumpScale=A.bumpScale,this.normalMap=A.normalMap,this.normalMapType=A.normalMapType,this.normalScale.copy(A.normalScale),this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this.specularMap=A.specularMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.combine=A.combine,this.reflectivity=A.reflectivity,this.refractionRatio=A.refractionRatio,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.flatShading=A.flatShading,this.fog=A.fog,this}}class eM{constructor(A,t,e){const n=this;let a=!1,o=0,s=0,I;const r=[];this.onStart=void 0,this.onLoad=A,this.onProgress=t,this.onError=e,this.itemStart=function(g){s++,a===!1&&n.onStart!==void 0&&n.onStart(g,o,s),a=!0},this.itemEnd=function(g){o++,n.onProgress!==void 0&&n.onProgress(g,o,s),o===s&&(a=!1,n.onLoad!==void 0&&n.onLoad())},this.itemError=function(g){n.onError!==void 0&&n.onError(g)},this.resolveURL=function(g){return I?I(g):g},this.setURLModifier=function(g){return I=g,this},this.addHandler=function(g,C){return r.push(g,C),this},this.removeHandler=function(g){const C=r.indexOf(g);return C!==-1&&r.splice(C,2),this},this.getHandler=function(g){for(let C=0,B=r.length;C<B;C+=2){const c=r[C],Q=r[C+1];if(c.global&&(c.lastIndex=0),c.test(g))return Q}return null}}}const iM=new eM;class nM{constructor(A){this.manager=A!==void 0?A:iM,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(A,t){const e=this;return new Promise(function(n,a){e.load(A,n,t,a)})}parse(){}setCrossOrigin(A){return this.crossOrigin=A,this}setWithCredentials(A){return this.withCredentials=A,this}setPath(A){return this.path=A,this}setResourcePath(A){return this.resourcePath=A,this}setRequestHeader(A){return this.requestHeader=A,this}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:pl}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=pl);const uh=(i,A,t)=>{},ph=i=>{};/*! pako 2.0.3 https://github.com/nodeca/pako @license (MIT AND Zlib) */const aM=4,mh=0,yh=1,sM=2;function Bs(i){let A=i.length;for(;--A>=0;)i[A]=0}const oM=0,FE=1,rM=2,gM=3,IM=258,Ml=29,lo=256,Xs=lo+1+Ml,za=30,Fl=19,RE=2*Xs+1,Gn=15,nI=16,lM=7,Rl=256,vE=16,GE=17,NE=18,VI=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),Er=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),CM=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),LE=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),BM=512,Si=new Array((Xs+2)*2);Bs(Si);const Js=new Array(za*2);Bs(Js);const Zs=new Array(BM);Bs(Zs);const js=new Array(IM-gM+1);Bs(js);const vl=new Array(Ml);Bs(vl);const _r=new Array(za);Bs(_r);function aI(i,A,t,e,n){this.static_tree=i,this.extra_bits=A,this.extra_base=t,this.elems=e,this.max_length=n,this.has_stree=i&&i.length}let bE,UE,kE;function sI(i,A){this.dyn_tree=i,this.max_code=0,this.stat_desc=A}const TE=i=>i<256?Zs[i]:Zs[256+(i>>>7)],$s=(i,A)=>{i.pending_buf[i.pending++]=A&255,i.pending_buf[i.pending++]=A>>>8&255},he=(i,A,t)=>{i.bi_valid>nI-t?(i.bi_buf|=A<<i.bi_valid&65535,$s(i,i.bi_buf),i.bi_buf=A>>nI-i.bi_valid,i.bi_valid+=t-nI):(i.bi_buf|=A<<i.bi_valid&65535,i.bi_valid+=t)},ei=(i,A,t)=>{he(i,t[A*2],t[A*2+1])},HE=(i,A)=>{let t=0;do t|=i&1,i>>>=1,t<<=1;while(--A>0);return t>>>1},hM=i=>{i.bi_valid===16?($s(i,i.bi_buf),i.bi_buf=0,i.bi_valid=0):i.bi_valid>=8&&(i.pending_buf[i.pending++]=i.bi_buf&255,i.bi_buf>>=8,i.bi_valid-=8)},cM=(i,A)=>{const t=A.dyn_tree,e=A.max_code,n=A.stat_desc.static_tree,a=A.stat_desc.has_stree,o=A.stat_desc.extra_bits,s=A.stat_desc.extra_base,I=A.stat_desc.max_length;let r,g,C,B,c,Q,h=0;for(B=0;B<=Gn;B++)i.bl_count[B]=0;for(t[i.heap[i.heap_max]*2+1]=0,r=i.heap_max+1;r<RE;r++)g=i.heap[r],B=t[t[g*2+1]*2+1]+1,B>I&&(B=I,h++),t[g*2+1]=B,!(g>e)&&(i.bl_count[B]++,c=0,g>=s&&(c=o[g-s]),Q=t[g*2],i.opt_len+=Q*(B+c),a&&(i.static_len+=Q*(n[g*2+1]+c)));if(h!==0){do{for(B=I-1;i.bl_count[B]===0;)B--;i.bl_count[B]--,i.bl_count[B+1]+=2,i.bl_count[I]--,h-=2}while(h>0);for(B=I;B!==0;B--)for(g=i.bl_count[B];g!==0;)C=i.heap[--r],!(C>e)&&(t[C*2+1]!==B&&(i.opt_len+=(B-t[C*2+1])*t[C*2],t[C*2+1]=B),g--)}},qE=(i,A,t)=>{const e=new Array(Gn+1);let n=0,a,o;for(a=1;a<=Gn;a++)e[a]=n=n+t[a-1]<<1;for(o=0;o<=A;o++){let s=i[o*2+1];s!==0&&(i[o*2]=HE(e[s]++,s))}},EM=()=>{let i,A,t,e,n;const a=new Array(Gn+1);for(t=0,e=0;e<Ml-1;e++)for(vl[e]=t,i=0;i<1<<VI[e];i++)js[t++]=e;for(js[t-1]=e,n=0,e=0;e<16;e++)for(_r[e]=n,i=0;i<1<<Er[e];i++)Zs[n++]=e;for(n>>=7;e<za;e++)for(_r[e]=n<<7,i=0;i<1<<Er[e]-7;i++)Zs[256+n++]=e;for(A=0;A<=Gn;A++)a[A]=0;for(i=0;i<=143;)Si[i*2+1]=8,i++,a[8]++;for(;i<=255;)Si[i*2+1]=9,i++,a[9]++;for(;i<=279;)Si[i*2+1]=7,i++,a[7]++;for(;i<=287;)Si[i*2+1]=8,i++,a[8]++;for(qE(Si,Xs+1,a),i=0;i<za;i++)Js[i*2+1]=5,Js[i*2]=HE(i,5);bE=new aI(Si,VI,lo+1,Xs,Gn),UE=new aI(Js,Er,0,za,Gn),kE=new aI(new Array(0),CM,0,Fl,lM)},JE=i=>{let A;for(A=0;A<Xs;A++)i.dyn_ltree[A*2]=0;for(A=0;A<za;A++)i.dyn_dtree[A*2]=0;for(A=0;A<Fl;A++)i.bl_tree[A*2]=0;i.dyn_ltree[Rl*2]=1,i.opt_len=i.static_len=0,i.last_lit=i.matches=0},PE=i=>{i.bi_valid>8?$s(i,i.bi_buf):i.bi_valid>0&&(i.pending_buf[i.pending++]=i.bi_buf),i.bi_buf=0,i.bi_valid=0},QM=(i,A,t,e)=>{PE(i),e&&($s(i,t),$s(i,~t)),i.pending_buf.set(i.window.subarray(A,A+t),i.pending),i.pending+=t},Dh=(i,A,t,e)=>{const n=A*2,a=t*2;return i[n]<i[a]||i[n]===i[a]&&e[A]<=e[t]},oI=(i,A,t)=>{const e=i.heap[t];let n=t<<1;for(;n<=i.heap_len&&(n<i.heap_len&&Dh(A,i.heap[n+1],i.heap[n],i.depth)&&n++,!Dh(A,e,i.heap[n],i.depth));)i.heap[t]=i.heap[n],t=n,n<<=1;i.heap[t]=e},Sh=(i,A,t)=>{let e,n,a=0,o,s;if(i.last_lit!==0)do e=i.pending_buf[i.d_buf+a*2]<<8|i.pending_buf[i.d_buf+a*2+1],n=i.pending_buf[i.l_buf+a],a++,e===0?ei(i,n,A):(o=js[n],ei(i,o+lo+1,A),s=VI[o],s!==0&&(n-=vl[o],he(i,n,s)),e--,o=TE(e),ei(i,o,t),s=Er[o],s!==0&&(e-=_r[o],he(i,e,s)));while(a<i.last_lit);ei(i,Rl,A)},zI=(i,A)=>{const t=A.dyn_tree,e=A.stat_desc.static_tree,n=A.stat_desc.has_stree,a=A.stat_desc.elems;let o,s,I=-1,r;for(i.heap_len=0,i.heap_max=RE,o=0;o<a;o++)t[o*2]!==0?(i.heap[++i.heap_len]=I=o,i.depth[o]=0):t[o*2+1]=0;for(;i.heap_len<2;)r=i.heap[++i.heap_len]=I<2?++I:0,t[r*2]=1,i.depth[r]=0,i.opt_len--,n&&(i.static_len-=e[r*2+1]);for(A.max_code=I,o=i.heap_len>>1;o>=1;o--)oI(i,t,o);r=a;do o=i.heap[1],i.heap[1]=i.heap[i.heap_len--],oI(i,t,1),s=i.heap[1],i.heap[--i.heap_max]=o,i.heap[--i.heap_max]=s,t[r*2]=t[o*2]+t[s*2],i.depth[r]=(i.depth[o]>=i.depth[s]?i.depth[o]:i.depth[s])+1,t[o*2+1]=t[s*2+1]=r,i.heap[1]=r++,oI(i,t,1);while(i.heap_len>=2);i.heap[--i.heap_max]=i.heap[1],cM(i,A),qE(t,I,i.bl_count)},wh=(i,A,t)=>{let e,n=-1,a,o=A[0*2+1],s=0,I=7,r=4;for(o===0&&(I=138,r=3),A[(t+1)*2+1]=65535,e=0;e<=t;e++)a=o,o=A[(e+1)*2+1],!(++s<I&&a===o)&&(s<r?i.bl_tree[a*2]+=s:a!==0?(a!==n&&i.bl_tree[a*2]++,i.bl_tree[vE*2]++):s<=10?i.bl_tree[GE*2]++:i.bl_tree[NE*2]++,s=0,n=a,o===0?(I=138,r=3):a===o?(I=6,r=3):(I=7,r=4))},_h=(i,A,t)=>{let e,n=-1,a,o=A[0*2+1],s=0,I=7,r=4;for(o===0&&(I=138,r=3),e=0;e<=t;e++)if(a=o,o=A[(e+1)*2+1],!(++s<I&&a===o)){if(s<r)do ei(i,a,i.bl_tree);while(--s!==0);else a!==0?(a!==n&&(ei(i,a,i.bl_tree),s--),ei(i,vE,i.bl_tree),he(i,s-3,2)):s<=10?(ei(i,GE,i.bl_tree),he(i,s-3,3)):(ei(i,NE,i.bl_tree),he(i,s-11,7));s=0,n=a,o===0?(I=138,r=3):a===o?(I=6,r=3):(I=7,r=4)}},dM=i=>{let A;for(wh(i,i.dyn_ltree,i.l_desc.max_code),wh(i,i.dyn_dtree,i.d_desc.max_code),zI(i,i.bl_desc),A=Fl-1;A>=3&&i.bl_tree[LE[A]*2+1]===0;A--);return i.opt_len+=3*(A+1)+5+5+4,A},fM=(i,A,t,e)=>{let n;for(he(i,A-257,5),he(i,t-1,5),he(i,e-4,4),n=0;n<e;n++)he(i,i.bl_tree[LE[n]*2+1],3);_h(i,i.dyn_ltree,A-1),_h(i,i.dyn_dtree,t-1)},uM=i=>{let A=4093624447,t;for(t=0;t<=31;t++,A>>>=1)if(A&1&&i.dyn_ltree[t*2]!==0)return mh;if(i.dyn_ltree[9*2]!==0||i.dyn_ltree[10*2]!==0||i.dyn_ltree[13*2]!==0)return yh;for(t=32;t<lo;t++)if(i.dyn_ltree[t*2]!==0)return yh;return mh};let xh=!1;const pM=i=>{xh||(EM(),xh=!0),i.l_desc=new sI(i.dyn_ltree,bE),i.d_desc=new sI(i.dyn_dtree,UE),i.bl_desc=new sI(i.bl_tree,kE),i.bi_buf=0,i.bi_valid=0,JE(i)},YE=(i,A,t,e)=>{he(i,(oM<<1)+(e?1:0),3),QM(i,A,t,!0)},mM=i=>{he(i,FE<<1,3),ei(i,Rl,Si),hM(i)},yM=(i,A,t,e)=>{let n,a,o=0;i.level>0?(i.strm.data_type===sM&&(i.strm.data_type=uM(i)),zI(i,i.l_desc),zI(i,i.d_desc),o=dM(i),n=i.opt_len+3+7>>>3,a=i.static_len+3+7>>>3,a<=n&&(n=a)):n=a=t+5,t+4<=n&&A!==-1?YE(i,A,t,e):i.strategy===aM||a===n?(he(i,(FE<<1)+(e?1:0),3),Sh(i,Si,Js)):(he(i,(rM<<1)+(e?1:0),3),fM(i,i.l_desc.max_code+1,i.d_desc.max_code+1,o+1),Sh(i,i.dyn_ltree,i.dyn_dtree)),JE(i),e&&PE(i)},DM=(i,A,t)=>(i.pending_buf[i.d_buf+i.last_lit*2]=A>>>8&255,i.pending_buf[i.d_buf+i.last_lit*2+1]=A&255,i.pending_buf[i.l_buf+i.last_lit]=t&255,i.last_lit++,A===0?i.dyn_ltree[t*2]++:(i.matches++,A--,i.dyn_ltree[(js[t]+lo+1)*2]++,i.dyn_dtree[TE(A)*2]++),i.last_lit===i.lit_bufsize-1);var SM=pM,wM=YE,_M=yM,xM=DM,MM=mM,FM={_tr_init:SM,_tr_stored_block:wM,_tr_flush_block:_M,_tr_tally:xM,_tr_align:MM};const RM=(i,A,t,e)=>{let n=i&65535|0,a=i>>>16&65535|0,o=0;for(;t!==0;){o=t>2e3?2e3:t,t-=o;do n=n+A[e++]|0,a=a+n|0;while(--o);n%=65521,a%=65521}return n|a<<16|0};var Ao=RM;const vM=()=>{let i,A=[];for(var t=0;t<256;t++){i=t;for(var e=0;e<8;e++)i=i&1?3988292384^i>>>1:i>>>1;A[t]=i}return A},GM=new Uint32Array(vM()),NM=(i,A,t,e)=>{const n=GM,a=e+t;i^=-1;for(let o=e;o<a;o++)i=i>>>8^n[(i^A[o])&255];return i^-1};var qt=NM,Vn={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},Aa={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:LM,_tr_stored_block:bM,_tr_flush_block:UM,_tr_tally:sn,_tr_align:kM}=FM,{Z_NO_FLUSH:ta,Z_PARTIAL_FLUSH:TM,Z_FULL_FLUSH:HM,Z_FINISH:on,Z_BLOCK:Mh,Z_OK:ii,Z_STREAM_END:Fh,Z_STREAM_ERROR:Ge,Z_DATA_ERROR:qM,Z_BUF_ERROR:rI,Z_DEFAULT_COMPRESSION:JM,Z_FILTERED:PM,Z_HUFFMAN_ONLY:ar,Z_RLE:YM,Z_FIXED:KM,Z_DEFAULT_STRATEGY:OM,Z_UNKNOWN:WM,Z_DEFLATED:Pr}=Aa,VM=9,zM=15,XM=8,ZM=29,jM=256,XI=jM+1+ZM,$M=30,AF=19,tF=2*XI+1,eF=15,it=3,An=258,Ve=An+it+1,iF=32,Yr=42,ZI=69,Qr=73,dr=91,fr=103,Nn=113,bs=666,Rt=1,Co=2,zn=3,hs=4,nF=3,tn=(i,A)=>(i.msg=Vn[A],A),Rh=i=>(i<<1)-(i>4?9:0),zi=i=>{let A=i.length;for(;--A>=0;)i[A]=0};let aF=(i,A,t)=>(A<<i.hash_shift^t)&i.hash_mask,rn=aF;const Wi=i=>{const A=i.state;let t=A.pending;t>i.avail_out&&(t=i.avail_out),t!==0&&(i.output.set(A.pending_buf.subarray(A.pending_out,A.pending_out+t),i.next_out),i.next_out+=t,A.pending_out+=t,i.total_out+=t,i.avail_out-=t,A.pending-=t,A.pending===0&&(A.pending_out=0))},zt=(i,A)=>{UM(i,i.block_start>=0?i.block_start:-1,i.strstart-i.block_start,A),i.block_start=i.strstart,Wi(i.strm)},at=(i,A)=>{i.pending_buf[i.pending++]=A},xs=(i,A)=>{i.pending_buf[i.pending++]=A>>>8&255,i.pending_buf[i.pending++]=A&255},sF=(i,A,t,e)=>{let n=i.avail_in;return n>e&&(n=e),n===0?0:(i.avail_in-=n,A.set(i.input.subarray(i.next_in,i.next_in+n),t),i.state.wrap===1?i.adler=Ao(i.adler,A,n,t):i.state.wrap===2&&(i.adler=qt(i.adler,A,n,t)),i.next_in+=n,i.total_in+=n,n)},KE=(i,A)=>{let t=i.max_chain_length,e=i.strstart,n,a,o=i.prev_length,s=i.nice_match;const I=i.strstart>i.w_size-Ve?i.strstart-(i.w_size-Ve):0,r=i.window,g=i.w_mask,C=i.prev,B=i.strstart+An;let c=r[e+o-1],Q=r[e+o];i.prev_length>=i.good_match&&(t>>=2),s>i.lookahead&&(s=i.lookahead);do if(n=A,!(r[n+o]!==Q||r[n+o-1]!==c||r[n]!==r[e]||r[++n]!==r[e+1])){e+=2,n++;do;while(r[++e]===r[++n]&&r[++e]===r[++n]&&r[++e]===r[++n]&&r[++e]===r[++n]&&r[++e]===r[++n]&&r[++e]===r[++n]&&r[++e]===r[++n]&&r[++e]===r[++n]&&e<B);if(a=An-(B-e),e=B-An,a>o){if(i.match_start=A,o=a,a>=s)break;c=r[e+o-1],Q=r[e+o]}}while((A=C[A&g])>I&&--t!==0);return o<=i.lookahead?o:i.lookahead},Xn=i=>{const A=i.w_size;let t,e,n,a,o;do{if(a=i.window_size-i.lookahead-i.strstart,i.strstart>=A+(A-Ve)){i.window.set(i.window.subarray(A,A+A),0),i.match_start-=A,i.strstart-=A,i.block_start-=A,e=i.hash_size,t=e;do n=i.head[--t],i.head[t]=n>=A?n-A:0;while(--e);e=A,t=e;do n=i.prev[--t],i.prev[t]=n>=A?n-A:0;while(--e);a+=A}if(i.strm.avail_in===0)break;if(e=sF(i.strm,i.window,i.strstart+i.lookahead,a),i.lookahead+=e,i.lookahead+i.insert>=it)for(o=i.strstart-i.insert,i.ins_h=i.window[o],i.ins_h=rn(i,i.ins_h,i.window[o+1]);i.insert&&(i.ins_h=rn(i,i.ins_h,i.window[o+it-1]),i.prev[o&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=o,o++,i.insert--,!(i.lookahead+i.insert<it)););}while(i.lookahead<Ve&&i.strm.avail_in!==0)},oF=(i,A)=>{let t=65535;for(t>i.pending_buf_size-5&&(t=i.pending_buf_size-5);;){if(i.lookahead<=1){if(Xn(i),i.lookahead===0&&A===ta)return Rt;if(i.lookahead===0)break}i.strstart+=i.lookahead,i.lookahead=0;const e=i.block_start+t;if((i.strstart===0||i.strstart>=e)&&(i.lookahead=i.strstart-e,i.strstart=e,zt(i,!1),i.strm.avail_out===0)||i.strstart-i.block_start>=i.w_size-Ve&&(zt(i,!1),i.strm.avail_out===0))return Rt}return i.insert=0,A===on?(zt(i,!0),i.strm.avail_out===0?zn:hs):(i.strstart>i.block_start&&(zt(i,!1),i.strm.avail_out===0),Rt)},gI=(i,A)=>{let t,e;for(;;){if(i.lookahead<Ve){if(Xn(i),i.lookahead<Ve&&A===ta)return Rt;if(i.lookahead===0)break}if(t=0,i.lookahead>=it&&(i.ins_h=rn(i,i.ins_h,i.window[i.strstart+it-1]),t=i.prev[i.strstart&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=i.strstart),t!==0&&i.strstart-t<=i.w_size-Ve&&(i.match_length=KE(i,t)),i.match_length>=it)if(e=sn(i,i.strstart-i.match_start,i.match_length-it),i.lookahead-=i.match_length,i.match_length<=i.max_lazy_match&&i.lookahead>=it){i.match_length--;do i.strstart++,i.ins_h=rn(i,i.ins_h,i.window[i.strstart+it-1]),t=i.prev[i.strstart&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=i.strstart;while(--i.match_length!==0);i.strstart++}else i.strstart+=i.match_length,i.match_length=0,i.ins_h=i.window[i.strstart],i.ins_h=rn(i,i.ins_h,i.window[i.strstart+1]);else e=sn(i,0,i.window[i.strstart]),i.lookahead--,i.strstart++;if(e&&(zt(i,!1),i.strm.avail_out===0))return Rt}return i.insert=i.strstart<it-1?i.strstart:it-1,A===on?(zt(i,!0),i.strm.avail_out===0?zn:hs):i.last_lit&&(zt(i,!1),i.strm.avail_out===0)?Rt:Co},Ga=(i,A)=>{let t,e,n;for(;;){if(i.lookahead<Ve){if(Xn(i),i.lookahead<Ve&&A===ta)return Rt;if(i.lookahead===0)break}if(t=0,i.lookahead>=it&&(i.ins_h=rn(i,i.ins_h,i.window[i.strstart+it-1]),t=i.prev[i.strstart&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=i.strstart),i.prev_length=i.match_length,i.prev_match=i.match_start,i.match_length=it-1,t!==0&&i.prev_length<i.max_lazy_match&&i.strstart-t<=i.w_size-Ve&&(i.match_length=KE(i,t),i.match_length<=5&&(i.strategy===PM||i.match_length===it&&i.strstart-i.match_start>4096)&&(i.match_length=it-1)),i.prev_length>=it&&i.match_length<=i.prev_length){n=i.strstart+i.lookahead-it,e=sn(i,i.strstart-1-i.prev_match,i.prev_length-it),i.lookahead-=i.prev_length-1,i.prev_length-=2;do++i.strstart<=n&&(i.ins_h=rn(i,i.ins_h,i.window[i.strstart+it-1]),t=i.prev[i.strstart&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=i.strstart);while(--i.prev_length!==0);if(i.match_available=0,i.match_length=it-1,i.strstart++,e&&(zt(i,!1),i.strm.avail_out===0))return Rt}else if(i.match_available){if(e=sn(i,0,i.window[i.strstart-1]),e&&zt(i,!1),i.strstart++,i.lookahead--,i.strm.avail_out===0)return Rt}else i.match_available=1,i.strstart++,i.lookahead--}return i.match_available&&(e=sn(i,0,i.window[i.strstart-1]),i.match_available=0),i.insert=i.strstart<it-1?i.strstart:it-1,A===on?(zt(i,!0),i.strm.avail_out===0?zn:hs):i.last_lit&&(zt(i,!1),i.strm.avail_out===0)?Rt:Co},rF=(i,A)=>{let t,e,n,a;const o=i.window;for(;;){if(i.lookahead<=An){if(Xn(i),i.lookahead<=An&&A===ta)return Rt;if(i.lookahead===0)break}if(i.match_length=0,i.lookahead>=it&&i.strstart>0&&(n=i.strstart-1,e=o[n],e===o[++n]&&e===o[++n]&&e===o[++n])){a=i.strstart+An;do;while(e===o[++n]&&e===o[++n]&&e===o[++n]&&e===o[++n]&&e===o[++n]&&e===o[++n]&&e===o[++n]&&e===o[++n]&&n<a);i.match_length=An-(a-n),i.match_length>i.lookahead&&(i.match_length=i.lookahead)}if(i.match_length>=it?(t=sn(i,1,i.match_length-it),i.lookahead-=i.match_length,i.strstart+=i.match_length,i.match_length=0):(t=sn(i,0,i.window[i.strstart]),i.lookahead--,i.strstart++),t&&(zt(i,!1),i.strm.avail_out===0))return Rt}return i.insert=0,A===on?(zt(i,!0),i.strm.avail_out===0?zn:hs):i.last_lit&&(zt(i,!1),i.strm.avail_out===0)?Rt:Co},gF=(i,A)=>{let t;for(;;){if(i.lookahead===0&&(Xn(i),i.lookahead===0)){if(A===ta)return Rt;break}if(i.match_length=0,t=sn(i,0,i.window[i.strstart]),i.lookahead--,i.strstart++,t&&(zt(i,!1),i.strm.avail_out===0))return Rt}return i.insert=0,A===on?(zt(i,!0),i.strm.avail_out===0?zn:hs):i.last_lit&&(zt(i,!1),i.strm.avail_out===0)?Rt:Co};function Xe(i,A,t,e,n){this.good_length=i,this.max_lazy=A,this.nice_length=t,this.max_chain=e,this.func=n}const Us=[new Xe(0,0,0,0,oF),new Xe(4,4,8,4,gI),new Xe(4,5,16,8,gI),new Xe(4,6,32,32,gI),new Xe(4,4,16,16,Ga),new Xe(8,16,32,32,Ga),new Xe(8,16,128,128,Ga),new Xe(8,32,128,256,Ga),new Xe(32,128,258,1024,Ga),new Xe(32,258,258,4096,Ga)],IF=i=>{i.window_size=2*i.w_size,zi(i.head),i.max_lazy_match=Us[i.level].max_lazy,i.good_match=Us[i.level].good_length,i.nice_match=Us[i.level].nice_length,i.max_chain_length=Us[i.level].max_chain,i.strstart=0,i.block_start=0,i.lookahead=0,i.insert=0,i.match_length=i.prev_length=it-1,i.match_available=0,i.ins_h=0};function lF(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Pr,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(tF*2),this.dyn_dtree=new Uint16Array((2*$M+1)*2),this.bl_tree=new Uint16Array((2*AF+1)*2),zi(this.dyn_ltree),zi(this.dyn_dtree),zi(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(eF+1),this.heap=new Uint16Array(2*XI+1),zi(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*XI+1),zi(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const OE=i=>{if(!i||!i.state)return tn(i,Ge);i.total_in=i.total_out=0,i.data_type=WM;const A=i.state;return A.pending=0,A.pending_out=0,A.wrap<0&&(A.wrap=-A.wrap),A.status=A.wrap?Yr:Nn,i.adler=A.wrap===2?0:1,A.last_flush=ta,LM(A),ii},WE=i=>{const A=OE(i);return A===ii&&IF(i.state),A},CF=(i,A)=>!i||!i.state||i.state.wrap!==2?Ge:(i.state.gzhead=A,ii),VE=(i,A,t,e,n,a)=>{if(!i)return Ge;let o=1;if(A===JM&&(A=6),e<0?(o=0,e=-e):e>15&&(o=2,e-=16),n<1||n>VM||t!==Pr||e<8||e>15||A<0||A>9||a<0||a>KM)return tn(i,Ge);e===8&&(e=9);const s=new lF;return i.state=s,s.strm=i,s.wrap=o,s.gzhead=null,s.w_bits=e,s.w_size=1<<s.w_bits,s.w_mask=s.w_size-1,s.hash_bits=n+7,s.hash_size=1<<s.hash_bits,s.hash_mask=s.hash_size-1,s.hash_shift=~~((s.hash_bits+it-1)/it),s.window=new Uint8Array(s.w_size*2),s.head=new Uint16Array(s.hash_size),s.prev=new Uint16Array(s.w_size),s.lit_bufsize=1<<n+6,s.pending_buf_size=s.lit_bufsize*4,s.pending_buf=new Uint8Array(s.pending_buf_size),s.d_buf=1*s.lit_bufsize,s.l_buf=(1+2)*s.lit_bufsize,s.level=A,s.strategy=a,s.method=t,WE(i)},BF=(i,A)=>VE(i,A,Pr,zM,XM,OM),hF=(i,A)=>{let t,e;if(!i||!i.state||A>Mh||A<0)return i?tn(i,Ge):Ge;const n=i.state;if(!i.output||!i.input&&i.avail_in!==0||n.status===bs&&A!==on)return tn(i,i.avail_out===0?rI:Ge);n.strm=i;const a=n.last_flush;if(n.last_flush=A,n.status===Yr)if(n.wrap===2)i.adler=0,at(n,31),at(n,139),at(n,8),n.gzhead?(at(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),at(n,n.gzhead.time&255),at(n,n.gzhead.time>>8&255),at(n,n.gzhead.time>>16&255),at(n,n.gzhead.time>>24&255),at(n,n.level===9?2:n.strategy>=ar||n.level<2?4:0),at(n,n.gzhead.os&255),n.gzhead.extra&&n.gzhead.extra.length&&(at(n,n.gzhead.extra.length&255),at(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(i.adler=qt(i.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=ZI):(at(n,0),at(n,0),at(n,0),at(n,0),at(n,0),at(n,n.level===9?2:n.strategy>=ar||n.level<2?4:0),at(n,nF),n.status=Nn);else{let o=Pr+(n.w_bits-8<<4)<<8,s=-1;n.strategy>=ar||n.level<2?s=0:n.level<6?s=1:n.level===6?s=2:s=3,o|=s<<6,n.strstart!==0&&(o|=iF),o+=31-o%31,n.status=Nn,xs(n,o),n.strstart!==0&&(xs(n,i.adler>>>16),xs(n,i.adler&65535)),i.adler=1}if(n.status===ZI)if(n.gzhead.extra){for(t=n.pending;n.gzindex<(n.gzhead.extra.length&65535)&&!(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>t&&(i.adler=qt(i.adler,n.pending_buf,n.pending-t,t)),Wi(i),t=n.pending,n.pending===n.pending_buf_size));)at(n,n.gzhead.extra[n.gzindex]&255),n.gzindex++;n.gzhead.hcrc&&n.pending>t&&(i.adler=qt(i.adler,n.pending_buf,n.pending-t,t)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=Qr)}else n.status=Qr;if(n.status===Qr)if(n.gzhead.name){t=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>t&&(i.adler=qt(i.adler,n.pending_buf,n.pending-t,t)),Wi(i),t=n.pending,n.pending===n.pending_buf_size)){e=1;break}n.gzindex<n.gzhead.name.length?e=n.gzhead.name.charCodeAt(n.gzindex++)&255:e=0,at(n,e)}while(e!==0);n.gzhead.hcrc&&n.pending>t&&(i.adler=qt(i.adler,n.pending_buf,n.pending-t,t)),e===0&&(n.gzindex=0,n.status=dr)}else n.status=dr;if(n.status===dr)if(n.gzhead.comment){t=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>t&&(i.adler=qt(i.adler,n.pending_buf,n.pending-t,t)),Wi(i),t=n.pending,n.pending===n.pending_buf_size)){e=1;break}n.gzindex<n.gzhead.comment.length?e=n.gzhead.comment.charCodeAt(n.gzindex++)&255:e=0,at(n,e)}while(e!==0);n.gzhead.hcrc&&n.pending>t&&(i.adler=qt(i.adler,n.pending_buf,n.pending-t,t)),e===0&&(n.status=fr)}else n.status=fr;if(n.status===fr&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&Wi(i),n.pending+2<=n.pending_buf_size&&(at(n,i.adler&255),at(n,i.adler>>8&255),i.adler=0,n.status=Nn)):n.status=Nn),n.pending!==0){if(Wi(i),i.avail_out===0)return n.last_flush=-1,ii}else if(i.avail_in===0&&Rh(A)<=Rh(a)&&A!==on)return tn(i,rI);if(n.status===bs&&i.avail_in!==0)return tn(i,rI);if(i.avail_in!==0||n.lookahead!==0||A!==ta&&n.status!==bs){let o=n.strategy===ar?gF(n,A):n.strategy===YM?rF(n,A):Us[n.level].func(n,A);if((o===zn||o===hs)&&(n.status=bs),o===Rt||o===zn)return i.avail_out===0&&(n.last_flush=-1),ii;if(o===Co&&(A===TM?kM(n):A!==Mh&&(bM(n,0,0,!1),A===HM&&(zi(n.head),n.lookahead===0&&(n.strstart=0,n.block_start=0,n.insert=0))),Wi(i),i.avail_out===0))return n.last_flush=-1,ii}return A!==on?ii:n.wrap<=0?Fh:(n.wrap===2?(at(n,i.adler&255),at(n,i.adler>>8&255),at(n,i.adler>>16&255),at(n,i.adler>>24&255),at(n,i.total_in&255),at(n,i.total_in>>8&255),at(n,i.total_in>>16&255),at(n,i.total_in>>24&255)):(xs(n,i.adler>>>16),xs(n,i.adler&65535)),Wi(i),n.wrap>0&&(n.wrap=-n.wrap),n.pending!==0?ii:Fh)},cF=i=>{if(!i||!i.state)return Ge;const A=i.state.status;return A!==Yr&&A!==ZI&&A!==Qr&&A!==dr&&A!==fr&&A!==Nn&&A!==bs?tn(i,Ge):(i.state=null,A===Nn?tn(i,qM):ii)},EF=(i,A)=>{let t=A.length;if(!i||!i.state)return Ge;const e=i.state,n=e.wrap;if(n===2||n===1&&e.status!==Yr||e.lookahead)return Ge;if(n===1&&(i.adler=Ao(i.adler,A,t,0)),e.wrap=0,t>=e.w_size){n===0&&(zi(e.head),e.strstart=0,e.block_start=0,e.insert=0);let I=new Uint8Array(e.w_size);I.set(A.subarray(t-e.w_size,t),0),A=I,t=e.w_size}const a=i.avail_in,o=i.next_in,s=i.input;for(i.avail_in=t,i.next_in=0,i.input=A,Xn(e);e.lookahead>=it;){let I=e.strstart,r=e.lookahead-(it-1);do e.ins_h=rn(e,e.ins_h,e.window[I+it-1]),e.prev[I&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=I,I++;while(--r);e.strstart=I,e.lookahead=it-1,Xn(e)}return e.strstart+=e.lookahead,e.block_start=e.strstart,e.insert=e.lookahead,e.lookahead=0,e.match_length=e.prev_length=it-1,e.match_available=0,i.next_in=o,i.input=s,i.avail_in=a,e.wrap=n,ii};var QF=BF,dF=VE,fF=WE,uF=OE,pF=CF,mF=hF,yF=cF,DF=EF,SF="pako deflate (from Nodeca project)",Ps={deflateInit:QF,deflateInit2:dF,deflateReset:fF,deflateResetKeep:uF,deflateSetHeader:pF,deflate:mF,deflateEnd:yF,deflateSetDictionary:DF,deflateInfo:SF};const wF=(i,A)=>Object.prototype.hasOwnProperty.call(i,A);var _F=function(i){const A=Array.prototype.slice.call(arguments,1);for(;A.length;){const t=A.shift();if(!!t){if(typeof t!="object")throw new TypeError(t+"must be non-object");for(const e in t)wF(t,e)&&(i[e]=t[e])}}return i},xF=i=>{let A=0;for(let e=0,n=i.length;e<n;e++)A+=i[e].length;const t=new Uint8Array(A);for(let e=0,n=0,a=i.length;e<a;e++){let o=i[e];t.set(o,n),n+=o.length}return t},Kr={assign:_F,flattenChunks:xF};let zE=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{zE=!1}const to=new Uint8Array(256);for(let i=0;i<256;i++)to[i]=i>=252?6:i>=248?5:i>=240?4:i>=224?3:i>=192?2:1;to[254]=to[254]=1;var MF=i=>{let A,t,e,n,a,o=i.length,s=0;for(n=0;n<o;n++)t=i.charCodeAt(n),(t&64512)===55296&&n+1<o&&(e=i.charCodeAt(n+1),(e&64512)===56320&&(t=65536+(t-55296<<10)+(e-56320),n++)),s+=t<128?1:t<2048?2:t<65536?3:4;for(A=new Uint8Array(s),a=0,n=0;a<s;n++)t=i.charCodeAt(n),(t&64512)===55296&&n+1<o&&(e=i.charCodeAt(n+1),(e&64512)===56320&&(t=65536+(t-55296<<10)+(e-56320),n++)),t<128?A[a++]=t:t<2048?(A[a++]=192|t>>>6,A[a++]=128|t&63):t<65536?(A[a++]=224|t>>>12,A[a++]=128|t>>>6&63,A[a++]=128|t&63):(A[a++]=240|t>>>18,A[a++]=128|t>>>12&63,A[a++]=128|t>>>6&63,A[a++]=128|t&63);return A};const FF=(i,A)=>{if(A<65534&&i.subarray&&zE)return String.fromCharCode.apply(null,i.length===A?i:i.subarray(0,A));let t="";for(let e=0;e<A;e++)t+=String.fromCharCode(i[e]);return t};var RF=(i,A)=>{let t,e;const n=A||i.length,a=new Array(n*2);for(e=0,t=0;t<n;){let o=i[t++];if(o<128){a[e++]=o;continue}let s=to[o];if(s>4){a[e++]=65533,t+=s-1;continue}for(o&=s===2?31:s===3?15:7;s>1&&t<n;)o=o<<6|i[t++]&63,s--;if(s>1){a[e++]=65533;continue}o<65536?a[e++]=o:(o-=65536,a[e++]=55296|o>>10&1023,a[e++]=56320|o&1023)}return FF(a,e)},vF=(i,A)=>{A=A||i.length,A>i.length&&(A=i.length);let t=A-1;for(;t>=0&&(i[t]&192)===128;)t--;return t<0||t===0?A:t+to[i[t]]>A?t:A},eo={string2buf:MF,buf2string:RF,utf8border:vF};function GF(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var XE=GF;const ZE=Object.prototype.toString,{Z_NO_FLUSH:NF,Z_SYNC_FLUSH:LF,Z_FULL_FLUSH:bF,Z_FINISH:UF,Z_OK:xr,Z_STREAM_END:kF,Z_DEFAULT_COMPRESSION:TF,Z_DEFAULT_STRATEGY:HF,Z_DEFLATED:qF}=Aa;function Bo(i){this.options=Kr.assign({level:TF,method:qF,chunkSize:16384,windowBits:15,memLevel:8,strategy:HF},i||{});let A=this.options;A.raw&&A.windowBits>0?A.windowBits=-A.windowBits:A.gzip&&A.windowBits>0&&A.windowBits<16&&(A.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new XE,this.strm.avail_out=0;let t=Ps.deflateInit2(this.strm,A.level,A.method,A.windowBits,A.memLevel,A.strategy);if(t!==xr)throw new Error(Vn[t]);if(A.header&&Ps.deflateSetHeader(this.strm,A.header),A.dictionary){let e;if(typeof A.dictionary=="string"?e=eo.string2buf(A.dictionary):ZE.call(A.dictionary)==="[object ArrayBuffer]"?e=new Uint8Array(A.dictionary):e=A.dictionary,t=Ps.deflateSetDictionary(this.strm,e),t!==xr)throw new Error(Vn[t]);this._dict_set=!0}}Bo.prototype.push=function(i,A){const t=this.strm,e=this.options.chunkSize;let n,a;if(this.ended)return!1;for(A===~~A?a=A:a=A===!0?UF:NF,typeof i=="string"?t.input=eo.string2buf(i):ZE.call(i)==="[object ArrayBuffer]"?t.input=new Uint8Array(i):t.input=i,t.next_in=0,t.avail_in=t.input.length;;){if(t.avail_out===0&&(t.output=new Uint8Array(e),t.next_out=0,t.avail_out=e),(a===LF||a===bF)&&t.avail_out<=6){this.onData(t.output.subarray(0,t.next_out)),t.avail_out=0;continue}if(n=Ps.deflate(t,a),n===kF)return t.next_out>0&&this.onData(t.output.subarray(0,t.next_out)),n=Ps.deflateEnd(this.strm),this.onEnd(n),this.ended=!0,n===xr;if(t.avail_out===0){this.onData(t.output);continue}if(a>0&&t.next_out>0){this.onData(t.output.subarray(0,t.next_out)),t.avail_out=0;continue}if(t.avail_in===0)break}return!0};Bo.prototype.onData=function(i){this.chunks.push(i)};Bo.prototype.onEnd=function(i){i===xr&&(this.result=Kr.flattenChunks(this.chunks)),this.chunks=[],this.err=i,this.msg=this.strm.msg};function Gl(i,A){const t=new Bo(A);if(t.push(i,!0),t.err)throw t.msg||Vn[t.err];return t.result}function JF(i,A){return A=A||{},A.raw=!0,Gl(i,A)}function PF(i,A){return A=A||{},A.gzip=!0,Gl(i,A)}var YF=Bo,KF=Gl,OF=JF,WF=PF,VF=Aa,zF={Deflate:YF,deflate:KF,deflateRaw:OF,gzip:WF,constants:VF};const sr=30,XF=12;var ZF=function(A,t){let e,n,a,o,s,I,r,g,C,B,c,Q,h,l,E,f,u,d,m,S,D,p,w,M;const R=A.state;e=A.next_in,w=A.input,n=e+(A.avail_in-5),a=A.next_out,M=A.output,o=a-(t-A.avail_out),s=a+(A.avail_out-257),I=R.dmax,r=R.wsize,g=R.whave,C=R.wnext,B=R.window,c=R.hold,Q=R.bits,h=R.lencode,l=R.distcode,E=(1<<R.lenbits)-1,f=(1<<R.distbits)-1;A:do{Q<15&&(c+=w[e++]<<Q,Q+=8,c+=w[e++]<<Q,Q+=8),u=h[c&E];t:for(;;){if(d=u>>>24,c>>>=d,Q-=d,d=u>>>16&255,d===0)M[a++]=u&65535;else if(d&16){m=u&65535,d&=15,d&&(Q<d&&(c+=w[e++]<<Q,Q+=8),m+=c&(1<<d)-1,c>>>=d,Q-=d),Q<15&&(c+=w[e++]<<Q,Q+=8,c+=w[e++]<<Q,Q+=8),u=l[c&f];e:for(;;){if(d=u>>>24,c>>>=d,Q-=d,d=u>>>16&255,d&16){if(S=u&65535,d&=15,Q<d&&(c+=w[e++]<<Q,Q+=8,Q<d&&(c+=w[e++]<<Q,Q+=8)),S+=c&(1<<d)-1,S>I){A.msg="invalid distance too far back",R.mode=sr;break A}if(c>>>=d,Q-=d,d=a-o,S>d){if(d=S-d,d>g&&R.sane){A.msg="invalid distance too far back",R.mode=sr;break A}if(D=0,p=B,C===0){if(D+=r-d,d<m){m-=d;do M[a++]=B[D++];while(--d);D=a-S,p=M}}else if(C<d){if(D+=r+C-d,d-=C,d<m){m-=d;do M[a++]=B[D++];while(--d);if(D=0,C<m){d=C,m-=d;do M[a++]=B[D++];while(--d);D=a-S,p=M}}}else if(D+=C-d,d<m){m-=d;do M[a++]=B[D++];while(--d);D=a-S,p=M}for(;m>2;)M[a++]=p[D++],M[a++]=p[D++],M[a++]=p[D++],m-=3;m&&(M[a++]=p[D++],m>1&&(M[a++]=p[D++]))}else{D=a-S;do M[a++]=M[D++],M[a++]=M[D++],M[a++]=M[D++],m-=3;while(m>2);m&&(M[a++]=M[D++],m>1&&(M[a++]=M[D++]))}}else if((d&64)===0){u=l[(u&65535)+(c&(1<<d)-1)];continue e}else{A.msg="invalid distance code",R.mode=sr;break A}break}}else if((d&64)===0){u=h[(u&65535)+(c&(1<<d)-1)];continue t}else if(d&32){R.mode=XF;break A}else{A.msg="invalid literal/length code",R.mode=sr;break A}break}}while(e<n&&a<s);m=Q>>3,e-=m,Q-=m<<3,c&=(1<<Q)-1,A.next_in=e,A.next_out=a,A.avail_in=e<n?5+(n-e):5-(e-n),A.avail_out=a<s?257+(s-a):257-(a-s),R.hold=c,R.bits=Q};const Na=15,vh=852,Gh=592,Nh=0,II=1,Lh=2,jF=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),$F=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),AR=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),tR=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),eR=(i,A,t,e,n,a,o,s)=>{const I=s.bits;let r=0,g=0,C=0,B=0,c=0,Q=0,h=0,l=0,E=0,f=0,u,d,m,S,D,p=null,w=0,M;const R=new Uint16Array(Na+1),U=new Uint16Array(Na+1);let N=null,G=0,T,V,tA;for(r=0;r<=Na;r++)R[r]=0;for(g=0;g<e;g++)R[A[t+g]]++;for(c=I,B=Na;B>=1&&R[B]===0;B--);if(c>B&&(c=B),B===0)return n[a++]=1<<24|64<<16|0,n[a++]=1<<24|64<<16|0,s.bits=1,0;for(C=1;C<B&&R[C]===0;C++);for(c<C&&(c=C),l=1,r=1;r<=Na;r++)if(l<<=1,l-=R[r],l<0)return-1;if(l>0&&(i===Nh||B!==1))return-1;for(U[1]=0,r=1;r<Na;r++)U[r+1]=U[r]+R[r];for(g=0;g<e;g++)A[t+g]!==0&&(o[U[A[t+g]]++]=g);if(i===Nh?(p=N=o,M=19):i===II?(p=jF,w-=257,N=$F,G-=257,M=256):(p=AR,N=tR,M=-1),f=0,g=0,r=C,D=a,Q=c,h=0,m=-1,E=1<<c,S=E-1,i===II&&E>vh||i===Lh&&E>Gh)return 1;for(;;){T=r-h,o[g]<M?(V=0,tA=o[g]):o[g]>M?(V=N[G+o[g]],tA=p[w+o[g]]):(V=32+64,tA=0),u=1<<r-h,d=1<<Q,C=d;do d-=u,n[D+(f>>h)+d]=T<<24|V<<16|tA|0;while(d!==0);for(u=1<<r-1;f&u;)u>>=1;if(u!==0?(f&=u-1,f+=u):f=0,g++,--R[r]===0){if(r===B)break;r=A[t+o[g]]}if(r>c&&(f&S)!==m){for(h===0&&(h=c),D+=C,Q=r-h,l=1<<Q;Q+h<B&&(l-=R[Q+h],!(l<=0));)Q++,l<<=1;if(E+=1<<Q,i===II&&E>vh||i===Lh&&E>Gh)return 1;m=f&S,n[m]=c<<24|Q<<16|D-a|0}}return f!==0&&(n[D+f]=r-h<<24|64<<16|0),s.bits=c,0};var Ys=eR;const iR=0,jE=1,$E=2,{Z_FINISH:bh,Z_BLOCK:nR,Z_TREES:or,Z_OK:Zn,Z_STREAM_END:aR,Z_NEED_DICT:sR,Z_STREAM_ERROR:Ne,Z_DATA_ERROR:AQ,Z_MEM_ERROR:tQ,Z_BUF_ERROR:oR,Z_DEFLATED:Uh}=Aa,eQ=1,kh=2,Th=3,Hh=4,qh=5,Jh=6,Ph=7,Yh=8,Kh=9,Oh=10,Mr=11,yi=12,lI=13,Wh=14,CI=15,Vh=16,zh=17,Xh=18,Zh=19,rr=20,gr=21,jh=22,$h=23,Ac=24,tc=25,ec=26,BI=27,ic=28,nc=29,Qt=30,iQ=31,rR=32,gR=852,IR=592,lR=15,CR=lR,ac=i=>(i>>>24&255)+(i>>>8&65280)+((i&65280)<<8)+((i&255)<<24);function BR(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const nQ=i=>{if(!i||!i.state)return Ne;const A=i.state;return i.total_in=i.total_out=A.total=0,i.msg="",A.wrap&&(i.adler=A.wrap&1),A.mode=eQ,A.last=0,A.havedict=0,A.dmax=32768,A.head=null,A.hold=0,A.bits=0,A.lencode=A.lendyn=new Int32Array(gR),A.distcode=A.distdyn=new Int32Array(IR),A.sane=1,A.back=-1,Zn},aQ=i=>{if(!i||!i.state)return Ne;const A=i.state;return A.wsize=0,A.whave=0,A.wnext=0,nQ(i)},sQ=(i,A)=>{let t;if(!i||!i.state)return Ne;const e=i.state;return A<0?(t=0,A=-A):(t=(A>>4)+1,A<48&&(A&=15)),A&&(A<8||A>15)?Ne:(e.window!==null&&e.wbits!==A&&(e.window=null),e.wrap=t,e.wbits=A,aQ(i))},oQ=(i,A)=>{if(!i)return Ne;const t=new BR;i.state=t,t.window=null;const e=sQ(i,A);return e!==Zn&&(i.state=null),e},hR=i=>oQ(i,CR);let sc=!0,hI,cI;const cR=i=>{if(sc){hI=new Int32Array(512),cI=new Int32Array(32);let A=0;for(;A<144;)i.lens[A++]=8;for(;A<256;)i.lens[A++]=9;for(;A<280;)i.lens[A++]=7;for(;A<288;)i.lens[A++]=8;for(Ys(jE,i.lens,0,288,hI,0,i.work,{bits:9}),A=0;A<32;)i.lens[A++]=5;Ys($E,i.lens,0,32,cI,0,i.work,{bits:5}),sc=!1}i.lencode=hI,i.lenbits=9,i.distcode=cI,i.distbits=5},rQ=(i,A,t,e)=>{let n;const a=i.state;return a.window===null&&(a.wsize=1<<a.wbits,a.wnext=0,a.whave=0,a.window=new Uint8Array(a.wsize)),e>=a.wsize?(a.window.set(A.subarray(t-a.wsize,t),0),a.wnext=0,a.whave=a.wsize):(n=a.wsize-a.wnext,n>e&&(n=e),a.window.set(A.subarray(t-e,t-e+n),a.wnext),e-=n,e?(a.window.set(A.subarray(t-e,t),0),a.wnext=e,a.whave=a.wsize):(a.wnext+=n,a.wnext===a.wsize&&(a.wnext=0),a.whave<a.wsize&&(a.whave+=n))),0},ER=(i,A)=>{let t,e,n,a,o,s,I,r,g,C,B,c,Q,h,l=0,E,f,u,d,m,S,D,p;const w=new Uint8Array(4);let M,R;const U=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!i||!i.state||!i.output||!i.input&&i.avail_in!==0)return Ne;t=i.state,t.mode===yi&&(t.mode=lI),o=i.next_out,n=i.output,I=i.avail_out,a=i.next_in,e=i.input,s=i.avail_in,r=t.hold,g=t.bits,C=s,B=I,p=Zn;A:for(;;)switch(t.mode){case eQ:if(t.wrap===0){t.mode=lI;break}for(;g<16;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}if(t.wrap&2&&r===35615){t.check=0,w[0]=r&255,w[1]=r>>>8&255,t.check=qt(t.check,w,2,0),r=0,g=0,t.mode=kh;break}if(t.flags=0,t.head&&(t.head.done=!1),!(t.wrap&1)||(((r&255)<<8)+(r>>8))%31){i.msg="incorrect header check",t.mode=Qt;break}if((r&15)!==Uh){i.msg="unknown compression method",t.mode=Qt;break}if(r>>>=4,g-=4,D=(r&15)+8,t.wbits===0)t.wbits=D;else if(D>t.wbits){i.msg="invalid window size",t.mode=Qt;break}t.dmax=1<<t.wbits,i.adler=t.check=1,t.mode=r&512?Oh:yi,r=0,g=0;break;case kh:for(;g<16;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}if(t.flags=r,(t.flags&255)!==Uh){i.msg="unknown compression method",t.mode=Qt;break}if(t.flags&57344){i.msg="unknown header flags set",t.mode=Qt;break}t.head&&(t.head.text=r>>8&1),t.flags&512&&(w[0]=r&255,w[1]=r>>>8&255,t.check=qt(t.check,w,2,0)),r=0,g=0,t.mode=Th;case Th:for(;g<32;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}t.head&&(t.head.time=r),t.flags&512&&(w[0]=r&255,w[1]=r>>>8&255,w[2]=r>>>16&255,w[3]=r>>>24&255,t.check=qt(t.check,w,4,0)),r=0,g=0,t.mode=Hh;case Hh:for(;g<16;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}t.head&&(t.head.xflags=r&255,t.head.os=r>>8),t.flags&512&&(w[0]=r&255,w[1]=r>>>8&255,t.check=qt(t.check,w,2,0)),r=0,g=0,t.mode=qh;case qh:if(t.flags&1024){for(;g<16;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}t.length=r,t.head&&(t.head.extra_len=r),t.flags&512&&(w[0]=r&255,w[1]=r>>>8&255,t.check=qt(t.check,w,2,0)),r=0,g=0}else t.head&&(t.head.extra=null);t.mode=Jh;case Jh:if(t.flags&1024&&(c=t.length,c>s&&(c=s),c&&(t.head&&(D=t.head.extra_len-t.length,t.head.extra||(t.head.extra=new Uint8Array(t.head.extra_len)),t.head.extra.set(e.subarray(a,a+c),D)),t.flags&512&&(t.check=qt(t.check,e,c,a)),s-=c,a+=c,t.length-=c),t.length))break A;t.length=0,t.mode=Ph;case Ph:if(t.flags&2048){if(s===0)break A;c=0;do D=e[a+c++],t.head&&D&&t.length<65536&&(t.head.name+=String.fromCharCode(D));while(D&&c<s);if(t.flags&512&&(t.check=qt(t.check,e,c,a)),s-=c,a+=c,D)break A}else t.head&&(t.head.name=null);t.length=0,t.mode=Yh;case Yh:if(t.flags&4096){if(s===0)break A;c=0;do D=e[a+c++],t.head&&D&&t.length<65536&&(t.head.comment+=String.fromCharCode(D));while(D&&c<s);if(t.flags&512&&(t.check=qt(t.check,e,c,a)),s-=c,a+=c,D)break A}else t.head&&(t.head.comment=null);t.mode=Kh;case Kh:if(t.flags&512){for(;g<16;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}if(r!==(t.check&65535)){i.msg="header crc mismatch",t.mode=Qt;break}r=0,g=0}t.head&&(t.head.hcrc=t.flags>>9&1,t.head.done=!0),i.adler=t.check=0,t.mode=yi;break;case Oh:for(;g<32;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}i.adler=t.check=ac(r),r=0,g=0,t.mode=Mr;case Mr:if(t.havedict===0)return i.next_out=o,i.avail_out=I,i.next_in=a,i.avail_in=s,t.hold=r,t.bits=g,sR;i.adler=t.check=1,t.mode=yi;case yi:if(A===nR||A===or)break A;case lI:if(t.last){r>>>=g&7,g-=g&7,t.mode=BI;break}for(;g<3;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}switch(t.last=r&1,r>>>=1,g-=1,r&3){case 0:t.mode=Wh;break;case 1:if(cR(t),t.mode=rr,A===or){r>>>=2,g-=2;break A}break;case 2:t.mode=zh;break;case 3:i.msg="invalid block type",t.mode=Qt}r>>>=2,g-=2;break;case Wh:for(r>>>=g&7,g-=g&7;g<32;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}if((r&65535)!==(r>>>16^65535)){i.msg="invalid stored block lengths",t.mode=Qt;break}if(t.length=r&65535,r=0,g=0,t.mode=CI,A===or)break A;case CI:t.mode=Vh;case Vh:if(c=t.length,c){if(c>s&&(c=s),c>I&&(c=I),c===0)break A;n.set(e.subarray(a,a+c),o),s-=c,a+=c,I-=c,o+=c,t.length-=c;break}t.mode=yi;break;case zh:for(;g<14;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}if(t.nlen=(r&31)+257,r>>>=5,g-=5,t.ndist=(r&31)+1,r>>>=5,g-=5,t.ncode=(r&15)+4,r>>>=4,g-=4,t.nlen>286||t.ndist>30){i.msg="too many length or distance symbols",t.mode=Qt;break}t.have=0,t.mode=Xh;case Xh:for(;t.have<t.ncode;){for(;g<3;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}t.lens[U[t.have++]]=r&7,r>>>=3,g-=3}for(;t.have<19;)t.lens[U[t.have++]]=0;if(t.lencode=t.lendyn,t.lenbits=7,M={bits:t.lenbits},p=Ys(iR,t.lens,0,19,t.lencode,0,t.work,M),t.lenbits=M.bits,p){i.msg="invalid code lengths set",t.mode=Qt;break}t.have=0,t.mode=Zh;case Zh:for(;t.have<t.nlen+t.ndist;){for(;l=t.lencode[r&(1<<t.lenbits)-1],E=l>>>24,f=l>>>16&255,u=l&65535,!(E<=g);){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}if(u<16)r>>>=E,g-=E,t.lens[t.have++]=u;else{if(u===16){for(R=E+2;g<R;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}if(r>>>=E,g-=E,t.have===0){i.msg="invalid bit length repeat",t.mode=Qt;break}D=t.lens[t.have-1],c=3+(r&3),r>>>=2,g-=2}else if(u===17){for(R=E+3;g<R;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}r>>>=E,g-=E,D=0,c=3+(r&7),r>>>=3,g-=3}else{for(R=E+7;g<R;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}r>>>=E,g-=E,D=0,c=11+(r&127),r>>>=7,g-=7}if(t.have+c>t.nlen+t.ndist){i.msg="invalid bit length repeat",t.mode=Qt;break}for(;c--;)t.lens[t.have++]=D}}if(t.mode===Qt)break;if(t.lens[256]===0){i.msg="invalid code -- missing end-of-block",t.mode=Qt;break}if(t.lenbits=9,M={bits:t.lenbits},p=Ys(jE,t.lens,0,t.nlen,t.lencode,0,t.work,M),t.lenbits=M.bits,p){i.msg="invalid literal/lengths set",t.mode=Qt;break}if(t.distbits=6,t.distcode=t.distdyn,M={bits:t.distbits},p=Ys($E,t.lens,t.nlen,t.ndist,t.distcode,0,t.work,M),t.distbits=M.bits,p){i.msg="invalid distances set",t.mode=Qt;break}if(t.mode=rr,A===or)break A;case rr:t.mode=gr;case gr:if(s>=6&&I>=258){i.next_out=o,i.avail_out=I,i.next_in=a,i.avail_in=s,t.hold=r,t.bits=g,ZF(i,B),o=i.next_out,n=i.output,I=i.avail_out,a=i.next_in,e=i.input,s=i.avail_in,r=t.hold,g=t.bits,t.mode===yi&&(t.back=-1);break}for(t.back=0;l=t.lencode[r&(1<<t.lenbits)-1],E=l>>>24,f=l>>>16&255,u=l&65535,!(E<=g);){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}if(f&&(f&240)===0){for(d=E,m=f,S=u;l=t.lencode[S+((r&(1<<d+m)-1)>>d)],E=l>>>24,f=l>>>16&255,u=l&65535,!(d+E<=g);){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}r>>>=d,g-=d,t.back+=d}if(r>>>=E,g-=E,t.back+=E,t.length=u,f===0){t.mode=ec;break}if(f&32){t.back=-1,t.mode=yi;break}if(f&64){i.msg="invalid literal/length code",t.mode=Qt;break}t.extra=f&15,t.mode=jh;case jh:if(t.extra){for(R=t.extra;g<R;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}t.length+=r&(1<<t.extra)-1,r>>>=t.extra,g-=t.extra,t.back+=t.extra}t.was=t.length,t.mode=$h;case $h:for(;l=t.distcode[r&(1<<t.distbits)-1],E=l>>>24,f=l>>>16&255,u=l&65535,!(E<=g);){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}if((f&240)===0){for(d=E,m=f,S=u;l=t.distcode[S+((r&(1<<d+m)-1)>>d)],E=l>>>24,f=l>>>16&255,u=l&65535,!(d+E<=g);){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}r>>>=d,g-=d,t.back+=d}if(r>>>=E,g-=E,t.back+=E,f&64){i.msg="invalid distance code",t.mode=Qt;break}t.offset=u,t.extra=f&15,t.mode=Ac;case Ac:if(t.extra){for(R=t.extra;g<R;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}t.offset+=r&(1<<t.extra)-1,r>>>=t.extra,g-=t.extra,t.back+=t.extra}if(t.offset>t.dmax){i.msg="invalid distance too far back",t.mode=Qt;break}t.mode=tc;case tc:if(I===0)break A;if(c=B-I,t.offset>c){if(c=t.offset-c,c>t.whave&&t.sane){i.msg="invalid distance too far back",t.mode=Qt;break}c>t.wnext?(c-=t.wnext,Q=t.wsize-c):Q=t.wnext-c,c>t.length&&(c=t.length),h=t.window}else h=n,Q=o-t.offset,c=t.length;c>I&&(c=I),I-=c,t.length-=c;do n[o++]=h[Q++];while(--c);t.length===0&&(t.mode=gr);break;case ec:if(I===0)break A;n[o++]=t.length,I--,t.mode=gr;break;case BI:if(t.wrap){for(;g<32;){if(s===0)break A;s--,r|=e[a++]<<g,g+=8}if(B-=I,i.total_out+=B,t.total+=B,B&&(i.adler=t.check=t.flags?qt(t.check,n,B,o-B):Ao(t.check,n,B,o-B)),B=I,(t.flags?r:ac(r))!==t.check){i.msg="incorrect data check",t.mode=Qt;break}r=0,g=0}t.mode=ic;case ic:if(t.wrap&&t.flags){for(;g<32;){if(s===0)break A;s--,r+=e[a++]<<g,g+=8}if(r!==(t.total&4294967295)){i.msg="incorrect length check",t.mode=Qt;break}r=0,g=0}t.mode=nc;case nc:p=aR;break A;case Qt:p=AQ;break A;case iQ:return tQ;case rR:default:return Ne}return i.next_out=o,i.avail_out=I,i.next_in=a,i.avail_in=s,t.hold=r,t.bits=g,(t.wsize||B!==i.avail_out&&t.mode<Qt&&(t.mode<BI||A!==bh))&&rQ(i,i.output,i.next_out,B-i.avail_out),C-=i.avail_in,B-=i.avail_out,i.total_in+=C,i.total_out+=B,t.total+=B,t.wrap&&B&&(i.adler=t.check=t.flags?qt(t.check,n,B,i.next_out-B):Ao(t.check,n,B,i.next_out-B)),i.data_type=t.bits+(t.last?64:0)+(t.mode===yi?128:0)+(t.mode===rr||t.mode===CI?256:0),(C===0&&B===0||A===bh)&&p===Zn&&(p=oR),p},QR=i=>{if(!i||!i.state)return Ne;let A=i.state;return A.window&&(A.window=null),i.state=null,Zn},dR=(i,A)=>{if(!i||!i.state)return Ne;const t=i.state;return(t.wrap&2)===0?Ne:(t.head=A,A.done=!1,Zn)},fR=(i,A)=>{const t=A.length;let e,n,a;return!i||!i.state||(e=i.state,e.wrap!==0&&e.mode!==Mr)?Ne:e.mode===Mr&&(n=1,n=Ao(n,A,t,0),n!==e.check)?AQ:(a=rQ(i,A,t,t),a?(e.mode=iQ,tQ):(e.havedict=1,Zn))};var uR=aQ,pR=sQ,mR=nQ,yR=hR,DR=oQ,SR=ER,wR=QR,_R=dR,xR=fR,MR="pako inflate (from Nodeca project)",wi={inflateReset:uR,inflateReset2:pR,inflateResetKeep:mR,inflateInit:yR,inflateInit2:DR,inflate:SR,inflateEnd:wR,inflateGetHeader:_R,inflateSetDictionary:xR,inflateInfo:MR};function FR(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var RR=FR;const gQ=Object.prototype.toString,{Z_NO_FLUSH:vR,Z_FINISH:GR,Z_OK:io,Z_STREAM_END:EI,Z_NEED_DICT:QI,Z_STREAM_ERROR:NR,Z_DATA_ERROR:oc,Z_MEM_ERROR:LR}=Aa;function ho(i){this.options=Kr.assign({chunkSize:1024*64,windowBits:15,to:""},i||{});const A=this.options;A.raw&&A.windowBits>=0&&A.windowBits<16&&(A.windowBits=-A.windowBits,A.windowBits===0&&(A.windowBits=-15)),A.windowBits>=0&&A.windowBits<16&&!(i&&i.windowBits)&&(A.windowBits+=32),A.windowBits>15&&A.windowBits<48&&(A.windowBits&15)===0&&(A.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new XE,this.strm.avail_out=0;let t=wi.inflateInit2(this.strm,A.windowBits);if(t!==io)throw new Error(Vn[t]);if(this.header=new RR,wi.inflateGetHeader(this.strm,this.header),A.dictionary&&(typeof A.dictionary=="string"?A.dictionary=eo.string2buf(A.dictionary):gQ.call(A.dictionary)==="[object ArrayBuffer]"&&(A.dictionary=new Uint8Array(A.dictionary)),A.raw&&(t=wi.inflateSetDictionary(this.strm,A.dictionary),t!==io)))throw new Error(Vn[t])}ho.prototype.push=function(i,A){const t=this.strm,e=this.options.chunkSize,n=this.options.dictionary;let a,o,s;if(this.ended)return!1;for(A===~~A?o=A:o=A===!0?GR:vR,gQ.call(i)==="[object ArrayBuffer]"?t.input=new Uint8Array(i):t.input=i,t.next_in=0,t.avail_in=t.input.length;;){for(t.avail_out===0&&(t.output=new Uint8Array(e),t.next_out=0,t.avail_out=e),a=wi.inflate(t,o),a===QI&&n&&(a=wi.inflateSetDictionary(t,n),a===io?a=wi.inflate(t,o):a===oc&&(a=QI));t.avail_in>0&&a===EI&&t.state.wrap>0&&i[t.next_in]!==0;)wi.inflateReset(t),a=wi.inflate(t,o);switch(a){case NR:case oc:case QI:case LR:return this.onEnd(a),this.ended=!0,!1}if(s=t.avail_out,t.next_out&&(t.avail_out===0||a===EI))if(this.options.to==="string"){let I=eo.utf8border(t.output,t.next_out),r=t.next_out-I,g=eo.buf2string(t.output,I);t.next_out=r,t.avail_out=e-r,r&&t.output.set(t.output.subarray(I,I+r),0),this.onData(g)}else this.onData(t.output.length===t.next_out?t.output:t.output.subarray(0,t.next_out));if(!(a===io&&s===0)){if(a===EI)return a=wi.inflateEnd(this.strm),this.onEnd(a),this.ended=!0,!0;if(t.avail_in===0)break}}return!0};ho.prototype.onData=function(i){this.chunks.push(i)};ho.prototype.onEnd=function(i){i===io&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=Kr.flattenChunks(this.chunks)),this.chunks=[],this.err=i,this.msg=this.strm.msg};function Nl(i,A){const t=new ho(A);if(t.push(i),t.err)throw t.msg||Vn[t.err];return t.result}function bR(i,A){return A=A||{},A.raw=!0,Nl(i,A)}var UR=ho,kR=Nl,TR=bR,HR=Nl,qR=Aa,JR={Inflate:UR,inflate:kR,inflateRaw:TR,ungzip:HR,constants:qR};const{Deflate:PR,deflate:YR,deflateRaw:KR,gzip:OR}=zF,{Inflate:WR,inflate:VR,inflateRaw:zR,ungzip:XR}=JR;var ZR=PR,jR=YR,$R=KR,Av=OR,tv=WR,ev=VR,iv=zR,nv=XR,av=Aa,rc={Deflate:ZR,deflate:jR,deflateRaw:$R,gzip:Av,Inflate:tv,inflate:ev,inflateRaw:iv,ungzip:nv,constants:av},Ie;const sv=(Ie=class{constructor(i=1){if(i<-1||i>9)throw new Error("Invalid zlib compression level, it should be between -1 and 9");this.level=i}static fromConfig({level:i}){return new Ie(i)}encode(i){return rc.deflate(i,{level:this.level})}decode(i,A){const t=rc.inflate(i);return A!==void 0?(A.set(t),A):t}},Ie.codecId="zlib",Ie);var ov=function(){return typeof document<"u"&&document.currentScript&&document.currentScript.src,function(i){i=i||{};var A;A||(A=typeof i<"u"?i:{});var t,e;A.ready=new Promise(function(_,v){t=_,e=v});var n={},a;for(a in A)A.hasOwnProperty(a)&&(n[a]=A[a]);var o="./this.program",s=A.print||console.log.bind(console),I=A.printErr||console.warn.bind(console);for(a in n)n.hasOwnProperty(a)&&(A[a]=n[a]);n=null,A.thisProgram&&(o=A.thisProgram);var r;A.wasmBinary&&(r=A.wasmBinary),A.noExitRuntime&&A.noExitRuntime,typeof WebAssembly!="object"&&Z("no native wasm support detected");var g,C=!1,B=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function c(_,v,P){var iA=v+P;for(P=v;_[P]&&!(P>=iA);)++P;if(16<P-v&&_.subarray&&B)return B.decode(_.subarray(v,P));for(iA="";v<P;){var aA=_[v++];if(aA&128){var IA=_[v++]&63;if((aA&224)==192)iA+=String.fromCharCode((aA&31)<<6|IA);else{var DA=_[v++]&63;aA=(aA&240)==224?(aA&15)<<12|IA<<6|DA:(aA&7)<<18|IA<<12|DA<<6|_[v++]&63,65536>aA?iA+=String.fromCharCode(aA):(aA-=65536,iA+=String.fromCharCode(55296|aA>>10,56320|aA&1023))}}else iA+=String.fromCharCode(aA)}return iA}function Q(_,v,P){var iA=p;if(0<P){P=v+P-1;for(var aA=0;aA<_.length;++aA){var IA=_.charCodeAt(aA);if(55296<=IA&&57343>=IA){var DA=_.charCodeAt(++aA);IA=65536+((IA&1023)<<10)|DA&1023}if(127>=IA){if(v>=P)break;iA[v++]=IA}else{if(2047>=IA){if(v+1>=P)break;iA[v++]=192|IA>>6}else{if(65535>=IA){if(v+2>=P)break;iA[v++]=224|IA>>12}else{if(v+3>=P)break;iA[v++]=240|IA>>18,iA[v++]=128|IA>>12&63}iA[v++]=128|IA>>6&63}iA[v++]=128|IA&63}}iA[v]=0}}var h=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0;function l(_,v){for(var P=_>>1,iA=P+v/2;!(P>=iA)&&M[P];)++P;if(P<<=1,32<P-_&&h)return h.decode(p.subarray(_,P));for(P=0,iA="";;){var aA=w[_+2*P>>1];if(aA==0||P==v/2)return iA;++P,iA+=String.fromCharCode(aA)}}function E(_,v,P){if(P===void 0&&(P=2147483647),2>P)return 0;P-=2;var iA=v;P=P<2*_.length?P/2:_.length;for(var aA=0;aA<P;++aA)w[v>>1]=_.charCodeAt(aA),v+=2;return w[v>>1]=0,v-iA}function f(_){return 2*_.length}function u(_,v){for(var P=0,iA="";!(P>=v/4);){var aA=R[_+4*P>>2];if(aA==0)break;++P,65536<=aA?(aA-=65536,iA+=String.fromCharCode(55296|aA>>10,56320|aA&1023)):iA+=String.fromCharCode(aA)}return iA}function d(_,v,P){if(P===void 0&&(P=2147483647),4>P)return 0;var iA=v;P=iA+P-4;for(var aA=0;aA<_.length;++aA){var IA=_.charCodeAt(aA);if(55296<=IA&&57343>=IA){var DA=_.charCodeAt(++aA);IA=65536+((IA&1023)<<10)|DA&1023}if(R[v>>2]=IA,v+=4,v+4>P)break}return R[v>>2]=0,v-iA}function m(_){for(var v=0,P=0;P<_.length;++P){var iA=_.charCodeAt(P);55296<=iA&&57343>=iA&&++P,v+=4}return v}var S,D,p,w,M,R,U,N,G;function T(_){S=_,A.HEAP8=D=new Int8Array(_),A.HEAP16=w=new Int16Array(_),A.HEAP32=R=new Int32Array(_),A.HEAPU8=p=new Uint8Array(_),A.HEAPU16=M=new Uint16Array(_),A.HEAPU32=U=new Uint32Array(_),A.HEAPF32=N=new Float32Array(_),A.HEAPF64=G=new Float64Array(_)}var V=A.INITIAL_MEMORY||16777216;A.wasmMemory?g=A.wasmMemory:g=new WebAssembly.Memory({initial:V/65536,maximum:32768}),g&&(S=g.buffer),V=S.byteLength,T(S);var tA,z=[],W=[],Y=[],CA=[];function K(){var _=A.preRun.shift();z.unshift(_)}var AA=0,lA=null;A.preloadedImages={},A.preloadedAudios={};function Z(_){throw A.onAbort&&A.onAbort(_),I(_),C=!0,_=new WebAssembly.RuntimeError("abort("+_+"). Build with -s ASSERTIONS=1 for more info."),e(_),_}function oA(_){var v=uA;return String.prototype.startsWith?v.startsWith(_):v.indexOf(_)===0}function wA(){return oA("data:application/octet-stream;base64,")}var uA="blosc_codec.wasm";if(!wA()){var mA=uA;uA=A.locateFile?A.locateFile(mA,""):""+mA}function fA(){try{if(r)return new Uint8Array(r);throw"both async and sync fetching of the wasm failed"}catch(_){Z(_)}}function RA(_){for(;0<_.length;){var v=_.shift();if(typeof v=="function")v(A);else{var P=v.T;typeof P=="number"?v.O===void 0?tA.get(P)():tA.get(P)(v.O):P(v.O===void 0?null:v.O)}}}function MA(_){this.N=_-16,this.$=function(v){R[this.N+8>>2]=v},this.X=function(v){R[this.N+0>>2]=v},this.Y=function(){R[this.N+4>>2]=0},this.W=function(){D[this.N+12>>0]=0},this.Z=function(){D[this.N+13>>0]=0},this.V=function(v,P){this.$(v),this.X(P),this.Y(),this.W(),this.Z()}}function SA(_){switch(_){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+_)}}var TA=void 0;function OA(_){for(var v="";p[_];)v+=TA[p[_++]];return v}var JA={},YA={},HA={};function kA(_){if(_===void 0)return"_unknown";_=_.replace(/[^a-zA-Z0-9_]/g,"$");var v=_.charCodeAt(0);return 48<=v&&57>=v?"_"+_:_}function rt(_,v){return _=kA(_),new Function("body","return function "+_+`() {
    "use strict";    return body.apply(this, arguments);
};
`)(v)}function $A(_){var v=Error,P=rt(_,function(iA){this.name=_,this.message=iA,iA=Error(iA).stack,iA!==void 0&&(this.stack=this.toString()+`
`+iA.replace(/^Error(:[^\n]*)?\n/,""))});return P.prototype=Object.create(v.prototype),P.prototype.constructor=P,P.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},P}var x=void 0;function y(_){throw new x(_)}var b=void 0;function X(_,v){function P(QA){if(QA=v(QA),QA.length!==iA.length)throw new b("Mismatched type converter count");for(var _A=0;_A<iA.length;++_A)j(iA[_A],QA[_A])}var iA=[];iA.forEach(function(QA){HA[QA]=_});var aA=Array(_.length),IA=[],DA=0;_.forEach(function(QA,_A){YA.hasOwnProperty(QA)?aA[_A]=YA[QA]:(IA.push(QA),JA.hasOwnProperty(QA)||(JA[QA]=[]),JA[QA].push(function(){aA[_A]=YA[QA],++DA,DA===IA.length&&P(aA)}))}),IA.length===0&&P(aA)}function j(_,v,P){if(P=P||{},!("argPackAdvance"in v))throw new TypeError("registerType registeredInstance requires argPackAdvance");var iA=v.name;if(_||y('type "'+iA+'" must have a positive integer typeid pointer'),YA.hasOwnProperty(_)){if(P.U)return;y("Cannot register type '"+iA+"' twice")}YA[_]=v,delete HA[_],JA.hasOwnProperty(_)&&(v=JA[_],delete JA[_],v.forEach(function(aA){aA()}))}var eA=[],sA=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function L(_){4<_&&--sA[_].P===0&&(sA[_]=void 0,eA.push(_))}function k(_){switch(_){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:var v=eA.length?eA.pop():sA.length;return sA[v]={P:1,value:_},v}}function hA(_){return this.fromWireType(U[_>>2])}function BA(_){if(_===null)return"null";var v=typeof _;return v==="object"||v==="array"||v==="function"?_.toString():""+_}function EA(_,v){switch(v){case 2:return function(P){return this.fromWireType(N[P>>2])};case 3:return function(P){return this.fromWireType(G[P>>3])};default:throw new TypeError("Unknown float type: "+_)}}function dA(_){var v=Function;if(!(v instanceof Function))throw new TypeError("new_ called with constructor type "+typeof v+" which is not a function");var P=rt(v.name||"unknownFunctionName",function(){});return P.prototype=v.prototype,P=new P,_=v.apply(P,_),_ instanceof Object?_:P}function yA(_){for(;_.length;){var v=_.pop();_.pop()(v)}}function bA(_,v){var P=A;if(P[_].L===void 0){var iA=P[_];P[_]=function(){return P[_].L.hasOwnProperty(arguments.length)||y("Function '"+v+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+P[_].L+")!"),P[_].L[arguments.length].apply(this,arguments)},P[_].L=[],P[_].L[iA.S]=iA}}function nA(_,v,P){A.hasOwnProperty(_)?((P===void 0||A[_].L!==void 0&&A[_].L[P]!==void 0)&&y("Cannot register public name '"+_+"' twice"),bA(_,_),A.hasOwnProperty(P)&&y("Cannot register multiple overloads of a function with the same number of arguments ("+P+")!"),A[_].L[P]=v):(A[_]=v,P!==void 0&&(A[_].ba=P))}function xA(_,v){for(var P=[],iA=0;iA<_;iA++)P.push(R[(v>>2)+iA]);return P}function O(_,v){0<=_.indexOf("j")||Z("Assertion failed: getDynCaller should only be called with i64 sigs");var P=[];return function(){P.length=arguments.length;for(var iA=0;iA<arguments.length;iA++)P[iA]=arguments[iA];var aA;return _.indexOf("j")!=-1?aA=P&&P.length?A["dynCall_"+_].apply(null,[v].concat(P)):A["dynCall_"+_].call(null,v):aA=tA.get(v).apply(null,P),aA}}function $(_,v){_=OA(_);var P=_.indexOf("j")!=-1?O(_,v):tA.get(v);return typeof P!="function"&&y("unknown function pointer with signature "+_+": "+v),P}var gA=void 0;function pA(_){_=F(_);var v=OA(_);return H(_),v}function FA(_,v){function P(IA){aA[IA]||YA[IA]||(HA[IA]?HA[IA].forEach(P):(iA.push(IA),aA[IA]=!0))}var iA=[],aA={};throw v.forEach(P),new gA(_+": "+iA.map(pA).join([", "]))}function PA(_,v,P){switch(v){case 0:return P?function(iA){return D[iA]}:function(iA){return p[iA]};case 1:return P?function(iA){return w[iA>>1]}:function(iA){return M[iA>>1]};case 2:return P?function(iA){return R[iA>>2]}:function(iA){return U[iA>>2]};default:throw new TypeError("Unknown integer type: "+_)}}var ot={};function zA(){if(!Et){var _={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:o||"./this.program"},v;for(v in ot)_[v]=ot[v];var P=[];for(v in _)P.push(v+"="+_[v]);Et=P}return Et}for(var Et,tt=[null,[],[]],Jt=Array(256),yt=0;256>yt;++yt)Jt[yt]=String.fromCharCode(yt);TA=Jt,x=A.BindingError=$A("BindingError"),b=A.InternalError=$A("InternalError"),A.count_emval_handles=function(){for(var _=0,v=5;v<sA.length;++v)sA[v]!==void 0&&++_;return _},A.get_first_emval=function(){for(var _=5;_<sA.length;++_)if(sA[_]!==void 0)return sA[_];return null},gA=A.UnboundTypeError=$A("UnboundTypeError"),W.push({T:function(){ia()}});var ea={p:function(_){return Li(_+16)+16},o:function(_,v,P){throw new MA(_).V(v,P),_},z:function(_,v,P,iA,aA){var IA=SA(P);v=OA(v),j(_,{name:v,fromWireType:function(DA){return!!DA},toWireType:function(DA,QA){return QA?iA:aA},argPackAdvance:8,readValueFromPointer:function(DA){if(P===1)var QA=D;else if(P===2)QA=w;else if(P===4)QA=R;else throw new TypeError("Unknown boolean type size: "+v);return this.fromWireType(QA[DA>>IA])},M:null})},y:function(_,v){v=OA(v),j(_,{name:v,fromWireType:function(P){var iA=sA[P].value;return L(P),iA},toWireType:function(P,iA){return k(iA)},argPackAdvance:8,readValueFromPointer:hA,M:null})},h:function(_,v,P){P=SA(P),v=OA(v),j(_,{name:v,fromWireType:function(iA){return iA},toWireType:function(iA,aA){if(typeof aA!="number"&&typeof aA!="boolean")throw new TypeError('Cannot convert "'+BA(aA)+'" to '+this.name);return aA},argPackAdvance:8,readValueFromPointer:EA(v,P),M:null})},e:function(_,v,P,iA,aA,IA){var DA=xA(v,P);_=OA(_),aA=$(iA,aA),nA(_,function(){FA("Cannot call "+_+" due to unbound types",DA)},v-1),X(DA,function(QA){var _A=_,NA=_;QA=[QA[0],null].concat(QA.slice(1));var KA=aA,WA=QA.length;2>WA&&y("argTypes array size mismatch! Must at least get return value and 'this' types!");for(var jA=QA[1]!==null&&!1,qA=!1,LA=1;LA<QA.length;++LA)if(QA[LA]!==null&&QA[LA].M===void 0){qA=!0;break}var lt=QA[0].name!=="void",et="",pt="";for(LA=0;LA<WA-2;++LA)et+=(LA!==0?", ":"")+"arg"+LA,pt+=(LA!==0?", ":"")+"arg"+LA+"Wired";NA="return function "+kA(NA)+"("+et+`) {
if (arguments.length !== `+(WA-2)+`) {
throwBindingError('function `+NA+" called with ' + arguments.length + ' arguments, expected "+(WA-2)+` args!');
}
`,qA&&(NA+=`var destructors = [];
`);var Pt=qA?"destructors":"null";for(et="throwBindingError invoker fn runDestructors retType classParam".split(" "),KA=[y,KA,IA,yA,QA[0],QA[1]],jA&&(NA+="var thisWired = classParam.toWireType("+Pt+`, this);
`),LA=0;LA<WA-2;++LA)NA+="var arg"+LA+"Wired = argType"+LA+".toWireType("+Pt+", arg"+LA+"); // "+QA[LA+2].name+`
`,et.push("argType"+LA),KA.push(QA[LA+2]);if(jA&&(pt="thisWired"+(0<pt.length?", ":"")+pt),NA+=(lt?"var rv = ":"")+"invoker(fn"+(0<pt.length?", ":"")+pt+`);
`,qA)NA+=`runDestructors(destructors);
`;else for(LA=jA?1:2;LA<QA.length;++LA)WA=LA===1?"thisWired":"arg"+(LA-2)+"Wired",QA[LA].M!==null&&(NA+=WA+"_dtor("+WA+"); // "+QA[LA].name+`
`,et.push(WA+"_dtor"),KA.push(QA[LA].M));if(lt&&(NA+=`var ret = retType.fromWireType(rv);
return ret;
`),et.push(NA+`}
`),QA=dA(et).apply(null,KA),LA=v-1,!A.hasOwnProperty(_A))throw new b("Replacing nonexistant public symbol");return A[_A].L!==void 0&&LA!==void 0?A[_A].L[LA]=QA:(A[_A]=QA,A[_A].S=LA),[]})},c:function(_,v,P,iA,aA){function IA(NA){return NA}v=OA(v),aA===-1&&(aA=4294967295);var DA=SA(P);if(iA===0){var QA=32-8*P;IA=function(NA){return NA<<QA>>>QA}}var _A=v.indexOf("unsigned")!=-1;j(_,{name:v,fromWireType:IA,toWireType:function(NA,KA){if(typeof KA!="number"&&typeof KA!="boolean")throw new TypeError('Cannot convert "'+BA(KA)+'" to '+this.name);if(KA<iA||KA>aA)throw new TypeError('Passing a number "'+BA(KA)+'" from JS side to C/C++ side to an argument of type "'+v+'", which is outside the valid range ['+iA+", "+aA+"]!");return _A?KA>>>0:KA|0},argPackAdvance:8,readValueFromPointer:PA(v,DA,iA!==0),M:null})},b:function(_,v,P){function iA(IA){IA>>=2;var DA=U;return new aA(S,DA[IA+1],DA[IA])}var aA=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][v];P=OA(P),j(_,{name:P,fromWireType:iA,argPackAdvance:8,readValueFromPointer:iA},{U:!0})},i:function(_,v){v=OA(v);var P=v==="std::string";j(_,{name:v,fromWireType:function(iA){var aA=U[iA>>2];if(P)for(var IA=iA+4,DA=0;DA<=aA;++DA){var QA=iA+4+DA;if(DA==aA||p[QA]==0){if(IA=IA?c(p,IA,QA-IA):"",_A===void 0)var _A=IA;else _A+=String.fromCharCode(0),_A+=IA;IA=QA+1}}else{for(_A=Array(aA),DA=0;DA<aA;++DA)_A[DA]=String.fromCharCode(p[iA+4+DA]);_A=_A.join("")}return H(iA),_A},toWireType:function(iA,aA){aA instanceof ArrayBuffer&&(aA=new Uint8Array(aA));var IA=typeof aA=="string";IA||aA instanceof Uint8Array||aA instanceof Uint8ClampedArray||aA instanceof Int8Array||y("Cannot pass non-string to std::string");var DA=(P&&IA?function(){for(var NA=0,KA=0;KA<aA.length;++KA){var WA=aA.charCodeAt(KA);55296<=WA&&57343>=WA&&(WA=65536+((WA&1023)<<10)|aA.charCodeAt(++KA)&1023),127>=WA?++NA:NA=2047>=WA?NA+2:65535>=WA?NA+3:NA+4}return NA}:function(){return aA.length})(),QA=Li(4+DA+1);if(U[QA>>2]=DA,P&&IA)Q(aA,QA+4,DA+1);else if(IA)for(IA=0;IA<DA;++IA){var _A=aA.charCodeAt(IA);255<_A&&(H(QA),y("String has UTF-16 code units that do not fit in 8 bits")),p[QA+4+IA]=_A}else for(IA=0;IA<DA;++IA)p[QA+4+IA]=aA[IA];return iA!==null&&iA.push(H,QA),QA},argPackAdvance:8,readValueFromPointer:hA,M:function(iA){H(iA)}})},d:function(_,v,P){if(P=OA(P),v===2)var iA=l,aA=E,IA=f,DA=function(){return M},QA=1;else v===4&&(iA=u,aA=d,IA=m,DA=function(){return U},QA=2);j(_,{name:P,fromWireType:function(_A){for(var NA=U[_A>>2],KA=DA(),WA,jA=_A+4,qA=0;qA<=NA;++qA){var LA=_A+4+qA*v;(qA==NA||KA[LA>>QA]==0)&&(jA=iA(jA,LA-jA),WA===void 0?WA=jA:(WA+=String.fromCharCode(0),WA+=jA),jA=LA+v)}return H(_A),WA},toWireType:function(_A,NA){typeof NA!="string"&&y("Cannot pass non-string to C++ string type "+P);var KA=IA(NA),WA=Li(4+KA+v);return U[WA>>2]=KA>>QA,aA(NA,WA+4,KA+v),_A!==null&&_A.push(H,WA),WA},argPackAdvance:8,readValueFromPointer:hA,M:function(_A){H(_A)}})},A:function(_,v){v=OA(v),j(_,{aa:!0,name:v,argPackAdvance:0,fromWireType:function(){},toWireType:function(){}})},n:L,x:function(_){4<_&&(sA[_].P+=1)},C:function(_,v){var P=YA[_];return P===void 0&&y("_emval_take_value has unknown type "+pA(_)),_=P.readValueFromPointer(v),k(_)},t:function(){Z()},r:function(_,v,P){p.copyWithin(_,v,v+P)},s:function(_){_>>>=0;var v=p.length;if(2147483648<_)return!1;for(var P=1;4>=P;P*=2){var iA=v*(1+.2/P);iA=Math.min(iA,_+100663296),iA=Math.max(16777216,_,iA),0<iA%65536&&(iA+=65536-iA%65536);A:{try{g.grow(Math.min(2147483648,iA)-S.byteLength+65535>>>16),T(g.buffer);var aA=1;break A}catch{}aA=void 0}if(aA)return!0}return!1},u:function(_,v){var P=0;return zA().forEach(function(iA,aA){var IA=v+P;for(aA=R[_+4*aA>>2]=IA,IA=0;IA<iA.length;++IA)D[aA++>>0]=iA.charCodeAt(IA);D[aA>>0]=0,P+=iA.length+1}),0},v:function(_,v){var P=zA();R[_>>2]=P.length;var iA=0;return P.forEach(function(aA){iA+=aA.length+1}),R[v>>2]=iA,0},w:function(){return 0},q:function(){},g:function(_,v,P,iA){for(var aA=0,IA=0;IA<P;IA++){for(var DA=R[v+8*IA>>2],QA=R[v+(8*IA+4)>>2],_A=0;_A<QA;_A++){var NA=p[DA+_A],KA=tt[_];NA===0||NA===10?((_===1?s:I)(c(KA,0)),KA.length=0):KA.push(NA)}aA+=QA}return R[iA>>2]=aA,0},a:g,l:function(){return 0},k:function(){return 0},j:function(){},B:function(){return 6},m:function(){},f:function(){}};(function(){function _(aA){A.asm=aA.exports,tA=A.asm.D,AA--,A.monitorRunDependencies&&A.monitorRunDependencies(AA),AA==0&&lA&&(aA=lA,lA=null,aA())}function v(aA){_(aA.instance)}function P(aA){return Promise.resolve().then(fA).then(function(IA){return WebAssembly.instantiate(IA,iA)}).then(aA,function(IA){I("failed to asynchronously prepare wasm: "+IA),Z(IA)})}var iA={a:ea};if(AA++,A.monitorRunDependencies&&A.monitorRunDependencies(AA),A.instantiateWasm)try{return A.instantiateWasm(iA,_)}catch(aA){return I("Module.instantiateWasm callback failed with error: "+aA),!1}return function(){return r||typeof WebAssembly.instantiateStreaming!="function"||wA()||oA("file://")||typeof fetch!="function"?P(v):fetch(uA,{credentials:"same-origin"}).then(function(aA){return WebAssembly.instantiateStreaming(aA,iA).then(v,function(IA){return I("wasm streaming compile failed: "+IA),I("falling back to ArrayBuffer instantiation"),P(v)})})}().catch(e),{}})();var ia=A.___wasm_call_ctors=function(){return(ia=A.___wasm_call_ctors=A.asm.E).apply(null,arguments)},Li=A._malloc=function(){return(Li=A._malloc=A.asm.F).apply(null,arguments)},H=A._free=function(){return(H=A._free=A.asm.G).apply(null,arguments)},F=A.___getTypeName=function(){return(F=A.___getTypeName=A.asm.H).apply(null,arguments)};A.___embind_register_native_and_builtin_types=function(){return(A.___embind_register_native_and_builtin_types=A.asm.I).apply(null,arguments)},A.dynCall_jiiiii=function(){return(A.dynCall_jiiiii=A.asm.J).apply(null,arguments)},A.dynCall_jiji=function(){return(A.dynCall_jiji=A.asm.K).apply(null,arguments)};var J;lA=function _(){J||q(),J||(lA=_)};function q(){function _(){if(!J&&(J=!0,A.calledRun=!0,!C)){if(RA(W),RA(Y),t(A),A.onRuntimeInitialized&&A.onRuntimeInitialized(),A.postRun)for(typeof A.postRun=="function"&&(A.postRun=[A.postRun]);A.postRun.length;){var v=A.postRun.shift();CA.unshift(v)}RA(CA)}}if(!(0<AA)){if(A.preRun)for(typeof A.preRun=="function"&&(A.preRun=[A.preRun]);A.preRun.length;)K();RA(z),0<AA||(A.setStatus?(A.setStatus("Running..."),setTimeout(function(){setTimeout(function(){A.setStatus("")},1),_()},1)):_())}}if(A.run=q,A.preInit)for(typeof A.preInit=="function"&&(A.preInit=[A.preInit]);0<A.preInit.length;)A.preInit.pop()();return q(),i.ready}}(),rv=typeof process<"u"&&process.versions!=null&&process.versions.node!=null,gv=rv?i=>new Uint8Array(Buffer.from(i,"base64")):(()=>{for(var i=new Uint8Array(128),A=0;A<64;A++)i[A<26?A+65:A<52?A+71:A<62?A-4:A*4-205]=A;return t=>{for(var e=t.length,n=new Uint8Array((e-(t[e-1]=="=")-(t[e-2]=="="))*3/4|0),a=0,o=0;a<e;){var s=i[t.charCodeAt(a++)],I=i[t.charCodeAt(a++)],r=i[t.charCodeAt(a++)],g=i[t.charCodeAt(a++)];n[o++]=s<<2|I>>4,n[o++]=I<<4|r>>2,n[o++]=r<<6|g}return n}})(),Iv=gv("AGFzbQEAAAABwAImYAF/AX9gA39/fwF/YAV/f39/fwF/YAJ/fwF/YAJ/fwBgAX8AYAN/f38AYAR/f39/AX9gBH9/f38AYAAAYAZ/f39/f38Bf2AFf39/f38AYAZ/f39/f38AYAd/f39/f39/AX9gBH9/f38BfmAFf39/f38BfmAIf39/f39/f38Bf2AJf39/f39/f39/AX9gAn5/AX9gC39/f39/f39/f39/AX9gA39+fwF+YAN/f34AYAN/f34Bf2ADfn9/AX9gAn5+AX5gCH9/f39/f39/AGAJf39/f39/f39/AGAFf35/f38AYAABf2ANf39/f39/f39/f39/fwF/YA9/f39/f39/f39/f39/f38Bf2AFf39/fn8Bf2AGf3x/f39/AX9gAX8BfmACf38BfmAHf35/f39/fwF+YAF+AX5gBH5/f34BfgK0AR0BYQFiAAYBYQFjAAsBYQFkAAYBYQFlAAwBYQFmAAUBYQFnAAcBYQFoAAYBYQFpAAQBYQFqAAMBYQFrAAABYQFsAAABYQFtAAMBYQFuAAUBYQFvAAYBYQFwAAABYQFxAAIBYQFyAAEBYQFzAAABYQF0AAkBYQF1AAMBYQF2AAMBYQF3AAABYQF4AAUBYQF5AAQBYQF6AAsBYQFBAAQBYQFCAAcBYQFDAAMBYQFhAgGAAoCAAgOtBKsEBAEBAwIACAAAAAQHAQEBAAIBAAQDAQMBBAEFAwUFAAYAAwAIAgIDAQgBAwYBCwEBAAQYBAEEBwoGAwMLBwgBBggDCwUDAwMGCAEGBAYABwIGAAABAAIEBAYEBQMDAAsABgwDAAANBgIYAwkAAQwGBggAAgAAAAUQHQAEAQMbBwcHBwMDBh4TBAgBAgECCgcGCgYEAAQAARARAwAIAAYDBgAFBQUFBQUJCwUGAQAFBQICAgcHAwQEAAcSARIXJQQGAwMDAAUEAQABBQUDAAMGCgAFBQMBHwUDAwUFAREDBwoEAAUBAwcKCiEGBQEABgYGBQUIAxMNAAADAAkBBwcHBwcHBwcAAQgGBwMRAgICAgYCCAoCAgcCCAAFBAUFAAMAAAIKBBQACQwMCwMLCAgICwwAAQEFAAUABQkDAAMSEhcGAQAUAAAJCQkJBgAJCQkJCQkJCQkJCQkJDQ0ABgcBAQcHAgEBAgEEAwoABAcFBRwKCgoFAgoCAgMaGQUE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BCAGanQgAWohASACIARHIQwgBEEBaiEEIAwNAAsLIA1BAWoiDSACayIBIAcgAWtBAWoiCEkEQCAKQQJJIQYDQEEBIQQgBkUEQANAIARBAnQiCiADIAFBNGxqaiADIApqKAIAIAF2NgIAIAIgBEchCiAEQQFqIQQgCg0ACwsgAUEBaiIBIAhJDQALCyAAQQRqIAcgCyAJIANBpAVqIAMgAiANEJYDIAVBAToABSAFIAc6AAYgACAFKAIENgIACyAQIQQLIAVBEGokACAEC+ACAQl/IwBBEGsiBCQAIARBADYCDCAEQQA2AggCQCADQUBrIgkgAyAEQQhqIARBDGogASACEPsBIggQIQ0AIARBBGogACgCABA0QQEhASAEKAIMIgUgBC0ABEEBak0EQEEAIQIgBEEAOgAFIAQgBToABiAAIAQoAgQ2AgAgBUEBakEBSwRAA0AgAyABQQJ0aiIGKAIAIQcgBiACNgIAIAcgAUF/anQgAmohAiABIAVGIQYgAUEBaiEBIAZFDQALCyAEKAIIIgdFDQEgAEEEaiEKIAVBAWohC0EAIQADQCADIAAgCWotAAAiBUECdGoiBigCACIBIAFBASAFdEEBdSIMaiICSQRAIAsgBWshBQNAIAogAUEBdGoiAiAFOgABIAIgADoAACABQQFqIgEgBigCACAMaiICSQ0ACwsgBiACNgIAIABBAWoiACAHRw0ACwwBC0FUIQgLIARBEGokACAICxQAIAAoAABBgPqerQNsQSAgAWt2CygAAkACQAJAIAAoAowBQX9qDgIAAQILIAAgARDCAw8LIAAgARDHAwsLOgEBfyABIAAoAgRrIgEgACgCGCICQYAIaksEQCAAIAEgASACa0GAeGoiAEGABCAAQYAESRtrNgIYCwsVACAAEJEBBEAgACgCBA8LIAAtAAsLRQEBfwJAIAIgA00gACABTXINAANAIABBf2oiAC0AACACQX9qIgItAABHDQEgBEEBaiEEIAIgA00NASAAIAFLDQALCyAECwwAIABBICABa62IpwsQACAAIAEgAigCCHRBA3RqCxIAIABBwAAgAWutiKdBACABGwsvAEEgIAFrIgEgAkkEQCAAp0F/IAJ0QX9zcQ8LIAAgASACa62Ip0F/IAJ0QX9zcQsgACACrSAAIAGtQgp8IAN+fULjyJW9y5vvjU9+fEIK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nn9+QuPcypX8zvL1hX98IQYgBCIDIgFBCGoiBCACTQ0ACwsCQCADQQRqIgEgAksEQCADIQEMAQsgAygAAK1Ch5Wvr5i23puef34gBoVCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQYLIAEgAkkEQCAAIAVqQShqIQADQCABMQAAQsXP2bLx5brqJ34gBoVCC4lCh5Wvr5i23puef34hBiABQQFqIgEgAEcNAAsLIAZCIYggBoVCz9bTvtLHq9lCfiIGQh2IIAaFQvnz3fGZ9pmrFn4iBkIgiCAGhQv4AgICfwR+IAAgACkDACACrXw3AwACQAJAIAAoAkgiAyACakEfTQRAIAAgA2pBKGogASACEKsBIAAoAkggAmohAQwBCyABIAJqIQQCQAJ/IAMEQCAAQShqIgIgA2ogAUEgIANrEKsBIAAgACkDCCACKQAAEE43AwggACAAKQMQIAApADAQTjcDECAAIAApAxggACkAOBBONwMYIAAgACkDICAAQUBrKQAAEE43AyAgACgCSCECIABBADYCSCABIAJrQSBqIQELIAFBIGogBEsLBEAgASECDAELIARBYGohAyAAKQMgIQUgACkDGCEGIAApAxAhByAAKQMIIQgDQCAIIAEpAAAQTiEIIAcgASkACBBOIQcgBiABKQAQEE4hBiAFIAEpABgQTiEFIAFBIGoiAiEBIAIgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyACIARPDQEgAEEoaiACIAQgAmsiARCrAQsgACABNgJICwtlACAAQgA3AyggAEL56tDQ58mh5OEANwMgIABCADcDGCAAQs/W077Sx6vZQjcDECAAQtbrgu7q/Yn14AA3AwggAEIANwMAIABCADcDMCAAQgA3AzggAEFAa0IANwMAIABCADcDSAsVACABBEAgAiAAIAERAwAPCyAAEEwLYQEDf0F+IQECQCAARQ0AIAAoAhwiAkUNACAAKAIkIgNFDQAgAigCNCIBBEAgACgCKCABIAMRBAAgACgCJCEDIAAoAhwhAgsgACgCKCACIAMRBABBACEBIABBADYCHAsgAQudCwEMfyACQQBOBEBBBEEDIAEvAQIiCxshB0EHQYoBIAsbIQQgAEG5LWohCEF/IQYDQCALIQkCQCAJIAEgDCINQQFqIgxBAnRqLwECIgtH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AhQgCiAAKAIIaiADOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogAEG5LWotAAA6AAAgACABQRAgACgCvC0iAWt2OwG4LSAAIAEgAmpBcGo2ArwtDwsgACACIARqNgK8LQuXAQECfwJAAn8gACgCvC0iAUEJTgRAIAAgACgCFCIBQQFqNgIUIAEgACgCCGogAC0AuC06AAAgACAAKAIUIgFBAWo2AhQgAEG5LWotAAAhAiABIAAoAghqDAELIAFBAUgNASAAIAAoAhQiAUEBajYCFCAALQC4LSECIAEgACgCCGoLIAI6AAALIABBADYCvC0gAEEAOwG4LQvaBAEBfwNAIAAgAUECdGpBADsBlAEgAUEBaiIBQZ4CRw0ACyAAQQA7AfwUIABBADsBiBMgAEHEFWpBADsBACAAQcAVakEAOwEAIABBvBVqQQA7AQAgAEG4FWpBADsBACAAQbQVakEAOwEAIABBsBVqQQA7AQAgAEGsFWpBADsBACAAQagVakEAOwEAIABBpBVqQQA7AQAgAEGgFWpBADsBACAAQZwVakEAOwEAIABBmBVqQQA7AQAgAEGUFWpBADsBACAAQZAVakEAOwEAIABBjBVqQQA7AQAgAEGIFWpBADsBACAAQYQVakEAOwEAIABBgBVqQQA7AQAgAEH8E2pBADsBACAAQfgTakEAOwEAIABB9BNqQQA7AQAgAEHwE2pBADsBACAAQewTakEAOwEAIABB6BNqQQA7AQAgAEHkE2pBADsBACAAQeATakEAOwEAIABB3BNqQQA7AQAgAEHYE2pBADsBACAAQdQTakEAOwEAIABB0BNqQQA7AQAgAEHME2pBADsBACAAQcgTakEAOwEAIABBxBNqQQA7AQAgAEHAE2pBADsBACAAQbwTakEAOwEAIABBuBNqQQA7AQAgAEG0E2pBADsBACAAQbATakEAOwEAIABBrBNqQQA7AQAgAEGoE2pBADsBACAAQaQTakEAOwEAIABBoBNqQQA7AQAgAEGcE2pBADsBACAAQZgTakEAOwEAIABBlBNqQQA7AQAgAEGQE2pBADsBACAAQYwTakEAOwEAIABCADcCrC0gAEGUCWpBATsBACAAQQA2AqgtIABBADYCoC0LngEBAn8gACAALwG4LSADQf//A3EiBCAAKAK8LSIDdHIiBTsBuC0gAAJ/IANB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A0AgCSAFIARBAXRqIgotAAEiC0ECdGoiDCgCACEDIAlBPGogCi0AAEEIdCAIakH//wNxEC8gCUECOgA/IAkgByALayIKIAJqOgA+IANBASABIAprdGohCiAJKAI8IQsDQCAAIANBAnRqIAs2AQAgA0EBaiIDIApJDQALIAwgCjYCACAEQQFqIgQgBkcNAAsLIAlBQGskAAvdAgEJfyMAQdAAayIJJAAgCUFAayAFKAIwNgIAIAkgBSkCKDcDOCAJIAUpAiA3AzAgCSAFKQIYNwMoIAkgBSkCEDcDICAJIAUpAgA3AxAgCSAFKQIINwMYIAMEQCAHIAZrIQ8gByABayEQA0BBASABIAcgAiALQQF0aiIGLQABIgxrIghrIgp0IQ0gBi0AACEOIAlBEGogDEECdGoiDCgCACEGAkAgCiAPTwRAIAAgBkECdGogCiAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QlQMgBiANaiEIDAELIAlBDGogDhAvIAlBAToADyAJIAg6AA4gBiAGIA1qIghPDQAgCSgCDCEKA0AgACAGQQJ0aiAKNgEAIAZBAWoiBiAIRw0ACwsgDCAINgIAIAtBAWoiCyADRw0ACwsgCUHQAGokAAs+AQN/IAAEQCAAKAIAIABBvNABaigCACIBIABBwNABaigCACICIABBxNABaigCACIDEGQgACABIAIgAxBkCwvMAQEBfyAAIAEoArTQATYCmOIBIAAgASgCBCICNgLA4AEgACACNgK84AEgACACIAEoAghqIgI2ArjgASAAIAI2AsTgASABKAK40AEEQCAAQoGAgIAQNwOI4QEgACABQaTQAGo2AgwgACABQZQgajYCCCAAIAFBnDBqNgIEIAAgAUEMajYCACAAQazQAWogAUGo0AFqKAIANgIAIABBsNABaiABQazQAWooAgA2AgAgAEG00AFqIAFBsNABaigCADYCAA8LIABCADcDiOEBC6JIAS5/IwBB4ABrIhIkACAAKAKEASEGIAAoAgQhByAAKAKIASEFIAAoAgwhCCASIAAoAhg2AlwgACgCPCEbIABBQGsoAgAhHCAAQSxqIiYgAyAEQQIQWSADIAcgCGogA0ZqIg0gAyAEaiIMQXhqIi5JBEAgBUH/HyAFQf8fSRsh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AnRBsKcBaigCABBHIAtBOGoQOSALQThqIAAvAQYgAi0AAEECdEGQpAFqKAIAEEcgC0E4ahA5AkAgCgRAIAEtAAAiASABQRggAUEYSRsiAmsiAQRAIAtBOGogACgCACABEEcgC0E4ahA5CyALQThqIAAoAgAgAXYgAhBHDAELIAtBOGogACgCACABLQAAEEcLIAtBOGoQOSAJQQJPBEAgCUF+aiEMA0AgByAMai0AACECIAMgDGotAAAhBCALQThqIAtBGGogBSAMai0AACIAEGwgC0E4aiALQShqIAQQbCALQThqEDkgC0E4aiALQQhqIAIQbCALQThqEDkgC0E4aiAIIAxBA3RqIgEvAQQgAkECdEGwpwFqKAIAIgIQRyACIARBAnRBkKQBaigCACICakEZTwRAIAtBOGoQOQsgC0E4aiABLwEGIAIQRyALQThqEDkCQCAKBEAgACAAQRggAEEYSRsiAmsiAARAIAtBOGogASgCACAAEEcgC0E4ahA5CyALQThqIAEoAgAgAHYgAhBHDAELIAtBOGogASgCACAAEEcLIAtBOGoQOSAMQX9qIgwgCUkNAAsLIAtBOGogCygCKCALKAI0EHQgC0E4aiALKAIYIAsoAiQQdCALQThqIAsoAgggCygCFBB0IAtBOGoQ/QEiAEG6fyAAGyEMCyALQdAAaiQAIAwLLwAgACACQQN0aigCBCIAQRB2QQFqIgJBCHRBfyABdCAAayACQRB0akEIdCABdmsLTwEEfwNAIANBASAAIARBAnRqKAIAIgNBCHQiBSACbiIGIAUgAkkbIAYgAxtBAnRBkJwBaigCACADbGohAyAEQQFqIgQgAU0NAAsgA0EIdgtKAQF/IwBB8ARrIgQkACAEIAMgAiABEKcBIgMgACACIAEQpgEiAhAhRQRAIARB8ABqQYAEIAQgASADEKgBIQILIARB8ARqJAAgAguKAQEIfyMAQRBrIgMkACADIAAQc0F/IQUCQCAALwACIAJJDQAgAygCDCIHQQh0QYACaiEIIAMoAgghCUEAIQADQCAJIAcgABDJAyEGIAEgAEECdGooAgAiCgRAIAYgCE8NAiAGIApsIARqIQQLIABBAWoiACACTQ0ACyAEQQh2IQULIANBEGokACAFC18BAn9BCCABayEFQQAhAQNAIARBASAAIAFBAXRqLwEAIgQg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ASACEEUiARAhDQEgBEEQaiAEQRhqIAMQggEgBEEIaiAEQRhqIAMQggFBACEBAkAgBEEYahAjBEBBACEDDAELA0AgACABaiICIARBEGogBEEYahBiOgAAIAIgBEEIaiAEQRhqEGI6AAEgBEEYahAjBEAgAUECciEDDAILIAIgBEEQaiAEQRhqEGI6AAIgAiAEQQhqIARBGGoQYjoAAyABQQRqIQMgBEEYahAjIQIgAUH3AUsNASADIQEgAkUNAAsLAn8DQEG6fyEBIANB/QFLDQMgACADaiICIARBEGogBEEYahBiOgAAIAIiBkEBaiEFIARBGGoQI0EDRgRAQQIhAyAEQQhqDAILIANB/AFLDQMgBiAEQQhqIARBGGoQYjoAASADQQJqIQMgBEEYahAjQQNHDQALIAAgA2ohBUEDIQMgBEEQagshASAFIAEgBEEYahBiOgAAIAIgA2ogAGshAQwBCyAEQRhqIAEgAhBFIgEQIQ0AIARBEGogBEEYaiADEIIBIARBCGogBEEYaiADEIIBQQAhAQJAIARBGGoQIwRAQQAhAwwBCwNAIAAgAWoiAiAEQRBqIARBGGoQYToAACACIARBCGogBEEYahBhOgABIARBGGoQIwRAIAFBAnIhAwwCCyACIARBEGogBEEYahBhOgACIAIgBEEIaiAEQRhqEGE6AAMgAUEEaiEDIARBGGoQIyECIAFB9wFLDQEgAyEBIAJFDQALCwJ/A0BBun8hASADQf0BSw0CIAAgA2oiAiAEQRBqIARBGGoQYToAACACIgZBAWohBSAEQRhqECNBA0YEQEECIQMgBEEIagwCCyADQfwBSw0CIAYgBEEIaiAEQRhqEGE6AAEgA0ECaiEDIARBGGoQI0EDRw0ACyAAIANqIQVBAyEDIARBEGoLIQEgBSABIARBGGoQYToAACACIANqIABrIQELIARBMGokACABC68DAQp/IwBBgARrIgkkAEFSIQUCQCACQf8BSw0AIABBBGohCkGAgAQgA0F/anRBEHUhC0EBIAN0IghBf2oiDCEHQQEhBQNAAkAgASAEQQF0Ig1qLwEAIgZB//8DRgRAIAogB0ECdGogBDoAAiAHQX9qIQdBASEGDAELIAVBACALIAZBEHRBEHVKGyEFCyAJIA1qIAY7AQAgAiAERyEGIARBAWohBCAGDQALIAAgBTsB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IAIgASgCCGpBADoAACABIAEoAhQiAkEBajYCFCACIAEoAghqQQA6AABBAiECIAEoAoQBIgNBCUcEQEEEIAEoAogBQQFKQQJ0IANBAkgbIQILIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAACABIAEoAhQiAkEBajYCFCACIAEoAghqQQM6AAAgAUHxADYCBAwNCyACKAIkIQMgAigCHCEEIAIoAhAhBSACKAIsIQYgAigCACEHIAEgASgCFCIIQQFqNgIUQQIhAiAIIAEoAghqIAZBAEdBAXQgB0EAR3IgBUEAR0ECdHIgBEEAR0EDdHIgA0EAR0EEdHI6AAAgASgCHCgCBCEDIAEgASgCFCIEQQFqNgIUIAQgASgCCGogAzoAACABKAIcKAIEIQMgASABKAIUIgRBAWo2AhQgBCABKAIIaiADQQh2OgAAIAEoAhwvAQYhAyABIAEoAhQiBEEBajYCFCAEIAEoAghqIAM6AAAgASgCHC0AByEDIAEgASgCFCIEQQFqNgIUIAQgASgCCGogAzoAACABKAKEASIDQQlHBEBBBCABKAKIAUEBSkECdCADQQJIGyECCyABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAgASgCHCgCDCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAAAJ/IAEoAhwiBCgCEARAIAQoAhQhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAgASgCHCgCFCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAkEIdjoAACABKAIcIQQLIAQoAiwLBEAgACAAKAIwIAEoAgggASgCFBA1NgIwCyABQcUANgIEIAFBADYCIAwCCyABKAIwQQx0QYCQfmohBEEAIQICQCABKAKIAUEBSg0AIAEoAoQBIgNBAkgNAEHAACECIANBBkgNAEGAAUHAASADQQZGGyECCyABQfEANgIEIAEgAiAEciICQSByIAIgASgCbBsiAkEfcCACckEfcxB1IAEoAmwEQCABIAAvATIQdSABIAAvATAQdQsgAEEAQQBBABBlNgIwIAEoAgQhAgsgAkHFAEcNASABKAIcIQQLAkAgBCgCEARAIAEoAhQhAiABKAIgIgUgBC8BFE8NASACIQMDQCABKAIMIAJGBEACQCACIANNDQAgBCgCLEUNACAAIAAoAjAgASgCCCADaiACIANrEDU2AjALIAAQNiABKAIcIQQgASgCFCICIAEoAgxGDQMgASgCICEFIAIhAwsgBCgCECAFai0AACEEIAEgAkEBajYCFCABKAIIIAJqIAQ6AAAgASABKAIgQQFqIgU2AiAgBSABKAIcIgQvARRPBEAgAyECDAMFIAEoAhQhAgwBCwALAAsgAUHJADYCBAwCCwJAIAQoAixFDQAgASgCFCIDIAJNDQAgACAAKAIwIAEoAgggAmogAyACaxA1NgIwCyABKAIgIAQoAhRGBEAgAUHJADYCBCABQQA2AiAMAgsgASgCBCECCyACQckARw0BIAEoAhwhBAsgBCgCHEUNAiABKAIUIgIhAwJAA0ACQCABKAIMIAJGBEACQCACIANNDQAgASgCHCgCLEUNACAAIAAoAjAgASgCCCADaiACIANrEDU2AjALIAAQNiABKAIUIgIgASgCDEYNASACIQMLQQEhBSABKAIcKAIcIQQgASABKAIgIgZBAWo2AiAgBCAGai0AACEEIAEgAkEBajYCFCABKAIIIAJqIAQ6AAAgBARAIAEoAhQhAgwCBSADIQIMAwsACwtBACEFCwJAIAEoAhwiBCgCLEUNACABKAIUIgMgAk0NACAAIAAoAjAgASgCCCACaiADIAJrEDU2AjALIAUNASABKAIEIQILIAJB2wBHDQMgASgCHCEEDAILIAFBADYCIAsgAUHbADYCBAsgBCgCJEUNASABKAIUIgIhAwJAA0ACQCABKAIMIAJGBEACQCACIANNDQAgASgCHCgCLEUNACAAIAAoAjAgASgCCCADaiACIANrEDU2AjALIAAQNiABKAIUIgIgASgCDEYNASACIQMLQQEhBSABKAIcKAIkIQQgASABKAIgIgZBAWo2AiAgBCAGai0AACEEIAEgAkEBajYCFCABKAIIIAJqIAQ6AAAgBARAIAEoAhQhAgwCBSADIQIMAwsACwtBACEFCwJAIAEoAhwiBCgCLEUNACABKAIUIgMgAk0NACAAIAAoAjAgASgCCCACaiADIAJrEDU2AjALIAUNASABKAIEIQILIAJB5wBHDQIgASgCHCEEDAELIAFB5wA2AgQLIAQoAiwEQCABKAIUIgVBAmoiAiABKAIMIgRLBH8gABA2IAEoAgwhBCABKAIUIgVBAmoFIAILIARLDQEgACgCMCECIAEgBUEBajYCFCABKAIIIAVqIAI6AAAgACgCMCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAkEIdjoAACAAQQBBAEEAEDU2AjAgAUHxADYCBAwBCyABQfEANgIECwJAIAEoAhQEQCAAEDYgACgCEARAIAAoAgQhAgwCCwwECyAAKAIEIgINAEEAIQILAkACQAJAIAEoAgQiA0GaBUYEQCACRQ0BDAULIAINAQsgA0GaBUcNACABKAJ0RQ0BCwJ/AkACQAJAIAEoAogBQX5qDgIAAQILIAEQnQQMAgsgARCcBAwBCyABQQQgASgChAFBDGxBuNcAaigCABEDAAsiAkF+cUECRgRAIAFBmgU2AgQLIAJBfXFFBEBBACECIAAoAhANAgwECyACQQFHDQAgAUEAQQBBABCOAiAAEDYgACgCEA0ADAMLQQEhAiABKAIYIgNBAUgNACAAKAIwIQICQCADQQJGBEAgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAAIAAoAjAhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAJBCHY6AAAgAC8BMiECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAACAALQAzIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAAIAAoAgghAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAgACgCCCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAkEIdjoAACAALwEKIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAAIAAtAAshAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAMAQsgASACQRB2EHUgASAALwEwEHULIAAQNiABKAIYIgBBAU4EQCABQQAgAGs2AhgLIAEoAhRFIQILIAIPCyAAQceEATYCGEF7DwsgAUF/NgIoQQAL3QEBBn8CQCAAKAKAgBAiBSAAKAKEgBAiAyAAKAKMgBAiBGpBBGpJDQAgACgClIAQIgIgBSADa0F9aiIGTw0AA0AgACACQf//A3FBAXRqQYCACGogAiAAIAIgA2oQOkECdGoiBCgCAGsiB0H//wMgB0H//wNJGzsBACAEIAI2AgAgAkEBaiICIAZJDQALIAAoAoyAECEECyAAIAQ2ApCAECAAIAM2AoiAECAAQQA2ApyAECAAIAE2AoCAECAAIAUgA2siAjYCjIAQIAAgAjYClIAQIAAgASACazYChIAQC9kDAQR/IwBBEGsiAyQAIAFBADYCACAAKAIAIgIgA0EMaiACKAIAKAIMEQMAIQICQCADKAIMRQ0AIAIsAAAhAiAAKAIAIgRBASAEKAIAKAIQEQQAIAEgASgCACACQf8AcXI2AgACQCACQX9KDQAgACgCACICIANBDGogAigCACgCDBEDACECIAMoAgxFDQEgAiwAACECIAAoAgAiBEEBIAQoAgAoAhARBAAgASABKAIAIAJB/wBxQQd0cjYCACACQX9KDQAgACgCACICIANBDGogAigCACgCDBEDACECIAMoAgxFDQEgAiwAACECIAAoAgAiBEEBIAQoAgAoAhARBAAgASABKAIAIAJB/wBxQQ50cjYCACACQX9KDQAgACgCACICIANBDGogAigCACgCDBEDACECIAMoAgxFDQEgAiwAACECIAAoAgAiBEEBIAQoAgAoAhARBAAgASABKAIAIAJB/wBxQRV0cjYCACACQX9KDQAgACgCACICIANBDGogAigCACgCDBEDACECIAMoAgxFDQEgAiwAACEFIAAoAgAiAEEBIAAoAgAoAhARBAAgASABKAIAIAVBHHRyNgIAIAVBf0oNAEEAIQUMAQtBASEFCyADQRBqJAAgBQvhSQE3fwJAIAAoAoCAECIJIAAoAoSAECILayAAKAKQgBBrIghBgIAETwRAIABBADYCnIAQDAELAkAgCA0AIAMoAgBBgSBIDQAgACAAKAKcgBBBoIAQECoiACABEKwEIAAgBTsBmIAQDAELAkAgBEEATEEAIAZBAkYbDQAgAygCACIIQYCAgPAHSw0AIAAgCCAJajYCgIAQQQkgBSAFQQFIGyIFQQwgBUEMSBsiG0EMbCIJQZQWaigCACEuAkACfyAbQQlNBEAgA0EANgIAIAIgBGoiOkF7aiA6IAZBAkYiOxshKSABIAhqITMgASEoIAIhCQJAIAhBDUgNACAzQXRqIjIgAUkNAEGANCAbdkEBcSE0IDNBe2oiGEF/aiEvIBhBfWohIkEAIRsDQCAAKAKUgBAhBCAAKAKIgBAhEyAAKAKcgBAhFCAoIQwDQCAAKAKQgBAiBSAMIAtrIh9BgYB8aiAFQYCABGogH0sbIRUgACgC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BEADQCADKAAAIAQoAABzIgkEQCAJECUgBGogAGsMBAsgA0EEaiEDIARBBGoiBCAUSQ0ACwsCQCAEIBhPDQAgAy8AACAELwAARw0AIANBAmohAyAEQQJqIQQLIAQgF0kEfyAEQQFqIAQgAy0AACAELQAARhsFIAQLIABrDAELIAMQJQsiAEHwAWpB/wFuakEIaiAPSw0EIAdBAmohAyAAIAZqQQRqIQYgBS0AACEEAn8gAEEPTwRAIAUgBEEPajoAACADQX8QNCAAQXFqIgRB/AdPBEADQCADQQRqIgNBfxA0IARBhHhqIgRB+wdLDQALCyADIARB//8DcUH/AW4iAGoiAyAAQYF+bCAEajoAACADQQFqDAELIAUgACAEajoAACADCyEFIAYgEU8NASAGQX5qIgAgACgAACALEDAgCCALIAwQSSAGKAAAIQACQAJAIBZFBEAgAEEBEDAiACAIEIUBIQQgBiAAIAhBASAMEEkgBEH//wNqIAZJDQEgBCgAACAGKAAARw0BDAILIAAgCxAwIgMgCCALEEghACAGIAxrIgQgAyAIIAsQXCAAQf//A2ogBEkNACAAIAxqIgQoAAAgBigAAEYNAQsgBkEBaiIDKAAAIAsQMCEEDAMLIAVBADoAACAFQQFqIQcMAAsACwtBACETIAUgECAGayIBaiABQfABakH/AW5qQQFqIA9LDQECQCABQQ9PBEAgBUHwAToAACAFQQFqIQAgAUFxaiIDQf8BSQRAIAAiBSADOgAADAILIABB/wEgAUHyfWoiAEH/AW5BAWoQKBogAEH/AW4iAyAFakECaiIFIANBgX5sIABqOgAADAELIAUgAUEEdDoAAAsgBUEBaiAGIAEQKiABaiACayETDAELIANBgICA8AdLDQAgASADaiIPQXVqIRAgD0F0aiEUIAgoAoCAASEAIAhBAUECIAFB//8DSxsiCzsBhoABIAggACADajYCgIABIAggCCgCkIABIANqNgKQgAEgASABKAAAIAsQMCAIIAsgASAAayIMEEkgD0F7aiITQX9qIRcgE0F9aiERIAZBBnQiCkEBciENIAFBAWoiAygAACALEDAhBCABQYCABEkhFSACIQUgASEGA0ACQCAVRQRAIAMgFEsNBCADQQFqIQ4gCiEJIA0hBwNAIAQgCBCFASEAIA4oAABBARAwIRIgAyAE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IAJBCE8EQANAIAMEQCADIAVsIQcgBUEHciIIIANsIQkgBUEGciIKIANsIQsgBUEFciIMIANsIQ0gBUEEciIOIANsIQ8gBUEDciIQIANsIREgBUECciISIANsIRMgBUEBciIUIANsIRVBACEEA0AgASAFIAIgBGwiBmpqIAAgBCAHamotAAA6AAAgASAGIBRqaiAAIAQgFWpqLQAAOgAAIAEgBiASamogACAEIBNqai0AADoAACABIAYgEGpqIAAgBCARamotAAA6AAAgASAGIA5qaiAAIAQgD2pqLQAAOgAAIAEgBiAMamogACAEIA1qai0AADoAACABIAYgCmpqIAAgBCALamotAAA6AAAgASAGIAhqaiAAIAQgCWpqLQAAOgAAIARBAWoiBCADRw0ACwsgBUEPaiEEIAVBCGohBSAEIAJJDQALCyACQXhxIgUgAk8NAANAIAMEQCADIAVsIQZBACEEA0AgASACIARsIAVqaiAAIAQgBmpqLQAAOgAAIARBAWoiBCADRw0ACwsgBUEBaiIFIAJHDQALCyACIANsrQuCAQEGfyABIAEgAG4iBiAAbGshByAAIAFNBEAgBkEBIAZBAUsbIQgDQCAABEAgACAEbCEJQQAhBQNAIAMgBSAJamogAiAFIAZsIARqai0AADoAACAFQQFqIgUgAEcNAAsLIARBAWoiBCAIRw0ACwsgAyABIAdrIgBqIAAgAmogBxAqGgsNACAAIAEgAiADEL0EC4IBAQZ/IAEgASAAbiIGIABsayEHIAAEQCAGQQEgBkEBSxshCANAIAAgAU0EQCAEIAZsIQlBACEFA0AgAyAFIAlqaiACIAAgBWwgBGpqLQAAOgAAIAVBAWoiBSAIRw0ACwsgBEEBaiIEIABHDQALCyADIAEgB2siAGogACACaiAHECoaC7gBAQN/AkAgAUEBSA0AIAAsAAAiBEH/AHEhAwJAIARBf0oNACABQQJIDQEgACwAASIEQQd0QYD/AHEgA3IhAyAEQX9KDQAgAUEDSA0BIAAsAAIiBEEOdEGAgP8AcSADciEDIARBf0oNACABQQRIDQEgACwAAyIEQRV0QYCAgP8AcSADciEDIARBf0oNACABQQVIDQEgAC0ABCIAQQ9LDQEgAEEcdCADciEDCyACIAM2AgBBASEFCyAFCw0AIAAgASACIAMQvwQLlAIBA38gACABEDcaIAJBA3YiBEH4////AXEhAyABIAJBB3EiBWohAiAAIAVqIQACQAJAAkACQAJAAkACQAJAIARBB3FBf2oOBwYFBAMCAQAHCyAAIAIQNyEAIAJBCGohAgsgACACEDchACACQQhqIQILIAAgAhA3IQAgAkEIaiECCyAAIAIQNyEAIAJBCGohAgsgACACEDchACACQQhqIQILIAAgAhA3IQAgAkEIaiECCyAAIAIQNyEAIAJBCGohAgsgAwRAA0AgACACEDcgAkEIahA3IAJBEGoQNyACQRhqEDcgAkEgahA3IAJBKGoQNyACQTBqEDcgAkE4ahA3IQAgAkFAayECIANBeGoiAw0ACwsgAAstACACBEADQCAAIAEtAAA6AAAgAEEBaiEAIAFBAWohASACQX9qIgINAAsLIAALvQUBA38gACABayIDQQlPBEAgACABIAIQUA8LAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIANBfmpBH3cOEAABDAIMDAwDBAUGBwgJCgsMCyACQQFNDQwDQCAAIAEQeCEAIAJBfmoiAkEBSw0ACwwMCyACQQNNDQsDQCAAIAEQdyEAIAJBfGoiAkEDSw0ACwwLCyACQQdNDQoDQCAAIAEQNyEAIAJBeGoiAkEHSw0ACwwKCyACQQ9NDQkDQCAAIAEQViEAIAJBcGoiAkEPSw0ACwwJCyACQRJJDQggAUEQaiEDA0AgACABEFYgAxB4IQAgAkFuaiICQRFLDQALDAgLIAJBFEkNByABQRBqIQMDQCAAIAEQViADEHchACACQWxqIgJBE0sNAAsMBwsgAkEWSQ0GIAFBFGohAyABQRBqIQQDQCAAIAEQViAEEHcgAxB4IQAgAkFqaiICQRVLDQALDAYLIAJBGEkNBSABQRBqIQMDQCAAIAEQViADEDchACACQWhqIgJBF0sNAAsMBQsgAkEaSQ0EIAFBGGohAyABQRBqIQQDQCAAIAEQViAEEDcgAxB4IQAgAkFmaiICQRlLDQALDAQLIAJBHEkNAyABQRhqIQMgAUEQaiEEA0AgACABEFYgBBA3IAMQdyEAIAJBZGoiAkEbSw0ACwwDCyACQR5JDQIgAUEcaiEDIAFBGGohBCABQRBqIQUDQCAAIAEQViAFEDcgBBB3IAMQeCEAIAJBYmoiAkEdSw0ACwwCCyACQR9NDQEDQCAAIAEQlAIhACACQWBqIgJBH0sNAAsMAQsgAkUNAQNAIAAgAS0AADoAACAAQQFqIQAgAUEBaiEBIAJBf2oiAg0ACwwBCyACRQ0AA0AgACABLQAAOgAAIABBAWohACABQQFqIQEgAkF/aiICDQALCyAAC7EBAgJ/An4gAEF/ai0AACEDAkACQCABQXhqIgQgAE0NACADrUL/AYNCgYKEiJCgwIABfiEFA0AgAikAACIGIAVRBEAgAkEIaiECIABBCGoiACAESQ0BDAILCyAGp0H/AXEgA0cNAQNAIABBAWohACACLQABIQEgAkEBaiECIAEgA0YNAAsMAQsgACABTw0AA0AgAi0AACADRw0BIAJBAWohAiAAQQFqIgAgAUkNAAsLIAALJgEBf0ECIQQgAygCACABEJUCTwR/IAAgASACIAMQlQRBAAUgBAsLC8zcATgAQYAIC4MGTjZzbmFwcHk0U2lua0UAABh0AAAABAAATjZzbmFwcHk2U291cmNlRQAAAAAYdAAAGAQAAAAAAABsBAAAAQAAAAIAAAADAAAABAAAAAUAAABONnNuYXBweTE1Qnl0ZUFycmF5U291cmNlRQAAjHIAAFAEAAAsBAAAAAAAALQEAAAGAAAABwAAAAgAAAAJAAAATjZzbmFwcHkyMlVuY2hlY2tlZEJ5dGVBcnJheVNpbmtFAAAAjHIAAJAEAAAQBAAAAQAECAEQASACAAUIAhACIAMABggDEAMgBAAHCAQQBCAFAAgIBRAFIAYACQgGEAYgBwAKCAcQByAIAAsICBAIIAkABAkJEAkgCgAFCQoQCiALAAYJCxALIAwABwkMEAwgDQAICQ0QDSAOAAkJDhAOIA8ACgkPEA8gEAALCRAQECARAAQKERARIBIABQoSEBIgEwAGChMQEyAUAAcKFBAUIBUACAoVEBUgFgAJChYQFiAXAAoKFxAXIBgACwoYEBggGQAECxkQGSAaAAULGhAaIBsABgsbEBsgHAAHCxwQHCAdAAgLHRAdIB4ACQseEB4gHwAKCx8QHyAgAAsLIBAgICEABAwhECEgIgAFDCIQIiAjAAYMIxAjICQABwwkECQgJQAIDCUQJSAmAAkMJhAmICcACgwnECcgKAALDCgQKCApAAQNKRApICoABQ0qECogKwAGDSsQKyAsAAcNLBAsIC0ACA0tEC0gLgAJDS4QLiAvAAoNLxAvIDAACw0wEDAgMQAEDjEQMSAyAAUOMhAyIDMABg4zEDMgNAAHDjQQNCA1AAgONRA1IDYACQ42EDYgNwAKDjcQNyA4AAsOOBA4IDkABA85EDkgOgAFDzoQOiA7AAYPOxA7IDwABw88EDwgAQgIDz0QPSABEAkPPhA+IAEYCg8/ED8gASALD0AQQCAAAAAA/wAAAP//AAD///8A/////2RlY29tcHJlc3MAY29tcHJlc3MAZnJlZV9yZXN1bHQAdmkAAHhzAABpaWlpaWlpAEGQDgvUBigHAAAwBwAAMAcAAMxzAADMcwAAzHMAABh0AAC2BwAAQHQAAEgHAAAAAAAAAQAAAIgHAAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAABh0AACQBwAATlN0M19fMjIxX19iYXNpY19zdHJpbmdfY29tbW9uSUxiMUVFRQBOMTBlbXNjcmlwdGVuM3ZhbEUAAAAAGHQAANQHAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAaWlpAAAoBwAAMAcAABgIAAAgCAAAJAgAACoIAAAxCAAANggAAGJsb3NjbHoAbHo0AGx6NGhjAHNuYXBweQB6bGliAHpzdGQARXJyb3IuICBudGhyZWFkcyBjYW5ub3QgYmUgbGFyZ2VyIHRoYW4gQkxPU0NfTUFYX1RIUkVBRFMgKCVkKQBFcnJvci4gIG50aHJlYWRzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyAEVSUk9SOyByZXR1cm4gY29kZSBmcm9tIHB0aHJlYWRfY3JlYXRlKCkgaXMgJWQKAAlFcnJvciBkZXRhaWw6ICVzCgBCbG9zYyBoYXMgbm90IGJlZW4gY29tcGlsZWQgd2l0aCAnJXMnIABjb21wcmVzc2lvbiBzdXBwb3J0LiAgUGxlYXNlIHVzZSBvbmUgaGF2aW5nIGl0LgBFcnJvciBhbGxvY2F0aW5nIG1lbW9yeSEARVJST1I7IHJldHVybiBjb2RlIGZyb20gcHRocmVhZF9qb2luKCkgaXMgJWQKAElucHV0IGJ1ZmZlciBzaXplIGNhbm5vdCBleGNlZWQgJWQgYnl0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AAAIAAAACQAAAAkAAAAKAAAACgAAAAsAAAALAAAADAAAAAwAAAANAAAADQBBgNsAC/8IDAAIAIwACABMAAgAzAAIACwACACsAAgAbAAIAOwACAAcAAgAnAAIAFwACADcAAgAPAAIALwACAB8AAgA/AAIAAIACACCAAgAQgAIAMIACAAiAAgAogAIAGIACADiAAgAEgAIAJIACABSAAgA0gAIADIACACyAAgAcgAIAPIACAAKAAgAigAIAEoACADKAAgAKgAIAKoACABqAAgA6gAIABoACACaAAgAWgAIANoACAA6AAgAugAIAHoACAD6AAgABgAIAIYACABGAAgAxgAIACYACACmAAgAZgAIAOYACAAWAAgAlgAIAFYACADWAAgANgAIALYACAB2AAgA9gAIAA4ACACOAAgATgAIAM4ACAAuAAgArgAIAG4ACADuAAgAHgAIAJ4ACABeAAgA3gAIAD4ACAC+AAgAfgAIAP4ACAABAAgAgQAIAEEACADBAAgAIQAIAKEACABhAAgA4QAIABEACACRAAgAUQAIANEACAAxAAgAsQAIAHEACADxAAgACQAIAIkACABJAAgAyQAIACkACACpAAgAaQAIAOkACAAZAAgAmQAIAFkACADZAAgAOQAIALkACAB5AAgA+QAIAAUACACFAAgARQAIAMUACAAlAAgApQAIAGUACADlAAgAFQAIAJUACABVAAgA1QAIADUACAC1AAgAdQAIAPUACAANAAgAjQAIAE0ACADNAAgALQAIAK0ACABtAAgA7QAIAB0ACACdAAgAXQAIAN0ACAA9AAgAvQAIAH0ACAD9AAgAEwAJABMBCQCTAAkAkwEJAFMACQBTAQkA0wAJANMBCQAzAAkAMwEJALMACQCzAQkAcwAJAHMBCQDzAAkA8wEJAAsACQALAQkAiwAJAIsBCQBLAAkASwEJAMsACQDLAQkAKwAJACsBCQCrAAkAqwEJAGsACQBrAQkA6wAJAOsBCQAbAAkAGwEJAJsACQCbAQkAWwAJAFsBCQDbAAkA2wEJADsACQA7AQkAuwAJALsBCQB7AAkAewEJAPsACQD7AQkABwAJAAcBCQCHAAkAhwEJAEcACQBHAQkAxwAJAMcBCQAnAAkAJwEJAKcACQCnAQkAZwAJAGcBCQDnAAkA5wEJABcACQAXAQkAlwAJAJcBCQBX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AAAJ/ABgBwAAAAhRAAAIEQAVCIMAEgcfAAAIcQAACDEAAAnCABAHCgAACGEAAAghAAAJogAACAEAAAiBAAAIQQAACeIAEAcGAAAIWQAACBkAAAmSABMHOwAACHkAAAg5AAAJ0gARBxEAAAhpAAAIKQAACbIAAAgJAAAIiQAACEkAAAnyABAHBAAACFUAAAgVABAIAgETBysAAAh1AAAINQAACcoAEQcNAAAIZQAACCUAAAmqAAAIBQAACIUAAAhFAAAJ6gAQBwgAAAhdAAAIHQAACZoAFAdTAAAIfQAACD0AAAnaABIHFwAACG0AAAgtAAAJugAACA0AAAiNAAAITQAACfoAEAcDAAAIUwAACBMAFQjDABMHIwAACHMAAAgzAAAJxgARBwsAAAhjAAAIIwAACaYAAAgDAAAIgwAACEMAAAnmABAHBwAACFsAAAgbAAAJlgAUB0MAAAh7AAAIOwAACdYAEgcTAAAIawAACCsAAAm2AAAICwAACIsAAAhLAAAJ9gAQBwUAAAhXAAAIFwBACAAAEwczAAAIdwAACDcAAAnOABEHDwAACGcAAAgnAAAJrgAACAcAAAiHAAAIRwAACe4AEAcJAAAIXwAACB8AAAmeABQHYwAACH8AAAg/AAAJ3gASBxsAAAhvAAAILwAACb4AAAgPAAAIjwAACE8AAAn+AGAHAAAACFAAAAgQABQIcwASBx8AAAhwAAAIMAAACcEAEAcKAAAIYAAACCAAAAmhAAAIAAAACIAAAAhAAAAJ4QAQBwYAAAhYAAAIGAAACZEAEwc7AAAIeAAACDgAAAnRABEHEQAACGgAAAgoAAAJsQAACAgAAAiIAAAISAAACfEAEAcEAAAIVAAACBQAFQjjABMHKwAACHQAAAg0AAAJyQARBw0AAAhkAAAIJAAACakAAAgEAAAIhAAACEQAAAnpABAHCAAACFwAAAgcAAAJmQAUB1MAAAh8AAAIPAAACdkAEgcXAAAIbAAACCwAAAm5AAAIDAAACIwAAAhMAAAJ+QAQBwMAAAhSAAAIEgAVCKMAEwcjAAAIcgAACDIAAAnFABEHCwAACGIAAAgiAAAJpQAACAIAAAiCAAAIQgAACeUAEAcHAAAIWgAACBoAAAmVABQHQwAACHoAAAg6AAAJ1QASBxMAAAhqAAAIKgAACbUAAAgKAAAIigAACEoAAAn1ABAHBQAACFYAAAgWAEAIAAATBzMAAAh2AAAINgAACc0AEQcPAAAIZgAACCYAAAmtAAAIBgAACIYAAAhGAAAJ7QAQBwkAAAheAAAIHgAACZ0AFAdjAAAIfgAACD4AAAndABIHGwAACG4AAAguAAAJvQAACA4AAAiOAAAITgAACf0AYAcAAAAIUQAACBEAFQiDABIHHwAACHEAAAgxAAAJwwAQBwoAAAhhAAAIIQAACaMAAAgBAAAIgQAACEEAAAnjABAHBgAACFkAAAgZAAAJkwATBzsAAAh5AAAIOQAACdMAEQcRAAAIaQAACCkAAAmzAAAICQAACIkAAAhJAAAJ8wAQBwQAAAhVAAAIFQAQCAIBEwcrAAAIdQAACDUAAAnLABEHDQAACGUAAAglAAAJqwAACAUAAAiFAAAIRQAACesAEAcIAAAIXQAACB0AAAmbABQHUwAACH0AAAg9AAAJ2wASBxcAAAhtAAAILQAACbsAAAgNAAAIjQAACE0AAAn7ABAHAwAACFMAAAgTABUIwwATByMAAAhzAAAIMwAACccAEQcLAAAIYwAACCMAAAmnAAAIAwAACIMAAAhDAAAJ5wAQBwcAAAhbAAAIGwAACZcAFAdDAAAIewAACDsAAAnXABIHEwAACGsAAAgrAAAJtwAACAsAAAiLAAAISwAACfcAEAcFAAAIVwAACBcAQAgAABMHMwAACHcAAAg3AAAJzwARBw8AAAhnAAAIJwAACa8AAAgHAAAIhwAACEcAAAnvABAHCQAACF8AAAgfAAAJnwAUB2MAAAh/AAAIPwAACd8AEgcbAAAIbwAACC8AAAm/AAAIDwAACI8AAAhPAAAJ/wAQBQEAFwUBARMFEQAbBQEQEQUFABkFAQQVBUEAHQUBQBAFAwAYBQECFAUhABwFASASBQkAGgUBCBYFgQBABQAAEAUCABcFgQETBRkAGwUBGBEFBwAZBQEGFQVhAB0FAWAQBQQAGAUBAxQFMQAcBQEwEgUNABoFAQwWBcEAQAUAADEuMi44AHN0cmVhbSBlcnJvcgBpbnN1ZmZpY2llbnQgbWVtb3J5AGJ1ZmZlciBlcnJvcgBB5IQBC6EVazgHAA2yBwCc8gcAcGQIAGCuCgCwcQsAMKoMABMAAAAMAAAADQAAAAEAAAAGAAAAAQAAAAEAAAATAAAADQAAAA4AAAABAAAABwAAAAAAAAABAAAAFAAAAA8AAAAQAAAAAQAAAAYAAAAAAAAAAQAAABUAAAAQAAAAEQAAAAEAAAAFAAAAAAAAAAIAAAAVAAAAEgAAABIAAAABAAAABQAAAAAAAAACAAAAFQAAABIAAAATAAAAAgAAAAUAAAACAAAAAwAAABUAAAATAAAAEwAAAAMAAAAFAAAABAAAAAMAAAAVAAAAEwAAABMAAAADAAAABQAAAAgAAAAEAAAAFQAAABMAAAATAAAAAwAAAAUAAAAQAAAABQAAABUAAAATAAAAFAAAAAQAAAAFAAAAEAAAAAUAAAAWAAAAFAAAABUAAAAEAAAABQAAABAAAAAFAAAAFgAAABUAAAAWAAAABAAAAAUAAAAQAAAABQAAABYAAAAVAAAAFgAAAAUAAAAFAAAAEAAAAAUAAAAWAAAAFQAAABYAAAAFAAAABQAAACAAAAAGAAAAFgAAABYAAAAXAAAABQAAAAUAAAAgAAAABgAAABYAAAAXAAAAFwAAAAYAAAAFAAAAIAAAAAYAAAAWAAAAFgAAABYAAAAFAAAABQAAADAAAAAHAAAAFwAAABcAAAAWAAAABQAAAAQAAABAAAAABwAAABcAAAAXAAAAFgAAAAYAAAADAAAAQAAAAAgAAAAXAAAAGAAAABYAAAAHAAAAAwAAAAABAAAJAAAAGQAAABkAAAAXAAAABwAAAAMAAAAAAQAACQAAABoAAAAaAAAAGAAAAAcAAAADAAAAAAIAAAkAAAAbAAAAGwAAABkAAAAJAAAAAwAAAOcDAAAJAAAAEgAAAAwAAAANAAAAAQAAAAUAAAABAAAAAQAAABIAAAANAAAADgAAAAEAAAAGAAAAAAAAAAEAAAASAAAADgAAAA4AAAABAAAABQAAAAAAAAACAAAAEgAAABAAAAAQAAAAAQAAAAQAAAAAAAAAAgAAABIAAAAQAAAAEQAAAAIAAAAFAAAAAgAAAAMAAAASAAAAEgAAABIAAAADAAAABQAAAAIAAAADAAAAEgAAABIAAAATAAAAAwAAAAUAAAAEAAAABAAAABIAAAASAAAAEwAAAAQAAAAEAAAABAAAAAQAAAASAAAAEgAAABMAAAAEAAAABAAAAAgAAAAFAAAAEgAAABIAAAATAAAABQAAAAQAAAAIAAAABQAAABIAAAASAAAAEwAAAAYAAAAEAAAACAAAAAUAAAASAAAAEgAAABMAAAAFAAAABAAAAAwAAAAGAAAAEgAAABMAAAATAAAABwAAAAQAAAAMAAAABgAAABIAAAASAAAAEwAAAAQAAAAEAAAAEAAAAAcAAAASAAAAEgAAABMAAAAEAAAAAwAAACAAAAAHAAAAEgAAABIAAAATAAAABgAAAAMAAACAAAAABwAAABIAAAATAAAAEwAAAAYAAAADAAAAgAAAAAgAAAASAAAAEwAAABMAAAAIAAAAAwAAAAABAAAIAAAAEgAAABMAAAATAAAABgAAAAMAAACAAAAACQAAABIAAAATAAAAEwAAAAgAAAADAAAAAAEAAAkAAAASAAAAEwAAABMAAAAKAAAAAwAAAAACAAAJAAAAEgAAABMAAAATAAAADAAAAAMAAAAAAgAACQAAABIAAAATAAAAEwAAAA0AAAADAAAA5wMAAAkAAAARAAAADAAAAAwAAAABAAAABQAAAAEAAAABAAAAEQAAAAwAAAANAAAAAQAAAAYAAAAAAAAAAQAAABEAAAANAAAADwAAAAEAAAAFAAAAAAAAAAEAAAARAAAADwAAABAAAAACAAAABQAAAAAAAAACAAAAEQAAABEAAAARAAAAAgAAAAQAAAAAAAAAAgAAABEAAAAQAAAAEQAAAAMAAAAEAAAAAgAAAAMAAAARAAAAEQAAABEAAAADAAAABAAAAAQAAAAEAAAAEQAAABEAAAARAAAAAwAAAAQAAAAIAAAABQAAABEAAAARAAAAEQAAAAQAAAAEAAAACAAAAAUAAAARAAAAEQAAABEAAAAFAAAABAAAAAgAAAAFAAAAEQAAABEAAAARAAAABgAAAAQAAAAIAAAABQAAABEAAAARAAAAEQAAAAUAAAAEAAAACAAAAAYAAAARAAAAEgAAABEAAAAHAAAABAAAAAwAAAAGAAAAEQAAABIAAAARAAAAAwAAAAQAAAAMAAAABwAAABEAAAASAAAAEQAAAAQAAAADAAAAIAAAAAcAAAARAAAAEgAAABEAAAAGAAAAAwAAAAABAAAHAAAAEQAAABIAAAARAAAABgAAAAMAAACAAAAACAAAABEAAAASAAAAEQAAAAgAAAADAAAAAAEAAAgAAAARAAAAEgAAABEAAAAKAAAAAwAAAAACAAAIAAAAEQAAABIAAAARAAAABQAAAAMAAAAAAQAACQAAABEAAAASAAAAEQAAAAcAAAADAAAAAAIAAAkAAAARAAAAEgAAABEAAAAJAAAAAwAAAAACAAAJAAAAEQAAABIAAAARAAAACwAAAAMAAADnAwAACQAAAA4AAAAMAAAADQAAAAEAAAAFAAAAAQAAAAEAAAAOAAAADgAAAA8AAAABAAAABQAAAAAAAAABAAAADgAAAA4AAAAPAAAAAQAAAAQAAAAAAAAAAQAAAA4AAAAOAAAADwAAAAIAAAAEAAAAAAAAAAIAAAAOAAAADgAAAA4AAAAEAAAABAAAAAIAAAADAAAADgAAAA4AAAAOAAAAAwAAAAQAAAAEAAAABAAAAA4AAAAOAAAADgAAAAQAAAAEAAAACAAAAAUAAAAOAAAADgAAAA4AAAAGAAAABAAAAAgAAAAFAAAADgAAAA4AAAAOAAAACAAAAAQAAAAIAAAABQAAAA4AAAAPAAAADgAAAAUAAAAEAAAACAAAAAYAAAAOAAAADwAAAA4AAAAJAAAABAAAAAgAAAAGAAAADgAAAA8AAAAOAAAAAwAAAAQAAAAMAAAABwAAAA4AAAAPAAAADgAAAAQAAAADAAAAGAAAAAcAAAAOAAAADwAAAA4AAAAFAAAAAwAAACAAAAAIAAAADgAAAA8AAAAPAAAABgAAAAMAAABAAAAACAAAAA4AAAAPAAAADwAAAAcAAAADAAAAAAEAAAgAAAAOAAAADwAAAA8AAAAFAAAAAwAAADAAAAAJAAAADgAAAA8AAAAPAAAABgAAAAMAAACAAAAACQAAAA4AAAAPAAAADwAAAAcAAAADAAAAAAEAAAkAAAAOAAAADwAAAA8AAAAIAAAAAwAAAAABAAAJAAAADgAAAA8AAAAPAAAACAAAAAMAAAAAAgAACQAAAA4AAAAPAAAADwAAAAkAAAADAAAAAAIAAAkAAAAOAAAADwAAAA8AAAAKAAAAAwAAAOcDAAAJAAAAIAAAACAAAAAhAAAAIgAAACMAAAAkAAAAJQAAACYAAAAnAAAAKAAAACkAAAApAAAAKgAAACsAAAAsAAAALQAAAC4AAAAvAAAAMAAAADAAAAAxAAAAMQAAADIAAAAzAAAANAAAADUAAAA2AAAANwAAADgAAAA4AEGQmgEL+gEEAAMAAgACAAIAAgACAAIAAgACAAIAAgACAAEAAQABAAIAAgACAAIAAgACAAIAAgACAAMAAgABAAEAAQABAAEA//////////8AAAAAAAAAAAEAAQABAAEAAQABAAIAAgACAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAP////////////8AAAAAAAABAAQAAwACAAIAAgACAAIAAgABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAP//////////////////AEGVnAEL+AcIAAAABwAAagYAAAAGAACtBQAAagUAADEFAAAABQAA1AQAAK0EAACKBAAAagQAAEwEAAAxBAAAFwQAAAAEAADpAwAA1AMAAMADAACtAwAAmwMAAIoDAAB5AwAAagMAAFsDAABMAwAAPgMAADEDAAAkAwAAFwMAAAsDAAAAAwAA9AIAAOkCAADeAgAA1AIAAMoCAADAAgAAtgIAAK0CAACkAgAAmwIAAJICAACKAgAAggIAAHkCAAByAgAAagIAAGICAABbAgAAUwIAAEwCAABFAgAAPgIAADcCAAAxAgAAKgIAACQCAAAeAgAAFwIAABECAAALAgAABQIAAAACAAD6AQAA9AEAAO8BAADpAQAA5AEAAN4BAADZAQAA1AEAAM8BAADKAQAAxQEAAMABAAC7AQAAtgEAALIBAACtAQAAqAEAAKQBAACfAQAAmwEAAJcBAACSAQAAjgEAAIoBAACGAQAAggEAAH4BAAB5AQAAdQEAAHIBAABuAQAAagEAAGYBAABiAQAAXgEAAFsBAABXAQAAUwEAAFABAABMAQAASQEAAEUBAABCAQAAPgEAADsBAAA3AQAANAEAADEBAAAuAQAAKgEAACcBAAAkAQAAIQEAAB4BAAAaAQAAFwEAABQBAAARAQAADgEAAAsBAAAIAQAABQEAAAIBAAAAAQAA/QAAAPoAAAD3AAAA9AAAAPEAAADvAAAA7AAAAOkAAADmAAAA5AAAAOEAAADeAAAA3AAAANkAAADXAAAA1AAAANEAAADPAAAAzAAAAMoAAADHAAAAxQAAAMIAAADAAAAAvgAAALsAAAC5AAAAtgAAALQAAACyAAAArwAAAK0AAACrAAAAqAAAAKYAAACkAAAAogAAAJ8AAACdAAAAmwAAAJkAAACXAAAAlQAAAJIA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AAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBsLIBC9YEAQAAAAEAAAABAAAAAQAAAAIAAAACAAAAAwAAAAMAAAAEAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBlLcBC4MEAQAAAAEAAAAFAAAADQAAAB0AAAA9AAAAfQAAAP0AAAD9AQAA/QMAAP0HAAD9DwAA/R8AAP0/AAD9fwAA/f8AAP3/AQD9/wMA/f8HAP3/DwD9/x8A/f8/AP3/fwD9//8A/f//Af3//wP9//8H/f//D/3//x/9//8//f//fwAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAAT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IGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AAAAGHQAAFBlAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUAABh0AAB4ZQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAAAYdAAAoGUAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAAGHQAAMhlAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUAABh0AADwZQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAAAYdAAAGGYAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAAGHQAAEBmAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l0RUUAABh0AABoZgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAAAYdAAAkGYAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAAGHQAALhmAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUAAEB0AADwZgAAAAAAAAEAAACIBwAAAAAAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAQHQAAExnAAAAAAAAAQAAAIgHAAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAABAdAAAqGcAAAAAAAABAAAAiAcAAAAAAABOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQAAQHQAAABoAAAAAAAAAQAAAIgHAAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAABEACgAREREAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAEQAPChEREQMKBwABAAkLCwAACQYLAAALAAYRAAAAERERAEGR0QELIQsAAAAAAAAAABEACgoREREACgAAAgAJCwAAAAkACwAACwBBy9EBCwEMAEHX0QELFQwAAAAADAAAAAAJDAAAAAAADAAADABBhdIBCwEOAEGR0gELFQ0AAAAEDQAAAAAJDgAAAAAADgAADgBBv9IBCwEQAEHL0gELHg8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgBBgtMBCw4SAAAAEhISAAAAAAAACQBBs9MBCwELAEG/0wELFQoAAAAACgAAAAAJCwAAAAAACwAACwBB7dMBCwEMAEH50wELJwwAAAAADAAAAAAJDAAAAAAADAAADAAALSsgICAwWDB4AChudWxsKQBBsNQBC2cwMTIzNDU2Nzg5QUJDREVGGRJEOwI/LEcUPTMwChsGRktFNw9JDo4XA0AdPGkrNh9KLRwBICUpIQgMFRYiLhA4Pgs0MRhkdHV2L0EJfzkRI0MyQomKiwUEJignDSoeNYwHGkiTE5SVAEGg1QEL9hNJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBObyBlcnJvciBpbmZvcm1hdGlvbgAAYmFzaWNfc3RyaW5nAHN0ZDo6ZXhjZXB0aW9uAAAAAADccQAAPAAAAD0AAAA+AAAAGHQAAORxAABTdDlleGNlcHRpb24AAAAAAAAAAAhyAAAQAAAAPwAAAEAAAACMcgAAFHIAANxxAABTdDExbG9naWNfZXJyb3IAAAAAADhyAAAQAAAAQQAAAEAAAACMcgAARHIAAAhyAABTdDEybGVuZ3RoX2Vycm9yAFN0OXR5cGVfaW5mbwAAABh0AABVcgAAjHIAAAFzAABkcgAAjHIAAKxyAABscgAAAAAAANByAABCAAAAQwAAAEQAAABFAAAARgAAAEcAAABIAAAASQAAAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQAAAIxyAADccgAAeHIAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAAAAAABAcwAAQgAAAEoAAABEAAAARQAAAEsAAACMcgAATHMAAGxyAABOMTBfX2N4eGFiaXYxMjNfX2Z1bmRhbWVudGFsX3R5cGVfaW5mb0UAdgAAACxzAAB0cwAAYgAAACxzAACAcwAAYwAAACxzAACMcwAAaAAAACxzAACYcwAAYQAAACxzAACkcwAAcwAAACxzAACwcwAAdAAAACxzAAC8cwAAaQAAACxzAADIcwAAagAAACxzAADUcwAAbAAAACxzAADgcwAAbQAAACxzAADscwAAZgAAACxzAAD4cwAAZAAAACxzAAAEdAAAAAAAAHhyAABCAAAATAAAAEQAAABFAAAARgAAAE0AAABOAAAATwAAAAAAAABgdAAAQgAAAFAAAABEAAAARQAAAEYAAABRAAAAUgAAAFMAAACMcgAAbHQAAHhyAABOMTBfX2N4eGFiaXYxMjFfX3ZtaV9jbGFzc190eXBlX2luZm9FAAAAcHUAQZjpAQtBgC0AAAAyAAABAQAAHgEAAA8AAACALAAAAC0AAAAAAAAeAAAADwAAAAAAAAAwLAAAAAAAABMAAAAHAAAAAAAAAAUAQeTpAQsBOQBB/OkBCwo6AAAAOwAAAC12AEGU6gELAQIAQaPqAQsF//////8AQejqAQsJoH5QAAAAAAAFAEH86gELAVQAQZTrAQsOOgAAAFUAAACYegAAAAQAQazrAQsBAQBBu+sBCwUK/////w=="),Ie,gc;(function(i){i[i.NOSHUFFLE=0]="NOSHUFFLE",i[i.SHUFFLE=1]="SHUFFLE",i[i.BITSHUFFLE=2]="BITSHUFFLE",i[i.AUTOSHUFFLE=-1]="AUTOSHUFFLE"})(gc||(gc={}));const Ic=new Set(["blosclz","lz4","lz4hc","snappy","zlib","zstd"]);let Ir;const lv=()=>ov({noInitialRun:!0,wasmBinary:Iv}),Cv=(Ie=class{constructor(i=5,A="lz4",t=1,e=0){if(i<0||i>9)throw new Error(`Invalid compression level: '${i}'. It should be between 0 and 9`);if(!Ic.has(A))throw new Error(`Invalid compressor '${A}'. Valid compressors include
        'blosclz', 'lz4', 'lz4hc','snappy', 'zlib', 'zstd'.`);if(t<-1||t>2)throw new Error(`Invalid shuffle ${t}. Must be one of 0 (NOSHUFFLE),
        1 (SHUFFLE), 2 (BITSHUFFLE), -1 (AUTOSHUFFLE).`);this.blocksize=e,this.clevel=i,this.cname=A,this.shuffle=t}static fromConfig({blocksize:i,clevel:A,cname:t,shuffle:e}){return new Ie(A,t,e,i)}async prepare(){Ir||(Ir=await lv())}encode(i){const A=Ir,t=A.compress(i,this.cname,this.clevel,this.shuffle,this.blocksize),e=new Uint8Array(t);return A.free_result(),e}decode(i,A){const t=Ir,e=t.decompress(i),n=new Uint8Array(e);return t.free_result(),A!==void 0?(A.set(n),A):n}},Ie.codecId="blosc",Ie.COMPRESSORS=[...Ic],Ie.NOSHUFFLE=0,Ie.SHUFFLE=1,Ie.BITSHUFFLE=2,Ie.AUTOSHUFFLE=-1,Ie),Fr=1,Bv=1,oe=4,Rr=8,hv=Rr,cv="string",Ta="int32",kn="int64",Ev="bool",Qv="half",si="float",Sn="double",dI="vec3i",fI="vec3s",uI="vec3d",dv="ptdataidx32",fv="ptdataidx64",uv={[Sn]:{exp:11,bias:(1<<11-1)-1,size:hv},[si]:{exp:8,bias:(1<<8-1)-1,size:oe},[Ta]:{size:oe},[kn]:{size:Rr},[dv]:{size:oe},[fv]:{size:Rr},[Qv]:{size:oe/2,exp:5,bias:(1<<5-1)-1}},nt=cA;class lc{constructor(A){UA(this,"source",null);UA(this,"offset",0);if(!(A instanceof Uint8Array))throw console.error("BufferIterator","constructor","source must be an Uint8Array buffer."),0;this.source=A}reset(){this.offset=0}readBytes(A){let t=0;return this.source.slice(this.offset,this.offset+A).forEach((e,n)=>{t=t|e<<8*n}),this.offset+=A,t}readRawBytes(A){const t=[];return this.source.slice(this.offset,this.offset+A).forEach((e,n)=>{t.push(e)}),this.offset+=A,Uint8Array.from(t)}readBool(){return Boolean(this.readBytes(Bv))}readString(A=cv){const t=this.readBytes(oe);let e="";return A===kn?e=this.readFloat(kn):A===Ev?e=Boolean(this.readBytes(t)):A===dI?e=new nt(this.readFloat(Ta),this.readFloat(Ta),this.readFloat(Ta)):A===fI?e=new nt(this.readFloat(si),this.readFloat(si),this.readFloat(si)):A===uI?e=new nt(this.readFloat(Sn),this.readFloat(Sn),this.readFloat(Sn)):Array(t).fill(0).map(n=>e+=String.fromCharCode(this.readBytes(Fr))),e}readFloat(A=Sn){const t=uv[A];if([fI,dI,uI].includes(A)){const r={[fI]:si,[dI]:Ta,[uI]:Sn}[A];return new nt(this.readFloat(r),this.readFloat(r),this.readFloat(r))}let e=[];if(Array(t.size).fill(0).forEach(()=>{e.unshift(this.readBytes(Fr))}),e=e.map(r=>`00000000${r.toString(2)}`.substr(-8)).join(""),[Ta,kn].includes(A))return~~parseInt(e,2);const n=e.slice(0,1)==="1"?-1:1,a=parseInt(e.slice(1,t.exp+1),2)-t.bias,o="1"+e.slice(t.exp+1,A.size);let s=a<0?0:o.substr(0,a+1),I="0."+Array(a<0?-a-1:0).fill("0").join("")+o.substr(a<0?0:a+1);return s=parseInt(s,2),I=parseInt(I.replace(".",""),2)/Math.pow(2,(I.split(".")[1]||"").length),s===0&&I===0?0:n*(s+I)}readVector3(A=Sn){const t=new nt;return t.x=this.readFloat(A),t.y=this.readFloat(A),t.z=this.readFloat(A),t}skip(A){this.offset+=A}}class pv{constructor(){UA(this,"blosc",null);UA(this,"zlib",null)}async prepareModules(){this.blosc=new Cv,await this.blosc.prepare(),this.zlib=new sv}}const vr=new pv;class vi{static greater(A,t){return A>t}static greaterEq(A,t){return A>=t}static less(A,t){return A<t}static lessEq(A,t){return A<=t}static eq(A,t){return A===t}static between(A,t,e,n,a){return n&&a?A>=t&&A<=e:n?A>=t&&A<e:a?A>t&&A<=e:A>t&&A<e}}class VA{constructor(){UA(this,"bufferIterator",null);UA(this,"compression",null);UA(this,"version",null);UA(this,"valueType",null);UA(this,"useHalf",null)}static tagContext(A,t){A.sharedContext=t}static passContext(A,t){t.sharedContext=A.sharedContext}static cleanContext(A){delete A.sharedContext}static getContext(A){return A.sharedContext}static assert(A){if(!A.sharedContext)throw console.error("GridSharedContext","assert","expected GridSharedContext to exist",{target:A}),0}}const mt={uniformScaleTranslateMap:"UniformScaleTranslateMap",scaleTranslateMap:"ScaleTranslateMap",uniformScaleMap:"UniformScaleMap",scaleMap:"ScaleMap",translationMap:"TranslationMap",unitaryMap:"UnitaryMap",nonlinearFrustumMap:"NonlinearFrustumMap"};class co{constructor(){this.transformMap={mapType:null,translation:new nt,scale:new nt,voxelSize:new nt,scaleInverse:new nt,scaleInverseSq:new nt,scaleInverseDouble:new nt}}readTransform(){const{bufferIterator:A,version:t}=VA.getContext(this);this.transformMap.mapType=A.readString(),!vi.less(t,219)&&([mt.uniformScaleTranslateMap,mt.scaleTranslateMap].includes(this.transformMap.mapType)?this.transformMap={...this.transformMap,translation:A.readVector3(),scale:A.readVector3(),voxelSize:A.readVector3(),scaleInverse:A.readVector3(),scaleInverseSq:A.readVector3(),scaleInverseDouble:A.readVector3()}:[mt.uniformScaleMap,mt.scaleMap].includes(this.transformMap.mapType)?this.transformMap={...this.transformMap,scale:A.readVector3(),voxelSize:A.readVector3(),scaleInverse:A.readVector3(),scaleInverseSq:A.readVector3(),scaleInverseDouble:A.readVector3()}:[mt.translationMap].includes(this.transformMap.mapType)?this.transformMap={...this.transformMap,translation:A.readVector3()}:[mt.unitaryMap].includes(this.transformMap.mapType)||[mt.nonlinearFrustumMap].includes(this.transformMap.mapType),this.applyTransformMap(new nt))}applyTransformMap(A){let t;return[mt.uniformScaleTranslateMap,mt.scaleTranslateMap].includes(this.transformMap.mapType)?t=e=>e.multiply(this.transformMap.scale):[mt.uniformScaleMap,mt.scaleMap].includes(this.transformMap.mapType)?t=e=>e.multiply(this.transformMap.scale).add(this.transformMap.translation):[mt.translationMap].includes(this.transformMap.mapType)?t=e=>e.add(this.transformMap.translation):[mt.unitaryMap].includes(this.transformMap.mapType)?t=e=>e:[mt.nonlinearFrustumMap].includes(this.transformMap.mapType)?t=e=>e:(ph("GridDescriptor::Matrix4x4",this.transformMap.mapType),t=e=>e),this.applyTransformMap=t,t(A)}applyInverseTransformMap(A){let t;return[mt.uniformScaleTranslateMap,mt.scaleTranslateMap].includes(this.transformMap.mapType)?t=e=>e.multiply(this.transformMap.scaleInverse):[mt.uniformScaleMap,mt.scaleMap].includes(this.transformMap.mapType)?t=e=>e.multiply(this.transformMap.scaleInverse):[mt.translationMap].includes(this.transformMap.mapType)?t=e=>e.sub(this.transformMap.translation).sub(this.transformMap.translation):[mt.unitaryMap].includes(this.transformMap.mapType)?t=e=>e:[mt.nonlinearFrustumMap].includes(this.transformMap.mapType)?t=e=>e:(ph("GridDescriptor::Matrix4x4",this.transformMap.mapType),t=e=>e),this.applyInverseTransformMap=t,t(A)}}class pI{constructor(){UA(this,"onIndexCache",null)}readMask(A){const{bufferIterator:t}=VA.getContext(this);this.dim=1<<A.log2dim,this.size=1<<3*A.log2dim,this.wordCount=this.size>>6,this.words=[],Array(this.wordCount).fill(0).forEach(()=>{const e=Array(8).fill("0").join("");let n=Array(8).fill(0).map(()=>`${e}${t.readBytes(1).toString(2).split("-").join("")}`.substr(-8).split("").reverse().join(""));n=n.join(""),this.words.push(`${Array(64).fill("0").join("")}${n}`.substr(-64))}),this.onCache=this.countOn(),this.offCache=this.countOff(),this.forEachOn(),this.forEachOff()}countOn(){if(this.onCache)return this.onCache;let A=0;return this.words.forEach(t=>{A+=t.split("").filter(e=>e==="1").length}),A}countOff(){return this.offCache?this.offCache:this.size-this.countOn()}forEachOn(A){if(this.countOn()===0||!A)return;let t=0,e=0;for(this.onIndexCache||(this.onIndexCache=[]),t=0;t<this.words.length;t++){const n=this.words[t].split("");for(e=0;e<n.length;e++)if(n[e]==="1"){const a=t*64+e;this.onIndexCache[a]=!0,A({wordIndex:t,bitIndex:e,offset:a})===0&&(e=n.length,t=this.words.length)}}}forEachOff(A){if(this.countOff()===0||!A)return;let t=0,e=0;for(this.onIndexCache||(this.onIndexCache=[]),t=0;t<this.words.length;t++){const n=this.words[t].split("");for(e=0;e<n.length;e++)if(n[e]==="0"){const a=t*64+e;this.onIndexCache[a]=!1,A({wordIndex:t,bitIndex:e,offset:a})===0&&(e=n.length,t=this.words.length)}}}isOn(A){return!!this.onIndexCache[A]}isOff(A){return!this.onIndexCache[A]}}const IQ=[5,4,3],lQ=[4,3,0],mv=["internal","internal","leaf"];class Ll{constructor(){UA(this,"valueCache",{});UA(this,"reads",0);UA(this,"readsMiss",0);UA(this,"readsOk",0)}readNode(A=0,t){const{version:e}=VA.getContext(this);Object.assign(this,t),this.depth=A,this.log2dim=IQ[A]||1,this.nodeType=mv[A]||"invalid",this.total=this.log2dim+(n=>{let a=0;return lQ.forEach((o,s)=>{s>=n&&(a+=o)}),a})(A),this.dim=1<<this.total,this.numValues=1<<3*this.log2dim,this.level=2-A,this.numVoxels=1<<3*this.total,this.background=t.background||0,this.offsetMask=this.dim-1,A<2&&(this.childMask=new pI,VA.passContext(this,this.childMask),this.childMask.readMask(this),VA.cleanContext(this.childMask)),this.valueMask=new pI,VA.passContext(this,this.valueMask),this.valueMask.readMask(this),VA.cleanContext(this.valueMask),this.isLeaf()?this.leavesCount=1:this.leavesCount=0,this.table=[],this.firstChild=null,this.values=[],!vi.less(e,214)&&this.readValues()}isLeaf(){return this.depth>=2}isInternalNode(){return!this.isLeaf()}getValueCoords(A){const t=new nt;let e=A>>2*this.log2dim;A&=(1<<2*this.log2dim)-1;let n=A>>this.log2dim,a=A&(1<<this.log2dim)-1;return t.set(e,n,a),t.x=t.x<<this.numVoxels,t.y=t.y<<this.numVoxels,t.z=t.z<<this.numVoxels,t}forEachValue(A=()=>{}){this.valueMask.forEachOn(t=>{A({wordIndex:t.wordIndex,bitIndex:t.bitIndex,offset:t.offset,coords:this.getValueCoords(t.offset)})})}readValues(){const{bufferIterator:A,compression:t,version:e}=VA.getContext(this),n=vi.less(e,222),a=t.activeMask;if(this.isLeaf()){this.values=Array(this.valueMask.size).fill(0),this.valueMask.forEachOn(({offset:r})=>{this.values[r]=1});return}const o=n?this.childMask.countOff():this.numValues;let s=272;vi.greaterEq(e,222)&&(s=A.readBytes(1)),this.background,[3,4,5].includes(s)&&(this.selectionMask=new pI(this),VA.passContext(this,this.selectionMask),this.selectionMask.readMask(this),VA.cleanContext(this.selectionMask));let I=o;a&&s!==6&&vi.greaterEq(e,222)&&(I=this.valueMask.countOn()),this.readData(I),this.childMask.forEachOn(r=>{let g=r.offset;const C=new nt;let B=g>>2*this.log2dim;g&=(1<<2*this.log2dim)-1;let c=g>>this.log2dim,Q=g&(1<<this.log2dim)-1;C.set(B,c,Q);const h=new Ll;VA.passContext(this,h),h.parent=this,h.readNode(this.depth+1,{id:r.offset,origin:C,indices:r,background:this.background}),C.x=C.x<<h.total,C.y=C.y<<h.total,C.z=C.z<<h.total,this.table[r.offset]=h,this.leavesCount+=h.leavesCount,this.firstChild||(this.firstChild=h),VA.cleanContext(h)})}readCompressedData(A){const{bufferIterator:t,valueType:e,useHalf:n}=VA.getContext(this),a=t.readBytes(8);if(a<=0){Array(-a).fill(0).forEach(()=>{this.values.push(t.readFloat(n?"half":e))});return}else{const o=t.readRawBytes(a);try{this.values.push(A.decode(o))}catch(s){console.warn("readZipData","uncompress","error",{error:s,zippedBytes:o})}}}readData(A){const{bufferIterator:t,valueType:e,useHalf:n,compression:a}=VA.getContext(this);a.blosc?this.readCompressedData(vr.blosc):a.zip?this.readCompressedData(vr.zlib):Array(A).fill(0).forEach(()=>{this.values.push(t.readFloat(n?"half":e))})}getLocalBbox(){if(this.localBboxCache)return this.localBboxCache;let A=new nt;const t=n=>{n&&n.origin&&A.add(n.origin),n.parent&&t(n.parent)};t(this);const e=[A,new nt(A.x+this.dim,A.y+this.dim,A.z+this.dim)];return this.localBboxCache=e,e}getFirstChild(){return this.firstChild}contains(A){const[t,e]=this.getLocalBbox();return A.x>=t.x&&A.x<=e.x&&A.y>=t.y&&A.y<=e.y&&A.z>=t.z&&A.z<=e.z}coordToOffset(A){return this.isLeaf()?(A.x&this.offsetMask)<<2*this.log2dim|(A.y&this.offsetMask)<<this.log2dim|A.z&this.offsetMask:(A.x&this.offsetMask)>>this.firstChild.total<<2*this.log2dim|(A.y&this.offsetMask)>>this.firstChild.total<<this.log2dim|(A.z&this.offsetMask)>>this.firstChild.total}getValue(A,t=null){if(!this.contains(A))return 0;if(t&&t.cache(this),this.isLeaf())return this.valueMask.isOn(this.coordToOffset(A))?1:0;const e=this.table[this.coordToOffset(A)];return e?e.getValue(A,t):0}getLeafAt(A,t=null){if(this.reads++,!this.contains(A))return this.readsMiss++,null;if(this.isLeaf())return this.readsOk++,this;t&&t.cache(this);const e=this.table[this.coordToOffset(A)];return e?(this.readsMiss++,e.getLeafAt(A,t)):(this.readsOk++,null)}}class yv{readNode(){const{bufferIterator:A,valueType:t}=VA.getContext(this);this.background=A.readFloat(t),this.numTiles=A.readBytes(oe),this.numChildren=A.readBytes(oe),this.table=[],this.origin=new nt,this.readChildren()}readChildren(){this.numTiles===0&&this.numChildren===0||(this.leavesCount=0,Array(this.numTiles).fill(0).forEach(()=>{this.readTile()}),Array(this.numChildren).fill(0).forEach(()=>{this.readInternalNode()}))}readTile(){const{bufferIterator:A,valueType:t}=VA.getContext(this),e=new nt(A.readFloat("int32"),A.readFloat("int32"),A.readFloat("int32")),n=A.readFloat(t),a=readBool();this.push({child:null,tile:{value:n,active:n?a:!1},origin:e,isChild:()=>!!child,isTile:()=>!!tile,isTileOff:()=>tile&&!tile.active,isTileOn:()=>tile&&tile.active})}readInternalNode(){const{bufferIterator:A}=VA.getContext(this),t=new nt(A.readFloat("int32"),A.readFloat("int32"),A.readFloat("int32")),e=new Ll;VA.passContext(this,e),e.readNode(0,{id:this.table.length,origin:t,background:this.background}),this.table.push(e),this.leavesCount+=e.leavesCount,VA.cleanContext(e)}getLocalBbox(){return[new nt(0,0,0),new nt(0,0,0)]}isLeaf(){return!1}isRoot(){return!0}getValue(A,t=null){let e=0;for(let n=0;n<this.table.length;n++)e=Math.max(e,this.table[n].getValue(A,t)),e!==0&&(n=this.table.length);return e}getLeafAt(A,t=null){let e=null;for(let n=0;n<this.table.length;n++)e=this.table[n].getLeafAt(A,t),e!==null&&(n=this.table.length);return e}}class Dv{constructor(A){UA(this,"stack",[]);UA(this,"grid",null);this.grid=A}getValue(A){return this.probeValues(A)}getLeafAt(A){return this.probeLeaves(A)}probeValues(A){if(this.stack.length){const t=this.stack.pop();if(t.contains(A))return t.getValue(A,this)}else return this.grid.root.getValue(A,this);return this.probeValues(A)}probeLeaves(A){if(this.stack.length){const t=this.stack.pop();if(t.contains(A))return t.getLeafAt(A,this)}else return this.grid.root.getLeafAt(A,this);return this.probeLeaves(A)}cache(A){this.stack.push(A)}}const Lr=class{constructor(){UA(this,"saveAsHalfFloat",!1);UA(this,"leavesCount",0);UA(this,"uniqueName");UA(this,"gridName");UA(this,"gridType");UA(this,"valueCache",{});UA(this,"accessor",new Dv(this))}readGrid(){const{bufferIterator:A,version:t}=VA.getContext(this);this.readGridHeader(),uh("Grid buffer position",this.gridBufferPosition,A.offset),this.gridBufferPosition!==A.offset&&(A.offset=this.gridBufferPosition),this.readCompression(),this.readMetadata(),vi.less(t,216)?(this.readTopology(),this.readGridTransform(),this.readBuffers()):(this.readGridTransform(),this.readTopology(),this.readBuffers()),A.offset=this.endBufferPosition}readGridHeader(){const{bufferIterator:A,version:t}=VA.getContext(this);this.uniqueName=A.readString(),this.gridName=this.uniqueName.split("")[0],this.gridType=A.readString(),this.gridType.indexOf(Lr.halfFloatGridPrefix)!==-1&&(this.saveAsHalfFloat=!0,this.gridType=this.gridType.split(Lr.halfFloatGridPrefix).join("")),vi.greaterEq(t,216)&&(this.instanceParentName=A.readString()),this.gridBufferPosition=A.readFloat(kn),this.blockBufferPosition=A.readFloat(kn),this.endBufferPosition=A.readFloat(kn)}readCompression(){const{bufferIterator:A,version:t}=VA.getContext(this);if(vi.greaterEq(t,222)){let e=A.readBytes(oe);e={none:e&0,zip:e&1,activeMask:e&2,blosc:e&4},VA.getContext(this).compression=e}}readMetadata(){const{bufferIterator:A,version:t}=VA.getContext(this);this.metadata={count:A.readBytes(oe)},Array(this.metadata.count).fill(0).forEach(()=>{const e=A.readString(),n=A.readString(),a=A.readString(n);this.metadata[e]={type:n,value:a}}),vi.less(t,219)&&(this.metadata.name=this.gridName)}getGridValueType(){const A=Object.entries(this.metadata).find(([t])=>t==="value_type");return(A?A[1].value:void 0)||si}getGridClass(){const A=Object.entries(this.metadata).find(([t])=>t==="class");return(A?A[1].value:void 0)||"level set"}readGridTransform(){this.transform=new co,VA.passContext(this,this.transform),this.transform.readTransform(),VA.cleanContext(this.transform)}readTopology(){const{bufferIterator:A}=VA.getContext(this);VA.getContext(this).useHalf=this.saveAsHalfFloat,VA.getContext(this).valueType=this.getGridValueType(),A.readBytes(oe)===1&&(this.root=new yv,VA.passContext(this,this.root),this.root.readNode(),this.leavesCount=this.root.leavesCount,VA.cleanContext(this.root),uh("Block buffer",this.blockBufferPosition,A.offset))}readBuffers(){}getWorldBbox(A){return(A||this).getLocalBbox().map(e=>e.clone()).map(this.transform.applyTransformMap)}getLocalBbox(){const A=1<<IQ[0]+lQ.reduce((t,e)=>t+e);return[this.metadata.file_bbox_min.value.subScalar(A-1),this.metadata.file_bbox_max.value.addScalar(A-1)]}getPreciseWorldBbox(){return[this.transform.applyTransformMap(this.metadata.file_bbox_min.value.clone()),this.transform.applyTransformMap(this.metadata.file_bbox_max.value.clone())]}getValue(A){const t=A.clone().round();return this.accessor.getValue(t)}getLeafAt(A){const t=A.clone().round();return this.accessor.getLeafAt(t)}};let Se=Lr;UA(Se,"halfFloatGridPrefix","_HalfFloat");class Sv{constructor(){UA(this,"libraryVersion");UA(this,"hasGridOffsets");UA(this,"uuid");UA(this,"metadata");VA.tagContext(this,new VA)}async prepare(){await vr.prepareModules(),VA.getContext(this).bufferIterator=new lc(source)}async read(A){if(await vr.prepareModules(),VA.getContext(this).bufferIterator=new lc(A),this.validateVDBFile())this.readFileVersion(),this.readHeader(),this.readGrids();else throw"Not a VDB file."}validateVDBFile(){const{bufferIterator:A}=VA.getContext(this);return A.readBytes(Rr)===1447313952}readFileVersion(){const{bufferIterator:A}=VA.getContext(this),t=A.readBytes(oe);VA.getContext(this).version=t,this.libraryVersion={minor:-1,major:-1},t>211?(this.libraryVersion.major=A.readBytes(oe),this.libraryVersion.minor=A.readBytes(oe)):(this.libraryVersion.major=0,this.libraryVersion.minor=0)}readHeader(){const{bufferIterator:A,version:t}=VA.getContext(this);this.hasGridOffsets=A.readBytes(Fr);let e;t>=220&&t<222?(e=A.readBytes(Fr),e={none:e&0,zip:e&1,activeMask:e&2,blosc:e&4}):e={none:!1,zip:!1,activeMask:!0,blosc:!1},VA.getContext(this).compression=e;let n="";Array(36).fill(0).map(s=>n+=String.fromCharCode(A.readBytes(1))),this.uuid=n;const a={},o=A.readBytes(oe);Array(o).fill(0).forEach(()=>{const s=A.readString(),I=A.readString(),r=A.readString(I);a[s]={type:I,value:r}}),this.metadata=a}readGrids(){const{bufferIterator:A}=VA.getContext(this);let t={};if(this.grids=t,this.hasGridOffsets){const e=A.readBytes(oe);Array(e).fill(0).forEach(()=>{const n=new Se(A);VA.passContext(this,n),n.readGrid(),VA.cleanContext(n),this.grids[n.uniqueName]=n})}}}const wv=i=>new Promise((A,t)=>{fetch(i).then(async e=>{const n=new Uint8Array(await e.arrayBuffer()),a=new Sv;try{await a.read(n),A(a)}catch(o){console.error({error:o}),t("VDB could not be parsed.")}})});class _v extends nM{constructor(A){super(A)}load(A,t,e,n){wv(A).then(a=>{t(a)}).catch(a=>{n(a)})}}const CQ=Is,xv=[16711680,65280,255];class Mv extends Ja{constructor(t,{color:e,opacity:n}={}){super();UA(this,"processes",[]);let a;t instanceof Array?a=t:typeof t.grids<"u"?a=Object.values(t.grids):a=[t];const o=new De,s=new CQ;Object.values(a).forEach((I,r)=>{const g=new AM(new ls(1,1,1),new Sl({wireframe:!0,color:e||xv[r],transparent:!0,opacity:n}),I.leavesCount);let C=0;const B=c=>{var Q;c.isLeaf()&&(s.set(...I.getWorldBbox(c)),s.getCenter(o.position),s.getSize(o.scale),o.updateMatrix(),g.setMatrixAt(C++,o.matrix)),((Q=c.childMask)==null?void 0:Q.countOn())>0&&c.childMask.forEachOn(({offset:h})=>{B(c.table[h])})};I.root.table.forEach(c=>B(c)),this.add(g)})}}class Fv extends tM{constructor(t={}){super();UA(this,"_uniforms",{baseColor:{value:new It(16777215)},scatterColor:{value:new It(0)},densityMap3D:{value:null},emissiveMap3D:{value:null},steps:{value:100},absorbance:{value:1},densityScale:{value:1},resolution:{value:100},offset3D:{value:new cA(0,0,0)},wrap3D:{value:Fe},noiseScale:{value:.5}});this.side=ce,this.depthWrite=!1,this.depthTest=!0,this.transparent=!0,this.customProgramCacheKey=()=>Math.random(),Object.keys(this._uniforms).forEach(e=>{t[e]&&(this[e]=t[e],t[e]instanceof Ee&&(t[e].offset3D=this._uniforms.offset3D.value))}),this.onBeforeCompile=e=>{Object.keys(this._uniforms).forEach(c=>{e.uniforms[c]=this._uniforms[c]}),e.isVolumetricFogMaterial=!0;const n=`
        #define VOLUME_BBOX_SPAN 0.5
        ${t.emissiveMap3D?"#define USE_EMISSIVE_GRID":""}
      `,a=`
         varying mat4 mModelMatrix;
         varying mat4 mInverseModelViewMatrix;
         varying mat3 mInverseNormalMatrix;
      `;e.vertexUvs=!0,e.vertexShader=e.vertexShader.replace("#include <common>",`
            ${a}

            out vec3 vOrigin;
            out vec3 vDirection;

            #include <common>
          `).replace("#include <worldpos_vertex>",`
            #include <worldpos_vertex>

            vOrigin = vec3(inverse(modelMatrix) * vec4(cameraPosition, 1.0)).xyz;
            vDirection = position - vOrigin;

            mModelMatrix = modelMatrix;
            mInverseModelViewMatrix = inverse(modelViewMatrix);
            mInverseNormalMatrix = inverse(normalMatrix);
          `);const o=`
        float lightMarchLimit = resolution + 2.;
        int iLightMarchLimit = int(lightMarchLimit);

        vec3 vUnit = (mModelMatrix * vec4(1., 0., 0., 0.)).xyz;
        float vUnitLength = length(vUnit);
        
        geometry.position = vPoint;

        vec3 iblIrradiance = vec3(0.0);
      `,s=`
        PointLight pointLight;
        lightAlbedo = vec3(0.);
        
        for (int lightIndex = 0; lightIndex < NUM_POINT_LIGHTS; lightIndex++) {
          pointLight = pointLights[lightIndex];
          getPointLightInfo(pointLight, geometry, directLight);

          vLightProbe = vec3(vPoint);
          lightAbsorbance = 0.;
          stepAccumulation = 1.;

          lightDirection = vPoint - (mInverseModelViewMatrix * vec4(pointLight.position, 1.)).xyz;
          lightDistance = length(lightDirection) * vUnitLength;
          lightDirection = normalize(lightDirection);
          vLightStep = (lightDirection * VOLUME_BBOX_SPAN) / lightMarchLimit;

          for (int lightMarch = 0; lightMarch < iLightMarchLimit; lightMarch++) {
            vLightProbe -= vLightStep;
            stepAccumulation += 1.;
            
            lightSample = texture(densityMap3D, mapTextureSample(vLightProbe)).r;
            
            lightAbsorbance += lightSample * eInverseAbsorbance;

            if (lightAbsorbance >= 1.) {
              lightAbsorbance = 1.;
              break;
            }
          }

          lightAlbedo += (1. - lightAbsorbance) * pointLight.color;
        }

        lightAlbedo *= density;
        albedo += lightAlbedo * baseColor.rgb * RECIPROCAL_PI;
      `,I=`
        DirectionalLight directionalLight;
        lightAlbedo = vec3(0.);

        for (int lightIndex = 0; lightIndex < NUM_DIR_LIGHTS; lightIndex++) {
          directionalLight = directionalLights[lightIndex];
          getDirectionalLightInfo(directionalLight, geometry, directLight);

          vLightProbe = vec3(vPoint);
          lightAbsorbance = 0.0;
          stepAccumulation = 1.;

          lightDirection = -normalize((vec4(directionalLight.direction, 1.) * viewMatrix).xyz);
          vLightStep = (lightDirection * VOLUME_BBOX_SPAN) / lightMarchLimit;

          for (int lightMarch = 0; lightMarch < iLightMarchLimit; lightMarch++) {
            vLightProbe -= vLightStep;
            stepAccumulation += 1.;
            
            lightSample = texture(densityMap3D, mapTextureSample(vLightProbe)).r;
            
            lightAbsorbance += lightSample * eInverseAbsorbance;

            if (lightAbsorbance >= 1.) {
              lightAbsorbance = 1.;
              break;
            }
          }

          lightAlbedo += (1. - lightAbsorbance) * directionalLight.color;
        }

        lightAlbedo *= density;
        albedo += lightAlbedo * baseColor.rgb * RECIPROCAL_PI;
      `,r=`
        SpotLight spotLight;
        lightAlbedo = vec3(0.);

        float angleCos;
        float spotAttenuation;
        
        for (int lightIndex = 0; lightIndex < NUM_SPOT_LIGHTS; lightIndex++) {
          spotLight = spotLights[lightIndex];
          getSpotLightInfo(spotLight, geometry, directLight);

          vLightProbe = vec3(vPoint);
          lightAbsorbance = 0.0;
          stepAccumulation = 1.;

          lightDirection = vPoint - (mInverseModelViewMatrix * vec4(spotLight.position, 1.)).xyz;
          lightDistance = length(lightDirection) * vUnitLength;
          lightDirection = normalize(lightDirection);
          vLightStep = (lightDirection * VOLUME_BBOX_SPAN) / lightMarchLimit;

          angleCos = dot(normalize(-lightDirection), normalize(mInverseNormalMatrix * spotLight.direction));
          spotAttenuation = smoothstep(spotLight.coneCos, spotLight.penumbraCos, angleCos);

          if (spotAttenuation > 0.) {
            for (int lightMarch = 0; lightMarch < iLightMarchLimit; lightMarch++) {
              vLightProbe -= vLightStep;
              stepAccumulation += 1.;
              
              lightSample = texture(densityMap3D, mapTextureSample(vLightProbe)).r;
              
              lightAbsorbance += lightSample * eInverseAbsorbance;

              if (lightAbsorbance >= 1.) {
                lightAbsorbance = 1.;
                break;
              }
            }

            lightAlbedo += (1. - lightAbsorbance) * spotAttenuation * spotLight.color;
          }
        }

        lightAlbedo *= density;
        albedo += lightAlbedo * baseColor.rgb * RECIPROCAL_PI;
      `,g=`
        lightAlbedo = vec3(0.);
        vec3 textureProbe;

        float absorbanceUp;
        float absorbanceDown;
        float stepAccumulationUp;
        float stepAccumulationDown;

        for (int lightIndex = 0; lightIndex < NUM_HEMI_LIGHTS; lightIndex++) {

          HemisphereLight hemiLight = hemisphereLights[lightIndex];
          vLightProbe = vec3(vPoint);

          absorbanceUp = 0.0;
          absorbanceDown = 0.0;

          stepAccumulationUp = 0.;
          stepAccumulationDown = 0.;

          lightDirection = -normalize((vec4(hemiLight.direction, 1.) * viewMatrix).xyz);
          vLightStep = (lightDirection * VOLUME_BBOX_SPAN) / lightMarchLimit;

          for (int lightMarch = 1; lightMarch < int(lightMarchLimit / 2.); lightMarch++) {
            if (absorbanceUp < 1.) {
              textureProbe = vLightProbe - float(lightMarch) * vLightStep;
              lightSample = texture(densityMap3D, mapTextureSample(textureProbe)).r;

              absorbanceUp += lightSample * eInverseAbsorbance;
              stepAccumulationUp += 1.;
            }
            
            if (absorbanceDown < 1.) {
              textureProbe = vLightProbe + float(lightMarch) * vLightStep;
              lightSample = texture(densityMap3D, mapTextureSample(textureProbe)).r;

              absorbanceDown += lightSample * eInverseAbsorbance;
              stepAccumulationDown += 1.;
            }
          }

          absorbanceUp = min(1., absorbanceUp);
          absorbanceDown = min(1., absorbanceDown);

          lightAlbedo += mix(
            (1. - absorbanceUp) * hemiLight.skyColor,
            (1. - absorbanceDown) * hemiLight.groundColor,
            0.5
          );
        }

        lightAlbedo *= density;
        albedo += lightAlbedo * baseColor.rgb * RECIPROCAL_PI;
      `,C=`
        albedo += ambientLightColor * baseColor.rgb;
      `,B=`
        bool isOutsideVolume(vec3 source) {
          return (
            source.x >= 1. ||
            source.y >= 1. ||
            source.z >= 1. ||
            source.x <= 0. ||
            source.y <= 0. ||
            source.z <= 0.
          );
        }

        vec2 getVolumeBbox(vec3 vPointOfReference) {
          const vec3 vBoxMin = vec3(-0.5);
          const vec3 vBoxMax = vec3(0.5);
          vec3 vInvPointOfReference = 1.0 / vPointOfReference;
          
          vec3 vMinRange = (-vOrigin - VOLUME_BBOX_SPAN) * vInvPointOfReference;
          vec3 vMaxRange = (-vOrigin + VOLUME_BBOX_SPAN) * vInvPointOfReference;
          
          vec3 vMin = min(vMinRange, vMaxRange);
          vec3 vMax = max(vMinRange, vMaxRange);

          return vec2(
            max(vMin.x, max(vMin.y, vMin.z)),
            min(vMax.x, min(vMax.y, vMax.z))
          );
        }

        vec3 radiation = vec3(0.);
        vec3 getBlackBodyRadiation(float temperature) {
          if (temperature == 0.) {
            return vec3(0.);
          }

          #ifndef USE_EMISSIVE_GRID
            return vec3(0.);
          #endif

          // NOTE Blackbody radiation source - https://www.shadertoy.com/view/4tdGWM
          float temperatureScaled = temperature * 1000.;

          radiation.r += 1. / (exp(19E3 * 1. / temperatureScaled) - 1.);
          radiation.g += 3.375 / (exp(19E3 * 1.5 / temperatureScaled) - 1.);
          radiation.b += 8. / (exp(19E3 * 2. / temperatureScaled) - 1.);

          return (radiation / max(radiation.r,max(radiation.g,radiation.b)));
        }

        float loopUV(float x) {
          if (abs(mod(floor(x), 2.)) == 1.) {
            return ceil(x) - x;
          } else {
            return x - floor(x);
          }
        }

        vec3 mapTextureSample(vec3 position) {
          vec3 uv = position + VOLUME_BBOX_SPAN + offset3D;

          if (wrap3D == 1000) {
            uv = mod(uv, 1.);
          } else if (wrap3D == 0 || wrap3D == 1001) {
            return uv;
          } else if (wrap3D == 1002) {
            uv.x = loopUV(uv.x);
            uv.y = loopUV(uv.y);
            uv.z = loopUV(uv.z);
          }

          return uv;
        }

        // NOTE GLSL Noise source - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
        vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

        float snoise(vec3 v){ 
          const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
          const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

          vec3 i  = floor(v + dot(v, C.yyy) );
          vec3 x0 =   v - i + dot(i, C.xxx) ;

          vec3 g = step(x0.yzx, x0.xyz);
          vec3 l = 1.0 - g;
          vec3 i1 = min( g.xyz, l.zxy );
          vec3 i2 = max( g.xyz, l.zxy );

          vec3 x1 = x0 - i1 + 1.0 * C.xxx;
          vec3 x2 = x0 - i2 + 2.0 * C.xxx;
          vec3 x3 = x0 - 1. + 3.0 * C.xxx;

          i = mod(i, 289.0 ); 
          vec4 p = permute( permute( permute( 
                    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                  + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                  + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

          float n_ = 1.0/7.0; // N=7
          vec3  ns = n_ * D.wyz - D.xzx;

          vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

          vec4 x_ = floor(j * ns.z);
          vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

          vec4 x = x_ *ns.x + ns.yyyy;
          vec4 y = y_ *ns.x + ns.yyyy;
          vec4 h = 1.0 - abs(x) - abs(y);

          vec4 b0 = vec4( x.xy, y.xy );
          vec4 b1 = vec4( x.zw, y.zw );

          vec4 s0 = floor(b0)*2.0 + 1.0;
          vec4 s1 = floor(b1)*2.0 + 1.0;
          vec4 sh = -step(h, vec4(0.0));

          vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
          vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

          vec3 p0 = vec3(a0.xy,h.x);
          vec3 p1 = vec3(a0.zw,h.y);
          vec3 p2 = vec3(a1.xy,h.z);
          vec3 p3 = vec3(a1.zw,h.w);

          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
          p0 *= norm.x;
          p1 *= norm.y;
          p2 *= norm.z;
          p3 *= norm.w;

          vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
          m = m * m;
          return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                        dot(p2,x2), dot(p3,x3) ) );
        }

        float fbm(vec3 x) {
          vec3 y = vec3(x);
          float v = 0.0;
          float a = 0.75;
          vec3 shift = vec3(1000.);
          for (int i = 0; i < 3; ++i) {
            y = y * 10000.0 + shift;
            v += a * snoise(y);
            a *= 0.5;
          }
          return v;
        }
      `;e.fragmentShader=e.fragmentShader.replace("#include <uv_pars_fragment>","// NOTE Override UV calculations").replace("#include <uv2_pars_fragment>","// NOTE Override UV calculations").replace("#include <common>",`
            precision highp float;
            precision highp sampler3D;

            in vec3 vOrigin;
            in vec3 vDirection;

            uniform sampler3D densityMap3D;
            uniform sampler3D emissiveMap3D;
            uniform vec3 offset3D;
            uniform int wrap3D;

            uniform float steps;
            uniform float absorbance;
            uniform float densityScale;
            uniform vec3 baseColor;
            uniform vec3 scatterColor;
            uniform float resolution;
            uniform float noiseScale;

            ${n}
            ${a}
            ${B}

            #include <common>
            #include <uv_pars_fragment>
            #include <uv2_pars_fragment>
          `).replace("#include <lights_fragment_begin>","// NOTE Override light calculations").replace("#include <lights_fragment_maps>","// NOTE Override light calculations").replace("#include <lights_fragment_end>","// NOTE Override light calculations").replace("#include <output_fragment>",`
            vec3 vWorld = -vViewPosition;

            vec3 vRayDirection = normalize(vDirection);
            vec2 vBounds = getVolumeBbox(vRayDirection);
            
            if (vBounds.x > vBounds.y) {
              discard;
            }

            vBounds.x = max(vBounds.x, 0.0);

            // Volume movement

            vec3 vPoint = vOrigin + vBounds.x * vRayDirection;
            vec3 vPointStep = 1.0 / abs(vRayDirection);
            float delta = min(vPointStep.x, min(vPointStep.y, vPointStep.z)) / steps;
            vec3 vDirectionDeltaStep = vRayDirection * delta;

            // Density calculations

            float density = 0.0;
            float smoothness = 0.0;
            vec3 albedo = vec3(0.);
            vec3 emissive = vec3(0.);
            GeometricContext geometry;
            float volumeSample;
            float emissiveSample;
            float noiseSample;

            // Light calculations
            
            vec3 lightAlbedo = vec3(0.);
            vec3 vLightProbe;
            vec3 lightDirection;
            vec3 vLightStep;
            float lightSample;
            float lightAbsorbance;
            float lightDistance;
            float stepAccumulation;
            
            IncidentLight directLight;

            // Utils

            float absorbanceDensityRatio = min(absorbance, densityScale); // NOTE When reducing densityScale, automatically reduce absorbance
            float inverseAbsorbance = 1.0 / absorbanceDensityRatio;
            float inverseDensityScale = 1.0 / densityScale;
            float eInverseAbsorbance = exp(-1. - inverseAbsorbance); // NOTE Wrong, but looks kinda better than exp(-inverseAbsorbance)
            float eDensityAbsorbance = exp(-absorbanceDensityRatio * delta);
            float eInverseDensityScale = exp(-1. - inverseDensityScale);

            ${o}

            vec3 lastNonSolidPoint = vec3(vPoint);

            for (float i = vBounds.x; i < vBounds.y; i += delta) {
              volumeSample = texture(densityMap3D, mapTextureSample(vPoint)).r;
              
              density += volumeSample * eDensityAbsorbance;
              smoothness += volumeSample * eInverseDensityScale;

              #ifdef USE_EMISSIVE_GRID
                emissiveSample = texture(emissiveMap3D, mapTextureSample(vPoint)).r;
                emissive = max(emissive, density * vec3(emissiveSample));
              #endif

              if (density < 1.) {
                lastNonSolidPoint = vPoint;
              }

              if (density >= 1. && smoothness >= 1.) {
                break;
              }

              vPoint += vDirectionDeltaStep;
            }

            density = clamp(density, 0.0, 1.0);
            smoothness = clamp(smoothness, 0.0, 1.0);

            vPoint = lastNonSolidPoint;

            if (density > 0.) {

              ${C}

              #if NUM_HEMI_LIGHTS > 0
                ${g}
              #endif

              #if NUM_POINT_LIGHTS > 0
                ${s}
              #endif

              #if NUM_DIR_LIGHTS > 0
                ${I}
              #endif

              #if NUM_SPOT_LIGHTS > 0
                ${r}
              #endif

            }

            emissive = getBlackBodyRadiation(emissive.r);
            albedo += emissive;

            float smoothnessBlend = smoothstep(0.0, 1.0, smoothness);
            float opacityNoise = noiseScale > 0. ? smoothness + (abs(fbm(mapTextureSample(vPoint))) * noiseScale + (1. - noiseScale)) : smoothness + 1.;

            outgoingLight.rgb = max(scatterColor, albedo);
            diffuseColor.a = smoothnessBlend * saturate(density * opacity) * opacityNoise;

            if (density <= 0.) {
              discard;
            }

            #include <output_fragment>
          `)}}set baseColor(t){this._uniforms.baseColor.value.set(t)}get baseColor(){return this._uniforms.baseColor.value}set scatterColor(t){this._uniforms.scatterColor.value.set(t)}get scatterColor(){return this._uniforms.scatterColor.value}set densityMap3D(t){this._uniforms.densityMap3D.value=t,t.offset3D=this._uniforms.offset3D.value}get densityMap3D(){return this._uniforms.densityMap3D.value}set emissiveMap3D(t){this._uniforms.emissiveMap3D.value=t,t.offset3D=this._uniforms.offset3D.value}get emissiveMap3D(){return this._uniforms.emissiveMap3D.value}set steps(t){this._uniforms.steps.value=t}get steps(){return this._uniforms.steps.value}set absorbance(t){this._uniforms.absorbance.value=t}get absorbance(){return this._uniforms.absorbance.value}set resolution(t){this._uniforms.resolution.value=t}get resolution(){return this._uniforms.resolution.value}set offset3D(t){this._uniforms.offset3D.value.copy(t)}get offset3D(){return this._uniforms.offset3D.value}set wrap3D(t){this._uniforms.wrap3D.value=t}get wrap3D(){return this._uniforms.wrap3D.value}set densityScale(t){this._uniforms.densityScale.value=t}get densityScale(){return this._uniforms.densityScale.value}set noiseScale(t){this._uniforms.noiseScale.value=t}get noiseScale(){return this._uniforms.noiseScale.value}}class bl extends Ja{constructor(t,e,n,a){super();UA(this,"processes",[]);UA(this,"materials",[]);const{resolution:o,progressive:s,noise:I,emissiveGrid:r}=e;this.frustumCulled=!1;let g;t instanceof Array?g=t:typeof t.grids<"u"?g=Object.values(t.grids):g=[t];let C,B;if(r){g=g.filter(f=>f!==r);const E=new Uint8Array(Math.pow(o,3));C=new OI(E,o,o,o),C.format=PI,C.minFilter=te,C.magFilter=te,C.unpackAlignment=1,C.needsUpdate=!0,B=(f,u,d)=>E[f]=typeof d<"u"?d:r.getValue(u)*255}let c=0,Q=0;const h=g.length,l=h*Math.pow(o,3);g.reverse().forEach(async(E,f)=>{if(!(E instanceof Se))return;const u=new Uint8Array(Math.pow(o,3)),d=new OI(u,o,o,o);d.format=PI,d.minFilter=te,d.magFilter=te,d.unpackAlignment=1,d.needsUpdate=!0;const m=new xl(1),S=new Fv({...e,emissiveMap3D:C,densityMap3D:d}),D=new Oe(m,S);D.frustumCulled=!1,this.materials.push(S);let p=[];if(s){for(p=[o];p[p.length-1]>10;)p.push(o/(p.length+1));p=p.filter(U=>~~U===U),p.reverse()}else p=[o];const w=o,M=Math.pow(w,2),R=U=>new Promise(N=>{const G=U/p[p.length-1],T=1/G,V=Math.pow(T,2),tA=Math.pow(T,3),z=1/U,W=Math.pow(U,2),Y=Math.pow(U,3),CA=new nt(0,0,0),K=new nt(0,0,0),AA=new nt(0,0,0),lA=new CQ;lA.set(...E.getPreciseWorldBbox()),lA.getCenter(D.position),lA.getSize(D.scale),lA.getCenter(CA),lA.getSize(K),AA.copy(K).multiplyScalar(z),E.transform.applyInverseTransformMap(AA),CA.sub(K.clone().multiplyScalar(.5)),E.transform.applyInverseTransformMap(CA),CA.add(AA.clone().multiplyScalar(.5));let Z=0,oA=0,wA=0;function*uA(){for(let RA=0;RA<Y;RA++){const MA=Oy.clamp(255*(I||0),0,255);if(T!==1){const SA=E.getValue(CA)*255,TA=Math.round(Z*T)+Math.round(oA*V)*U+Math.round(wA*tA)*W,OA=B&&B(TA,CA);for(let JA=0;JA<T;JA++)for(let YA=0;YA<T;YA++)for(let HA=0;HA<T;HA++)u[TA+JA+YA*w+HA*M]=SA,B&&B(TA+JA+YA*w+HA*M,null,OA)}else{const SA=Math.round(Z*T)+Math.round(oA*V)*U+Math.round(wA*tA)*W;u[SA*T]=E.getValue(CA)*(255-MA+Math.random()*MA),B&&B(SA,CA)}if(Q++,s&&(d.needsUpdate=!0,C&&(C.needsUpdate=!0)),wA>=U){B=null,C.needsUpdate=!0;return}Z++,CA.x+=AA.x,Z>=U&&(Z=0,CA.x-=AA.x*U,oA++,CA.y+=AA.y),oA>=U&&(oA=0,CA.y-=AA.y*U,wA++,CA.z+=AA.z),yield}}let mA=uA();const fA=()=>{mA&&(this.processes[f]=requestAnimationFrame(fA));let RA=window.performance.now();for(;window.performance.now()-RA<16&&mA;){const{done:MA}=mA.next();a&&a({convertedVoxels:Q,totalVoxels:l,convertedGrids:c,totalGrids:h}),MA&&(c++,mA=null,delete this.processes[f],N(),c===h&&(s||this.add(D),n&&n()))}};fA()});s&&this.add(D);for(let U=0;U<=p.length;U++)await R(p[U])})}dispose(){!this.processes||(this.processes.forEach((t,e)=>{cancelAnimationFrame(t),delete this.processes[e]}),this.processes=null)}}class Me{constructor(A,t,e){this.x=A,this.y=t,this.z=e}dot2(A,t){return this.x*A+this.y*t}dot3(A,t,e){return this.x*A+this.y*t+this.z*e}}const Rv=[new Me(1,1,0),new Me(-1,1,0),new Me(1,-1,0),new Me(-1,-1,0),new Me(1,0,1),new Me(-1,0,1),new Me(1,0,-1),new Me(-1,0,-1),new Me(0,1,1),new Me(0,-1,1),new Me(0,1,-1),new Me(0,-1,-1)],Cc=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],Ht=new Array(512),je=new Array(512);(i=>{i>0&&i<1&&(i*=65536),i=Math.floor(i),i<256&&(i|=i<<8);for(let A=0;A<256;A++){let t;A&1?t=Cc[A]^i&255:t=Cc[A]^i>>8&255,Ht[A]=Ht[A+256]=t,je[A]=je[A+256]=Rv[t%12]}})(0);const mI=i=>i*i*i*(i*(i*6-15)+10),un=(i,A,t)=>(1-t)*i+t*A,Bc=(i,A,t)=>{var e=Math.floor(i),n=Math.floor(A),a=Math.floor(t);i=i-e,A=A-n,t=t-a,e=e&255,n=n&255,a=a&255;var o=je[e+Ht[n+Ht[a]]].dot3(i,A,t),s=je[e+Ht[n+Ht[a+1]]].dot3(i,A,t-1),I=je[e+Ht[n+1+Ht[a]]].dot3(i,A-1,t),r=je[e+Ht[n+1+Ht[a+1]]].dot3(i,A-1,t-1),g=je[e+1+Ht[n+Ht[a]]].dot3(i-1,A,t),C=je[e+1+Ht[n+Ht[a+1]]].dot3(i-1,A,t-1),B=je[e+1+Ht[n+1+Ht[a]]].dot3(i-1,A-1,t),c=je[e+1+Ht[n+1+Ht[a+1]]].dot3(i-1,A-1,t-1),Q=mI(i),h=mI(A),l=mI(t);return un(un(un(o,g,Q),un(s,C,Q),l),un(un(I,B,Q),un(r,c,Q),l),h)};class me{constructor(A=3e3){this._seedValue=A,this.setSeed=this.setSeed.bind(this),this.noise=this.noise.bind(this),this.Euclidean=this.Euclidean.bind(this),this.Manhattan=this.Manhattan.bind(this)}static xorshift(A){let t=A^A>>12;return t=t^t<<25,t=t^t>>27,t*2}static hash(A,t,e){return(((2166136261^A)*16777619^t)*16777619^e)*16777619&4294967295}static d(A,t){return[A.x-t.x,A.y-t.y,A.z-t.z]}static EuclideanDistance(A,t){return me.d(A,t).reduce((e,n)=>e+n*n,0)}static ManhattanDistance(A,t){return me.d(A,t).reduce((e,n)=>e+Math.abs(n),0)}static probLookup(A){return A=A&4294967295,A<393325350?1:A<1022645910?2:A<1861739990?3:A<2700834071?4:A<3372109335?5:A<3819626178?6:A<4075350088?7:A<4203212043?8:9}static insert(A,t){let e;for(let n=A.length-1;n>=0&&!(t>A[n]);n--)e=A[n],A[n]=t,n+1<A.length&&(A[n+1]=e)}noise(A,t){let e,n,a={x:0,y:0,z:0},o={x:0,y:0,z:0},s,I,r,g=[9999999,9999999,9999999];for(let C=-1;C<2;++C)for(let B=-1;B<2;++B)for(let c=-1;c<2;++c){s=Math.floor(A.x)+C,I=Math.floor(A.y)+B,r=Math.floor(A.z)+c,e=me.xorshift(me.hash(s+this._seedValue&4294967295,I&4294967295,r&4294967295)),n=me.probLookup(e);for(let Q=0;Q<n;++Q)e=me.xorshift(e),a.X=e/4294967296,e=me.xorshift(e),a.Y=e/4294967296,e=me.xorshift(e),a.Z=e/4294967296,o={x:a.X+s,y:a.Y+I,z:a.Z+r},me.insert(g,t(A,o))}return g.map(C=>C<0?0:C>1?1:C)}setSeed(A=3e3){this._seedValue=A}Euclidean(A,t,e){return this.noise({x:A,y:t,z:e},me.EuclideanDistance)[0]}Manhattan(A,t,e){return this.noise({x:A,y:t,z:e},me.ManhattanDistance)[0]}}const vv=new me,yI=vv.Euclidean;class Gv extends Se{constructor(){super();UA(this,"saveAsHalfFloat",!1);UA(this,"leavesCount",0);UA(this,"uniqueName");UA(this,"gridName");UA(this,"gridType");this.readGrid()}readGrid(){this.readGridHeader(),this.readGridTransform()}readGridHeader(){this.uniqueName=`CubeVolume#${Math.random()}`,this.gridName=this.uniqueName.split("#")[0],this.gridType="fog volume"}readCompression(){}readMetadata(){}getGridValueType(){return si}getGridClass(){return"fog volume"}readGridTransform(){this.transform=new co}readTopology(){}getWorldBbox(){return this.getLocalBbox()}getLocalBbox(){return[new nt(-.5,-.5,-.5),new nt(.5,.5,.5)]}getPreciseWorldBbox(){return this.getWorldBbox()}getValue(t){return 1}getLeafAt(t){return null}}UA(Gv,"halfFloatGridPrefix",Se.halfFloatGridPrefix);class Nv extends Se{constructor(){super();UA(this,"saveAsHalfFloat",!1);UA(this,"leavesCount",0);UA(this,"uniqueName");UA(this,"gridName");UA(this,"gridType");this.readGrid()}readGrid(){this.readGridHeader(),this.readGridTransform()}readGridHeader(){this.uniqueName=`SphereVolume#${Math.random()}`,this.gridName=this.uniqueName.split("#")[0],this.gridType="fog volume"}readCompression(){}readMetadata(){}getGridValueType(){return si}getGridClass(){return"fog volume"}readGridTransform(){this.transform=new co}readTopology(){}getWorldBbox(){return this.getLocalBbox()}getLocalBbox(){return[new nt(-.5,-.5,-.5),new nt(.5,.5,.5)]}getPreciseWorldBbox(){return this.getWorldBbox()}getValue(t){return t.length()<=.5?1:0}getLeafAt(t){return null}}UA(Nv,"halfFloatGridPrefix",Se.halfFloatGridPrefix);class Lv extends Se{constructor(t){super();UA(this,"saveAsHalfFloat",!1);UA(this,"leavesCount",0);UA(this,"uniqueName");UA(this,"gridName");UA(this,"gridType");UA(this,"valueFunction");this.readGrid(),this.valueFunction=t}readGrid(){this.readGridHeader(),this.readGridTransform()}readGridHeader(){this.uniqueName=`ParametricVolume#${Math.random()}`,this.gridName=this.uniqueName.split("#")[0],this.gridType="fog volume"}readCompression(){}readMetadata(){}getGridValueType(){return si}getGridClass(){return"fog volume"}readGridTransform(){this.transform=new co}readTopology(){}getWorldBbox(){return this.getLocalBbox()}getLocalBbox(){return[new nt(-.5,-.5,-.5),new nt(.5,.5,.5)]}getPreciseWorldBbox(){return this.getWorldBbox()}getValue(t){return this.valueFunction(t)}getLeafAt(t){return null}}UA(Lv,"halfFloatGridPrefix",Se.halfFloatGridPrefix);class BQ extends Se{constructor({height:t,density:e}={}){super();UA(this,"saveAsHalfFloat",!1);UA(this,"leavesCount",0);UA(this,"uniqueName");UA(this,"gridName");UA(this,"gridType");UA(this,"height",1);UA(this,"density",.01);this.height=t||1,this.density=e||.01,this.readGrid()}readGrid(){this.readGridHeader(),this.readGridTransform()}readGridHeader(){this.uniqueName=`CloudVolume#${Math.random()}`,this.gridName=this.uniqueName.split("#")[0],this.gridType="fog volume"}readCompression(){}readMetadata(){}getGridValueType(){return si}getGridClass(){return"fog volume"}readGridTransform(){this.transform=new co}readTopology(){}getWorldBbox(){return this.getLocalBbox()}getLocalBbox(){return[new nt(-.5,-.5,-.5),new nt(.5,.5,.5)]}getPreciseWorldBbox(){return this.getWorldBbox()}getValue(t){const e=new nt(t.x+.5,t.y+.5,t.z+.5),n=(a,o)=>{const s=e.x*a%a,I=e.y*a%a,r=e.z*a%a,g=Math.abs(s-.5),C=Math.abs(I-.5),B=Math.abs(r-.5);return o(g,C,B)};if(e.y<this.height){const a=this.height-e.y;return n(20,yI)+n(100,yI)*.25+n(10,Bc)<this.density?.5*a+n(100,Bc)+n(100,yI):0}return 0}getLeafAt(t){return null}}UA(BQ,"halfFloatGridPrefix",Se.halfFloatGridPrefix);/**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.18.1
 * @author George Michael Brower
 * @license MIT
 */class Ii{constructor(A,t,e,n,a="div"){this.parent=A,this.object=t,this.property=e,this._disabled=!1,this._hidden=!1,this.initialValue=this.getValue(),this.domElement=document.createElement("div"),this.domElement.classList.add("controller"),this.domElement.classList.add(n),this.$name=document.createElement("div"),this.$name.classList.add("name"),Ii.nextNameID=Ii.nextNameID||0,this.$name.id=`lil-gui-name-${++Ii.nextNameID}`,this.$widget=document.createElement(a),this.$widget.classList.add("widget"),this.$disable=this.$widget,this.domElement.appendChild(this.$name),this.domElement.appendChild(this.$widget),this.parent.children.push(this),this.parent.controllers.push(this),this.parent.$children.appendChild(this.domElement),this._listenCallback=this._listenCallback.bind(this),this.name(e)}name(A){return this._name=A,this.$name.innerHTML=A,this}onChange(A){return this._onChange=A,this}_callOnChange(){this.parent._callOnChange(this),this._onChange!==void 0&&this._onChange.call(this,this.getValue()),this._changed=!0}onFinishChange(A){return this._onFinishChange=A,this}_callOnFinishChange(){this._changed&&(this.parent._callOnFinishChange(this),this._onFinishChange!==void 0&&this._onFinishChange.call(this,this.getValue())),this._changed=!1}reset(){return this.setValue(this.initialValue),this._callOnFinishChange(),this}enable(A=!0){return this.disable(!A)}disable(A=!0){return A===this._disabled?this:(this._disabled=A,this.domElement.classList.toggle("disabled",A),this.$disable.toggleAttribute("disabled",A),this)}show(A=!0){return this._hidden=!A,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}options(A){const t=this.parent.add(this.object,this.property,A);return t.name(this._name),this.destroy(),t}min(A){return this}max(A){return this}step(A){return this}decimals(A){return this}listen(A=!0){return this._listening=A,this._listenCallbackID!==void 0&&(cancelAnimationFrame(this._listenCallbackID),this._listenCallbackID=void 0),this._listening&&this._listenCallback(),this}_listenCallback(){this._listenCallbackID=requestAnimationFrame(this._listenCallback);const A=this.save();A!==this._listenPrevValue&&this.updateDisplay(),this._listenPrevValue=A}getValue(){return this.object[this.property]}setValue(A){return this.object[this.property]=A,this._callOnChange(),this.updateDisplay(),this}updateDisplay(){return this}load(A){return this.setValue(A),this._callOnFinishChange(),this}save(){return this.getValue()}destroy(){this.listen(!1),this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.controllers.splice(this.parent.controllers.indexOf(this),1),this.parent.$children.removeChild(this.domElement)}}class bv extends Ii{constructor(A,t,e){super(A,t,e,"boolean","label"),this.$input=document.createElement("input"),this.$input.setAttribute("type","checkbox"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$input.addEventListener("change",()=>{this.setValue(this.$input.checked),this._callOnFinishChange()}),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.checked=this.getValue(),this}}function jI(i){let A,t;return(A=i.match(/(#|0x)?([a-f0-9]{6})/i))?t=A[2]:(A=i.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))?t=parseInt(A[1]).toString(16).padStart(2,0)+parseInt(A[2]).toString(16).padStart(2,0)+parseInt(A[3]).toString(16).padStart(2,0):(A=i.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i))&&(t=A[1]+A[1]+A[2]+A[2]+A[3]+A[3]),t?"#"+t:!1}const Uv={isPrimitive:!0,match:i=>typeof i=="string",fromHexString:jI,toHexString:jI},no={isPrimitive:!0,match:i=>typeof i=="number",fromHexString:i=>parseInt(i.substring(1),16),toHexString:i=>"#"+i.toString(16).padStart(6,0)},kv={isPrimitive:!1,match:i=>Array.isArray(i),fromHexString(i,A,t=1){const e=no.fromHexString(i);A[0]=(e>>16&255)/255*t,A[1]=(e>>8&255)/255*t,A[2]=(e&255)/255*t},toHexString([i,A,t],e=1){e=255/e;const n=i*e<<16^A*e<<8^t*e<<0;return no.toHexString(n)}},Tv={isPrimitive:!1,match:i=>Object(i)===i,fromHexString(i,A,t=1){const e=no.fromHexString(i);A.r=(e>>16&255)/255*t,A.g=(e>>8&255)/255*t,A.b=(e&255)/255*t},toHexString({r:i,g:A,b:t},e=1){e=255/e;const n=i*e<<16^A*e<<8^t*e<<0;return no.toHexString(n)}},Hv=[Uv,no,kv,Tv];function qv(i){return Hv.find(A=>A.match(i))}class Jv extends Ii{constructor(A,t,e,n){super(A,t,e,"color"),this.$input=document.createElement("input"),this.$input.setAttribute("type","color"),this.$input.setAttribute("tabindex",-1),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$text=document.createElement("input"),this.$text.setAttribute("type","text"),this.$text.setAttribute("spellcheck","false"),this.$text.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$display.appendChild(this.$input),this.$widget.appendChild(this.$display),this.$widget.appendChild(this.$text),this._format=qv(this.initialValue),this._rgbScale=n,this._initialValueHexString=this.save(),this._textFocused=!1,this.$input.addEventListener("input",()=>{this._setValueFromHexString(this.$input.value)}),this.$input.addEventListener("blur",()=>{this._callOnFinishChange()}),this.$text.addEventListener("input",()=>{const a=jI(this.$text.value);a&&this._setValueFromHexString(a)}),this.$text.addEventListener("focus",()=>{this._textFocused=!0,this.$text.select()}),this.$text.addEventListener("blur",()=>{this._textFocused=!1,this.updateDisplay(),this._callOnFinishChange()}),this.$disable=this.$text,this.updateDisplay()}reset(){return this._setValueFromHexString(this._initialValueHexString),this}_setValueFromHexString(A){if(this._format.isPrimitive){const t=this._format.fromHexString(A);this.setValue(t)}else this._format.fromHexString(A,this.getValue(),this._rgbScale),this._callOnChange(),this.updateDisplay()}save(){return this._format.toHexString(this.getValue(),this._rgbScale)}load(A){return this._setValueFromHexString(A),this._callOnFinishChange(),this}updateDisplay(){return this.$input.value=this._format.toHexString(this.getValue(),this._rgbScale),this._textFocused||(this.$text.value=this.$input.value.substring(1)),this.$display.style.backgroundColor=this.$input.value,this}}class DI extends Ii{constructor(A,t,e){super(A,t,e,"function"),this.$button=document.createElement("button"),this.$button.appendChild(this.$name),this.$widget.appendChild(this.$button),this.$button.addEventListener("click",n=>{n.preventDefault(),this.getValue().call(this.object),this._callOnChange()}),this.$button.addEventListener("touchstart",()=>{},{passive:!0}),this.$disable=this.$button}}class Pv extends Ii{constructor(A,t,e,n,a,o){super(A,t,e,"number"),this._initInput(),this.min(n),this.max(a);const s=o!==void 0;this.step(s?o:this._getImplicitStep(),s),this.updateDisplay()}decimals(A){return this._decimals=A,this.updateDisplay(),this}min(A){return this._min=A,this._onUpdateMinMax(),this}max(A){return this._max=A,this._onUpdateMinMax(),this}step(A,t=!0){return this._step=A,this._stepExplicit=t,this}updateDisplay(){const A=this.getValue();if(this._hasSlider){let t=(A-this._min)/(this._max-this._min);t=Math.max(0,Math.min(t,1)),this.$fill.style.width=t*100+"%"}return this._inputFocused||(this.$input.value=this._decimals===void 0?A:A.toFixed(this._decimals)),this}_initInput(){this.$input=document.createElement("input"),this.$input.setAttribute("type","number"),this.$input.setAttribute("step","any"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$disable=this.$input;const A=()=>{let E=parseFloat(this.$input.value);isNaN(E)||(this._stepExplicit&&(E=this._snap(E)),this.setValue(this._clamp(E)))},t=E=>{const f=parseFloat(this.$input.value);isNaN(f)||(this._snapClampSetValue(f+E),this.$input.value=this.getValue())},e=E=>{E.code==="Enter"&&this.$input.blur(),E.code==="ArrowUp"&&(E.preventDefault(),t(this._step*this._arrowKeyMultiplier(E))),E.code==="ArrowDown"&&(E.preventDefault(),t(this._step*this._arrowKeyMultiplier(E)*-1))},n=E=>{this._inputFocused&&(E.preventDefault(),t(this._step*this._normalizeMouseWheel(E)))};let a=!1,o,s,I,r,g;const C=5,B=E=>{o=E.clientX,s=I=E.clientY,a=!0,r=this.getValue(),g=0,window.addEventListener("mousemove",c),window.addEventListener("mouseup",Q)},c=E=>{if(a){const f=E.clientX-o,u=E.clientY-s;Math.abs(u)>C?(E.preventDefault(),this.$input.blur(),a=!1,this._setDraggingStyle(!0,"vertical")):Math.abs(f)>C&&Q()}a||(g-=(E.clientY-I)*this._step*this._arrowKeyMultiplier(E),r+g>this._max?g=this._max-r:r+g<this._min&&(g=this._min-r),this._snapClampSetValue(r+g)),I=E.clientY},Q=()=>{this._setDraggingStyle(!1,"vertical"),this._callOnFinishChange(),window.removeEventListener("mousemove",c),window.removeEventListener("mouseup",Q)},h=()=>{this._inputFocused=!0},l=()=>{this._inputFocused=!1,this.updateDisplay(),this._callOnFinishChange()};this.$input.addEventListener("input",A),this.$input.addEventListener("keydown",e),this.$input.addEventListener("wheel",n,{passive:!1}),this.$input.addEventListener("mousedown",B),this.$input.addEventListener("focus",h),this.$input.addEventListener("blur",l)}_initSlider(){this._hasSlider=!0,this.$slider=document.createElement("div"),this.$slider.classList.add("slider"),this.$fill=document.createElement("div"),this.$fill.classList.add("fill"),this.$slider.appendChild(this.$fill),this.$widget.insertBefore(this.$slider,this.$input),this.domElement.classList.add("hasSlider");const A=(E,f,u,d,m)=>(E-f)/(u-f)*(m-d)+d,t=E=>{const f=this.$slider.getBoundingClientRect();let u=A(E,f.left,f.right,this._min,this._max);this._snapClampSetValue(u)},e=E=>{this._setDraggingStyle(!0),t(E.clientX),window.addEventListener("mousemove",n),window.addEventListener("mouseup",a)},n=E=>{t(E.clientX)},a=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("mousemove",n),window.removeEventListener("mouseup",a)};let o=!1,s,I;const r=E=>{E.preventDefault(),this._setDraggingStyle(!0),t(E.touches[0].clientX),o=!1},g=E=>{E.touches.length>1||(this._hasScrollBar?(s=E.touches[0].clientX,I=E.touches[0].clientY,o=!0):r(E),window.addEventListener("touchmove",C,{passive:!1}),window.addEventListener("touchend",B))},C=E=>{if(o){const f=E.touches[0].clientX-s,u=E.touches[0].clientY-I;Math.abs(f)>Math.abs(u)?r(E):(window.removeEventListener("touchmove",C),window.removeEventListener("touchend",B))}else E.preventDefault(),t(E.touches[0].clientX)},B=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("touchmove",C),window.removeEventListener("touchend",B)},c=this._callOnFinishChange.bind(this),Q=400;let h;const l=E=>{if(Math.abs(E.deltaX)<Math.abs(E.deltaY)&&this._hasScrollBar)return;E.preventDefault();const u=this._normalizeMouseWheel(E)*this._step;this._snapClampSetValue(this.getValue()+u),this.$input.value=this.getValue(),clearTimeout(h),h=setTimeout(c,Q)};this.$slider.addEventListener("mousedown",e),this.$slider.addEventListener("touchstart",g,{passive:!1}),this.$slider.addEventListener("wheel",l,{passive:!1})}_setDraggingStyle(A,t="horizontal"){this.$slider&&this.$slider.classList.toggle("active",A),document.body.classList.toggle("lil-gui-dragging",A),document.body.classList.toggle(`lil-gui-${t}`,A)}_getImplicitStep(){return this._hasMin&&this._hasMax?(this._max-this._min)/1e3:.1}_onUpdateMinMax(){!this._hasSlider&&this._hasMin&&this._hasMax&&(this._stepExplicit||this.step(this._getImplicitStep(),!1),this._initSlider(),this.updateDisplay())}_normalizeMouseWheel(A){let{deltaX:t,deltaY:e}=A;return Math.floor(A.deltaY)!==A.deltaY&&A.wheelDelta&&(t=0,e=-A.wheelDelta/120,e*=this._stepExplicit?1:10),t+-e}_arrowKeyMultiplier(A){let t=this._stepExplicit?1:10;return A.shiftKey?t*=10:A.altKey&&(t/=10),t}_snap(A){const t=Math.round(A/this._step)*this._step;return parseFloat(t.toPrecision(15))}_clamp(A){return A<this._min&&(A=this._min),A>this._max&&(A=this._max),A}_snapClampSetValue(A){this.setValue(this._clamp(this._snap(A)))}get _hasScrollBar(){const A=this.parent.root.$children;return A.scrollHeight>A.clientHeight}get _hasMin(){return this._min!==void 0}get _hasMax(){return this._max!==void 0}}class Yv extends Ii{constructor(A,t,e,n){super(A,t,e,"option"),this.$select=document.createElement("select"),this.$select.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this._values=Array.isArray(n)?n:Object.values(n),this._names=Array.isArray(n)?n:Object.keys(n),this._names.forEach(a=>{const o=document.createElement("option");o.innerHTML=a,this.$select.appendChild(o)}),this.$select.addEventListener("change",()=>{this.setValue(this._values[this.$select.selectedIndex]),this._callOnFinishChange()}),this.$select.addEventListener("focus",()=>{this.$display.classList.add("focus")}),this.$select.addEventListener("blur",()=>{this.$display.classList.remove("focus")}),this.$widget.appendChild(this.$select),this.$widget.appendChild(this.$display),this.$disable=this.$select,this.updateDisplay()}updateDisplay(){const A=this.getValue(),t=this._values.indexOf(A);return this.$select.selectedIndex=t,this.$display.innerHTML=t===-1?A:this._names[t],this}}class Kv extends Ii{constructor(A,t,e){super(A,t,e,"string"),this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$input.addEventListener("input",()=>{this.setValue(this.$input.value)}),this.$input.addEventListener("keydown",n=>{n.code==="Enter"&&this.$input.blur()}),this.$input.addEventListener("blur",()=>{this._callOnFinishChange()}),this.$widget.appendChild(this.$input),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.value=this.getValue(),this}}const Ov=`.lil-gui {
  font-family: var(--font-family);
  font-size: var(--font-size);
  line-height: 1;
  font-weight: normal;
  font-style: normal;
  text-align: left;
  background-color: var(--background-color);
  color: var(--text-color);
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  --background-color: #1f1f1f;
  --text-color: #ebebeb;
  --title-background-color: #111111;
  --title-text-color: #ebebeb;
  --widget-color: #424242;
  --hover-color: #4f4f4f;
  --focus-color: #595959;
  --number-color: #2cc9ff;
  --string-color: #a2db3c;
  --font-size: 11px;
  --input-font-size: 11px;
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;
  --padding: 4px;
  --spacing: 4px;
  --widget-height: 20px;
  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);
  --name-width: 45%;
  --slider-knob-width: 2px;
  --slider-input-width: 27%;
  --color-input-width: 27%;
  --slider-input-min-width: 45px;
  --color-input-min-width: 45px;
  --folder-indent: 7px;
  --widget-padding: 0 0 0 3px;
  --widget-border-radius: 2px;
  --checkbox-size: calc(0.75 * var(--widget-height));
  --scrollbar-width: 5px;
}
.lil-gui, .lil-gui * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
.lil-gui.root {
  width: var(--width, 245px);
  display: flex;
  flex-direction: column;
}
.lil-gui.root > .title {
  background: var(--title-background-color);
  color: var(--title-text-color);
}
.lil-gui.root > .children {
  overflow-x: hidden;
  overflow-y: auto;
}
.lil-gui.root > .children::-webkit-scrollbar {
  width: var(--scrollbar-width);
  height: var(--scrollbar-width);
  background: var(--background-color);
}
.lil-gui.root > .children::-webkit-scrollbar-thumb {
  border-radius: var(--scrollbar-width);
  background: var(--focus-color);
}
@media (pointer: coarse) {
  .lil-gui.allow-touch-styles {
    --widget-height: 28px;
    --padding: 6px;
    --spacing: 6px;
    --font-size: 13px;
    --input-font-size: 16px;
    --folder-indent: 10px;
    --scrollbar-width: 7px;
    --slider-input-min-width: 50px;
    --color-input-min-width: 65px;
  }
}
.lil-gui.force-touch-styles {
  --widget-height: 28px;
  --padding: 6px;
  --spacing: 6px;
  --font-size: 13px;
  --input-font-size: 16px;
  --folder-indent: 10px;
  --scrollbar-width: 7px;
  --slider-input-min-width: 50px;
  --color-input-min-width: 65px;
}
.lil-gui.autoPlace {
  max-height: 100%;
  position: fixed;
  top: 0;
  right: 15px;
  z-index: 1001;
}

.lil-gui .controller {
  display: flex;
  align-items: center;
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
}
.lil-gui .controller.disabled {
  opacity: 0.5;
}
.lil-gui .controller.disabled, .lil-gui .controller.disabled * {
  pointer-events: none !important;
}
.lil-gui .controller > .name {
  min-width: var(--name-width);
  flex-shrink: 0;
  white-space: pre;
  padding-right: var(--spacing);
  line-height: var(--widget-height);
}
.lil-gui .controller .widget {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: var(--widget-height);
}
.lil-gui .controller.string input {
  color: var(--string-color);
}
.lil-gui .controller.boolean .widget {
  cursor: pointer;
}
.lil-gui .controller.color .display {
  width: 100%;
  height: var(--widget-height);
  border-radius: var(--widget-border-radius);
  position: relative;
}
@media (hover: hover) {
  .lil-gui .controller.color .display:hover:before {
    content: " ";
    display: block;
    position: absolute;
    border-radius: var(--widget-border-radius);
    border: 1px solid #fff9;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
.lil-gui .controller.color input[type=color] {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}
.lil-gui .controller.color input[type=text] {
  margin-left: var(--spacing);
  font-family: var(--font-family-mono);
  min-width: var(--color-input-min-width);
  width: var(--color-input-width);
  flex-shrink: 0;
}
.lil-gui .controller.option select {
  opacity: 0;
  position: absolute;
  width: 100%;
  max-width: 100%;
}
.lil-gui .controller.option .display {
  position: relative;
  pointer-events: none;
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  line-height: var(--widget-height);
  max-width: 100%;
  overflow: hidden;
  word-break: break-all;
  padding-left: 0.55em;
  padding-right: 1.75em;
  background: var(--widget-color);
}
@media (hover: hover) {
  .lil-gui .controller.option .display.focus {
    background: var(--focus-color);
  }
}
.lil-gui .controller.option .display.active {
  background: var(--focus-color);
}
.lil-gui .controller.option .display:after {
  font-family: "lil-gui";
  content: "\u2195";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding-right: 0.375em;
}
.lil-gui .controller.option .widget,
.lil-gui .controller.option select {
  cursor: pointer;
}
@media (hover: hover) {
  .lil-gui .controller.option .widget:hover .display {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number input {
  color: var(--number-color);
}
.lil-gui .controller.number.hasSlider input {
  margin-left: var(--spacing);
  width: var(--slider-input-width);
  min-width: var(--slider-input-min-width);
  flex-shrink: 0;
}
.lil-gui .controller.number .slider {
  width: 100%;
  height: var(--widget-height);
  background-color: var(--widget-color);
  border-radius: var(--widget-border-radius);
  padding-right: var(--slider-knob-width);
  overflow: hidden;
  cursor: ew-resize;
  touch-action: pan-y;
}
@media (hover: hover) {
  .lil-gui .controller.number .slider:hover {
    background-color: var(--hover-color);
  }
}
.lil-gui .controller.number .slider.active {
  background-color: var(--focus-color);
}
.lil-gui .controller.number .slider.active .fill {
  opacity: 0.95;
}
.lil-gui .controller.number .fill {
  height: 100%;
  border-right: var(--slider-knob-width) solid var(--number-color);
  box-sizing: content-box;
}

.lil-gui-dragging .lil-gui {
  --hover-color: var(--widget-color);
}
.lil-gui-dragging * {
  cursor: ew-resize !important;
}

.lil-gui-dragging.lil-gui-vertical * {
  cursor: ns-resize !important;
}

.lil-gui .title {
  height: var(--title-height);
  line-height: calc(var(--title-height) - 4px);
  font-weight: 600;
  padding: 0 var(--padding);
  -webkit-tap-highlight-color: transparent;
  cursor: pointer;
  outline: none;
  text-decoration-skip: objects;
}
.lil-gui .title:before {
  font-family: "lil-gui";
  content: "\u25BE";
  padding-right: 2px;
  display: inline-block;
}
.lil-gui .title:active {
  background: var(--title-background-color);
  opacity: 0.75;
}
@media (hover: hover) {
  body:not(.lil-gui-dragging) .lil-gui .title:hover {
    background: var(--title-background-color);
    opacity: 0.85;
  }
  .lil-gui .title:focus {
    text-decoration: underline var(--focus-color);
  }
}
.lil-gui.root > .title:focus {
  text-decoration: none !important;
}
.lil-gui.closed > .title:before {
  content: "\u25B8";
}
.lil-gui.closed > .children {
  transform: translateY(-7px);
  opacity: 0;
}
.lil-gui.closed:not(.transition) > .children {
  display: none;
}
.lil-gui.transition > .children {
  transition-duration: 300ms;
  transition-property: height, opacity, transform;
  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);
  overflow: hidden;
  pointer-events: none;
}
.lil-gui .children:empty:before {
  content: "Empty";
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
  display: block;
  height: var(--widget-height);
  font-style: italic;
  line-height: var(--widget-height);
  opacity: 0.5;
}
.lil-gui.root > .children > .lil-gui > .title {
  border: 0 solid var(--widget-color);
  border-width: 1px 0;
  transition: border-color 300ms;
}
.lil-gui.root > .children > .lil-gui.closed > .title {
  border-bottom-color: transparent;
}
.lil-gui + .controller {
  border-top: 1px solid var(--widget-color);
  margin-top: 0;
  padding-top: var(--spacing);
}
.lil-gui .lil-gui .lil-gui > .title {
  border: none;
}
.lil-gui .lil-gui .lil-gui > .children {
  border: none;
  margin-left: var(--folder-indent);
  border-left: 2px solid var(--widget-color);
}
.lil-gui .lil-gui .controller {
  border: none;
}

.lil-gui input {
  -webkit-tap-highlight-color: transparent;
  border: 0;
  outline: none;
  font-family: var(--font-family);
  font-size: var(--input-font-size);
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  background: var(--widget-color);
  color: var(--text-color);
  width: 100%;
}
@media (hover: hover) {
  .lil-gui input:hover {
    background: var(--hover-color);
  }
  .lil-gui input:active {
    background: var(--focus-color);
  }
}
.lil-gui input:disabled {
  opacity: 1;
}
.lil-gui input[type=text],
.lil-gui input[type=number] {
  padding: var(--widget-padding);
}
.lil-gui input[type=text]:focus,
.lil-gui input[type=number]:focus {
  background: var(--focus-color);
}
.lil-gui input::-webkit-outer-spin-button,
.lil-gui input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.lil-gui input[type=number] {
  -moz-appearance: textfield;
}
.lil-gui input[type=checkbox] {
  appearance: none;
  -webkit-appearance: none;
  height: var(--checkbox-size);
  width: var(--checkbox-size);
  border-radius: var(--widget-border-radius);
  text-align: center;
  cursor: pointer;
}
.lil-gui input[type=checkbox]:checked:before {
  font-family: "lil-gui";
  content: "\u2713";
  font-size: var(--checkbox-size);
  line-height: var(--checkbox-size);
}
@media (hover: hover) {
  .lil-gui input[type=checkbox]:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button {
  -webkit-tap-highlight-color: transparent;
  outline: none;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: var(--font-size);
  color: var(--text-color);
  width: 100%;
  height: var(--widget-height);
  text-transform: none;
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  border: 1px solid var(--widget-color);
  text-align: center;
  line-height: calc(var(--widget-height) - 4px);
}
@media (hover: hover) {
  .lil-gui button:hover {
    background: var(--hover-color);
    border-color: var(--hover-color);
  }
  .lil-gui button:focus {
    border-color: var(--focus-color);
  }
}
.lil-gui button:active {
  background: var(--focus-color);
}

@font-face {
  font-family: "lil-gui";
  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");
}`;function Wv(i){const A=document.createElement("style");A.innerHTML=i;const t=document.querySelector("head link[rel=stylesheet], head style");t?document.head.insertBefore(A,t):document.head.appendChild(A)}let hc=!1;class Ul{constructor({parent:A,autoPlace:t=A===void 0,container:e,width:n,title:a="Controls",closeFolders:o=!1,injectStyles:s=!0,touchStyles:I=!0}={}){if(this.parent=A,this.root=A?A.root:this,this.children=[],this.controllers=[],this.folders=[],this._closed=!1,this._hidden=!1,this.domElement=document.createElement("div"),this.domElement.classList.add("lil-gui"),this.$title=document.createElement("div"),this.$title.classList.add("title"),this.$title.setAttribute("role","button"),this.$title.setAttribute("aria-expanded",!0),this.$title.setAttribute("tabindex",0),this.$title.addEventListener("click",()=>this.openAnimated(this._closed)),this.$title.addEventListener("keydown",r=>{(r.code==="Enter"||r.code==="Space")&&(r.preventDefault(),this.$title.click())}),this.$title.addEventListener("touchstart",()=>{},{passive:!0}),this.$children=document.createElement("div"),this.$children.classList.add("children"),this.domElement.appendChild(this.$title),this.domElement.appendChild(this.$children),this.title(a),I&&this.domElement.classList.add("allow-touch-styles"),this.parent){this.parent.children.push(this),this.parent.folders.push(this),this.parent.$children.appendChild(this.domElement);return}this.domElement.classList.add("root"),!hc&&s&&(Wv(Ov),hc=!0),e?e.appendChild(this.domElement):t&&(this.domElement.classList.add("autoPlace"),document.body.appendChild(this.domElement)),n&&this.domElement.style.setProperty("--width",n+"px"),this._closeFolders=o,this.domElement.addEventListener("keydown",r=>r.stopPropagation()),this.domElement.addEventListener("keyup",r=>r.stopPropagation())}add(A,t,e,n,a){if(Object(e)===e)return new Yv(this,A,t,e);const o=A[t];switch(typeof o){case"number":return new Pv(this,A,t,e,n,a);case"boolean":return new bv(this,A,t);case"string":return new Kv(this,A,t);case"function":return new DI(this,A,t)}console.error(`gui.add failed
	property:`,t,`
	object:`,A,`
	value:`,o)}addColor(A,t,e=1){return new Jv(this,A,t,e)}addFolder(A){const t=new Ul({parent:this,title:A});return this.root._closeFolders&&t.close(),t}load(A,t=!0){return A.controllers&&this.controllers.forEach(e=>{e instanceof DI||e._name in A.controllers&&e.load(A.controllers[e._name])}),t&&A.folders&&this.folders.forEach(e=>{e._title in A.folders&&e.load(A.folders[e._title])}),this}save(A=!0){const t={controllers:{},folders:{}};return this.controllers.forEach(e=>{if(!(e instanceof DI)){if(e._name in t.controllers)throw new Error(`Cannot save GUI with duplicate property "${e._name}"`);t.controllers[e._name]=e.save()}}),A&&this.folders.forEach(e=>{if(e._title in t.folders)throw new Error(`Cannot save GUI with duplicate folder "${e._title}"`);t.folders[e._title]=e.save()}),t}open(A=!0){return this._setClosed(!A),this.$title.setAttribute("aria-expanded",!this._closed),this.domElement.classList.toggle("closed",this._closed),this}close(){return this.open(!1)}_setClosed(A){this._closed!==A&&(this._closed=A,this._callOnOpenClose(this))}show(A=!0){return this._hidden=!A,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}openAnimated(A=!0){return this._setClosed(!A),this.$title.setAttribute("aria-expanded",!this._closed),requestAnimationFrame(()=>{const t=this.$children.clientHeight;this.$children.style.height=t+"px",this.domElement.classList.add("transition");const e=a=>{a.target===this.$children&&(this.$children.style.height="",this.domElement.classList.remove("transition"),this.$children.removeEventListener("transitionend",e))};this.$children.addEventListener("transitionend",e);const n=A?this.$children.scrollHeight:0;this.domElement.classList.toggle("closed",!A),requestAnimationFrame(()=>{this.$children.style.height=n+"px"})}),this}title(A){return this._title=A,this.$title.innerHTML=A,this}reset(A=!0){return(A?this.controllersRecursive():this.controllers).forEach(e=>e.reset()),this}onChange(A){return this._onChange=A,this}_callOnChange(A){this.parent&&this.parent._callOnChange(A),this._onChange!==void 0&&this._onChange.call(this,{object:A.object,property:A.property,value:A.getValue(),controller:A})}onFinishChange(A){return this._onFinishChange=A,this}_callOnFinishChange(A){this.parent&&this.parent._callOnFinishChange(A),this._onFinishChange!==void 0&&this._onFinishChange.call(this,{object:A.object,property:A.property,value:A.getValue(),controller:A})}onOpenClose(A){return this._onOpenClose=A,this}_callOnOpenClose(A){this.parent&&this.parent._callOnOpenClose(A),this._onOpenClose!==void 0&&this._onOpenClose.call(this,A)}destroy(){this.parent&&(this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.folders.splice(this.parent.folders.indexOf(this),1)),this.domElement.parentElement&&this.domElement.parentElement.removeChild(this.domElement),Array.from(this.children).forEach(A=>A.destroy())}controllersRecursive(){let A=Array.from(this.controllers);return this.folders.forEach(t=>{A=A.concat(t.controllersRecursive())}),A}foldersRecursive(){let A=Array.from(this.folders);return this.folders.forEach(t=>{A=A.concat(t.foldersRecursive())}),A}}const hQ=Ul;class Vv extends _m{constructor(A){super(A),this.type=Ri}parse(A){const s=function(u,d){switch(u){case 1:console.error("THREE.RGBELoader Read Error: "+(d||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(d||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(d||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(d||""))}return-1},C=`
`,B=function(u,d,m){d=d||1024;let D=u.pos,p=-1,w=0,M="",R=String.fromCharCode.apply(null,new Uint16Array(u.subarray(D,D+128)));for(;0>(p=R.indexOf(C))&&w<d&&D<u.byteLength;)M+=R,w+=R.length,D+=128,R+=String.fromCharCode.apply(null,new Uint16Array(u.subarray(D,D+128)));return-1<p?(m!==!1&&(u.pos+=w+p+1),M+R.slice(0,p)):!1},c=function(u){const d=/^#\?(\S+)/,m=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,S=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,D=/^\s*FORMAT=(\S+)\s*$/,p=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,w={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let M,R;if(u.pos>=u.byteLength||!(M=B(u)))return s(1,"no header found");if(!(R=M.match(d)))return s(3,"bad initial token");for(w.valid|=1,w.programtype=R[1],w.string+=M+`
`;M=B(u),M!==!1;){if(w.string+=M+`
`,M.charAt(0)==="#"){w.comments+=M+`
`;continue}if((R=M.match(m))&&(w.gamma=parseFloat(R[1])),(R=M.match(S))&&(w.exposure=parseFloat(R[1])),(R=M.match(D))&&(w.valid|=2,w.format=R[1]),(R=M.match(p))&&(w.valid|=4,w.height=parseInt(R[1],10),w.width=parseInt(R[2],10)),w.valid&2&&w.valid&4)break}return w.valid&2?w.valid&4?w:s(3,"missing image size specifier"):s(3,"missing format specifier")},Q=function(u,d,m){const S=d;if(S<8||S>32767||u[0]!==2||u[1]!==2||u[2]&128)return new Uint8Array(u);if(S!==(u[2]<<8|u[3]))return s(3,"wrong scanline width");const D=new Uint8Array(4*d*m);if(!D.length)return s(4,"unable to allocate buffer space");let p=0,w=0;const M=4*S,R=new Uint8Array(4),U=new Uint8Array(M);let N=m;for(;N>0&&w<u.byteLength;){if(w+4>u.byteLength)return s(1);if(R[0]=u[w++],R[1]=u[w++],R[2]=u[w++],R[3]=u[w++],R[0]!=2||R[1]!=2||(R[2]<<8|R[3])!=S)return s(3,"bad rgbe scanline format");let G=0,T;for(;G<M&&w<u.byteLength;){T=u[w++];const tA=T>128;if(tA&&(T-=128),T===0||G+T>M)return s(3,"bad scanline data");if(tA){const z=u[w++];for(let W=0;W<T;W++)U[G++]=z}else U.set(u.subarray(w,w+T),G),G+=T,w+=T}const V=S;for(let tA=0;tA<V;tA++){let z=0;D[p]=U[tA+z],z+=S,D[p+1]=U[tA+z],z+=S,D[p+2]=U[tA+z],z+=S,D[p+3]=U[tA+z],p+=4}N--}return D},h=function(u,d,m,S){const D=u[d+3],p=Math.pow(2,D-128)/255;m[S+0]=u[d+0]*p,m[S+1]=u[d+1]*p,m[S+2]=u[d+2]*p,m[S+3]=1},l=function(u,d,m,S){const D=u[d+3],p=Math.pow(2,D-128)/255;m[S+0]=To.toHalfFloat(Math.min(u[d+0]*p,65504)),m[S+1]=To.toHalfFloat(Math.min(u[d+1]*p,65504)),m[S+2]=To.toHalfFloat(Math.min(u[d+2]*p,65504)),m[S+3]=To.toHalfFloat(1)},E=new Uint8Array(A);E.pos=0;const f=c(E);if(f!==-1){const u=f.width,d=f.height,m=Q(E.subarray(E.pos),u,d);if(m!==-1){let S,D,p;switch(this.type){case ni:p=m.length/4;const w=new Float32Array(p*4);for(let R=0;R<p;R++)h(m,R*4,w,R*4);S=w,D=ni;break;case Ri:p=m.length/4;const M=new Uint16Array(p*4);for(let R=0;R<p;R++)l(m,R*4,M,R*4);S=M,D=Ri;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type);break}return{width:u,height:d,data:S,header:f.string,gamma:f.gamma,exposure:f.exposure,type:D}}}return null}setDataType(A){return this.type=A,this}load(A,t,e,n){function a(o,s){switch(o.type){case ni:case Ri:o.encoding=gn,o.minFilter=Wt,o.magFilter=Wt,o.generateMipmaps=!1,o.flipY=!0;break}t&&t(o,s)}return super.load(A,a,e,n)}}const SI={},kl=async(i,A)=>{if(!SI[A]){const t=await new Promise(e=>{new _v().load(A,n=>{e(n)},null,()=>{alert("Could not load the VDB file."),console.error("Could not load the VDB file.",{name:i,file:A})})});SI[A]={name:i,vdb:t}}return SI[A].vdb};new xm,new Vv;const zv=({scene:i})=>{kl("bunny_cloud.vdb","./assets/bunny_cloud.vdb").then(A=>{const t=new Mv(A),e=A.grids[Object.keys(A.grids)[0]],n=new ln;n.set(...e.getPreciseWorldBbox());const a=new rA;n.getSize(a).multiplyScalar(.5),t.position.y-=a.y,i.add(t),Or([{folder:"Bbox",children:[{id:"color",name:"Color",defaultValue:"#ff0000",onChange:o=>{t.children[0].material.color.set(o)}},{id:"opacity",name:"Opacity",defaultValue:.1,min:0,max:1,onChange:o=>{t.children.forEach(s=>{s.material.opacity=o})}}]}])})},Xv=({scene:i})=>{kl("bunny_cloud.vdb","./assets/bunny_cloud.vdb").then(A=>{const t=new wt(new Be(20,32,32),new UI({color:16777215}));i.add(t);const e=new wt(new Be(20,32,32),new UI({color:16777215}));e.position.set(-200,0,200),i.add(e);const n=new bl(A,{resolution:100,steps:400,baseColor:16777215,absorbance:1,progressive:!0}),a=A.grids[Object.keys(A.grids)[0]],o=new ln;o.set(...a.getPreciseWorldBbox());const s=new rA;o.getSize(s).multiplyScalar(.5),n.position.y-=s.y,i.add(n);const I=(D,p,w,M)=>{const R=new Zi,U=new eE(D,.5);return U.position.set(p,w,M),U.add(new wt(new Be(1,32,32),new nn({color:D}))),R.add(U),i.add(R),[U,R]},r=(D,p,w,M)=>{const R=new Zi,U=new tE(D,.5,null,.2,.6);return U.position.set(p,w,M),U.add(new wt(new Be(1,32,32),new nn({color:D}))),R.add(U),i.add(R),[U,R]},g=(D,p,w,M)=>{const R=new ul(D,.5);R.position.set(p,w,M);const U=new wt(new Be(1,32,32),new nn({color:D}));return U.position.set(p,w,M),i.add(R),i.add(U),[R,U]},[C,B]=r(16711935,50,80,0),[c]=r(16711680,0,80,0),[Q,h]=I(16711935,50,80,0),[l]=I(16711680,0,80,0),[E,f]=I(16777096,0,0,0);e.add(f);const[u]=I(16711935,0,-10,0);u.children=[];const[d,m]=g(16711680,0,0,-80),S=new AE(16711680,255,1);i.add(S),setInterval(()=>{B.rotateY(.005),h.rotateX(.005)},1),Or([{folder:"Scene",children:[{id:"showMesh",name:"Show Debug Mesh",defaultValue:!1,onChange:D=>{n.visible=!D,t.visible=!!D}},{id:"backgroundColor",name:"Background Color",defaultValue:"#598eff",onChange:D=>{i.background.set(D)}},{id:"lightSetup",name:"Lights",defaultValue:"hemi",options:{"Hemisphere Light":"hemi","Spot Lights":"spot","Point Lights":"point","Directional Light":"dir",Sun:"sun",Glow:"glow"},onChange:D=>{Q.visible=D==="point",l.visible=D==="point",C.visible=D==="spot",c.visible=D==="spot",d.visible=D==="dir",S.visible=D==="dir",S.visible=D==="hemi",E.visible=D==="sun",u.visible=D==="glow"}},{id:"lightColor",name:"Light Color",defaultValue:"#ff00ff",onChange:D=>{C.color.set(D),C.children[0].material.color.set(D),d.color.set(D),m.material.color.set(D),Q.color.set(D),Q.children[0].material.color.set(D),u.color.set(D)}},{id:"lightIntensity",name:"Light Intensity",defaultValue:1,min:0,max:1,onChange:D=>{C.intensity=D,c.intensity=D,d.intensity=D,S.intensity=D,Q.intensity=D,l.intensity=D,u.intensity=D}}]},{folder:"Fog Volume",children:[{id:"fogColor",name:"Fog Color",defaultValue:"#ffffff",onChange:D=>{n.materials.forEach(p=>p.baseColor=D),t.material.color.set(D)}},{id:"scatterColor",name:"Scatter Color",defaultValue:"#000000",onChange:D=>{n.materials.forEach(p=>p.scatterColor=D)}},{id:"absorbance",name:"Absorbance",defaultValue:1,min:0,max:1,onChange:D=>{n.materials.forEach(p=>p.absorbance=D)}},{id:"densityScale",name:"Density Scale",defaultValue:1,min:0,max:1,onChange:D=>{n.materials.forEach(p=>p.densityScale=D)}},{id:"noise",name:"Noise",defaultValue:.5,min:0,max:1,onChange:D=>{n.materials.forEach(p=>p.noiseScale=D)}},{id:"opacity",name:"Opacity",defaultValue:1,min:0,max:1,onChange:D=>{n.materials.forEach(p=>p.opacity=D)}},{id:"steps",name:"Steps",defaultValue:400,min:10,max:2e3,onChange:D=>{n.materials.forEach(p=>p.steps=D)}}]}])})},Zv=({scene:i})=>{const A=new wt(new Be(20,32,32),new bI({color:16777215}));i.add(A);const t=new wt(new Be(20,32,32),new bI({color:16777215}));t.position.set(-200,0,200),i.add(t);const e=new bl(new BQ({height:.2,density:.001}),{resolution:50,progressive:!0,steps:500,absorbance:.5,baseColor:11184810});e.scale.setScalar(1e3),e.position.y+=300,i.add(e),setInterval(()=>{e.materials.forEach(a=>{a.densityMap3D.offset3D.x+=1e-4,a.densityMap3D.offset3D.z+=1e-4})},1/60);const n=new ul(16777096,1);n.position.set(1,1,0),i.add(n),Or([{folder:"Scene",children:[{id:"showMesh",name:"Show Debug Mesh",defaultValue:!1,onChange:a=>{e.visible=!a,A.visible=!!a}},{id:"backgroundColor",name:"Background Color",defaultValue:"#598eff",onChange:a=>{i.background.set(a)}},{id:"lightIntensity",name:"Light Intensity",defaultValue:1,min:0,max:1,onChange:a=>{n.intensity=a}}]},{folder:"Fog Volume",children:[{id:"wrap3D",name:"3D Wrapping",defaultValue:Tn,options:{"Three.ClampToEdgeWrapping":se,"Three.RepeatWrapping":Ks,"Three.MirroredRepeatWrapping":Tn},onChange:a=>{e.materials.forEach(o=>o.wrap3D=a)}},{id:"fogColor",name:"Fog Color",defaultValue:"#ffffff",onChange:a=>{e.materials.forEach(o=>o.baseColor=a),A.material.color.set(a)}},{id:"scatterColor",name:"Scatter Color",defaultValue:`#${i.background.getHexString?i.background.getHexString():"888888"}`,onChange:a=>{e.materials.forEach(o=>o.scatterColor=a)}},{id:"absorbance",name:"Absorbance",defaultValue:.98,min:0,max:1,onChange:a=>{e.materials.forEach(o=>o.absorbance=a)}},{id:"densityScale",name:"Density Scale",defaultValue:1,min:0,max:1,onChange:a=>{e.materials.forEach(o=>o.densityScale=a)}},{id:"noise",name:"Noise",defaultValue:.5,min:0,max:1,onChange:a=>{e.materials.forEach(o=>o.noiseScale=a)}},{id:"opacity",name:"Opacity",defaultValue:1,min:0,max:1,onChange:a=>{e.materials.forEach(o=>o.opacity=a)}},{id:"steps",name:"Steps",defaultValue:400,min:10,max:1e3,onChange:a=>{e.materials.forEach(o=>o.steps=a)}}]}])};let Ms=new hQ;const jn=document.querySelector("#dropzone");let wI="vdb";const jv=()=>[{folder:"General",children:[{id:"demo",name:"Example",options:{Bunny:"bunny",Clouds:"clouds",Bbox:"bbox","Custom VDB":"vdb"},defaultValue:wI,onChange:i=>{if(i!==wI)switch(wI=i,_i.traverse(A=>{A.material&&A.material.dispose(),A.geometry&&A.geometry.dispose()}),_i.children=[],jn.style.display=i==="vdb"?"":"none",i){case"bbox":return zv({scene:_i});case"bunny":return Xv({scene:_i});case"clouds":return Zv({scene:_i});case"vdb":return pQ({scene:_i})}}}]}];let cQ=[];const Or=i=>{cQ=i,$v()},$v=()=>{Ms.destroy(),Ms=new hQ;const i={},A=(t,e)=>{e.forEach(n=>{n.folder||(i[n.id]=n.defaultValue)}),e.forEach(n=>{if(n.folder)A(Ms.addFolder(n.folder),n.children);else{let a;i[n.id]&&i[n.id][0]==="#"?a=t.addColor(i,n.id):a=t.add(i,n.id,n.options||n.min,n.max),a.name(n.name).onChange(o=>{n.onChange&&n.onChange(o)}),n.onChange&&n.onChange(n.defaultValue)}})};A(Ms,jv()),A(Ms,cQ)};var cc=[0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,0,16,17,18,18,19,19,20,20,20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29];function ct(){var i=this;function A(t,e){var n=0;do n|=1&t,t>>>=1,n<<=1;while(--e>0);return n>>>1}i.build_tree=function(t){var e,n,a,o=i.dyn_tree,s=i.stat_desc.static_tree,I=i.stat_desc.elems,r=-1;for(t.heap_len=0,t.heap_max=573,e=0;e<I;e++)o[2*e]!==0?(t.heap[++t.heap_len]=r=e,t.depth[e]=0):o[2*e+1]=0;for(;t.heap_len<2;)o[2*(a=t.heap[++t.heap_len]=r<2?++r:0)]=1,t.depth[a]=0,t.opt_len--,s&&(t.static_len-=s[2*a+1]);for(i.max_code=r,e=Math.floor(t.heap_len/2);e>=1;e--)t.pqdownheap(o,e);a=I;do e=t.heap[1],t.heap[1]=t.heap[t.heap_len--],t.pqdownheap(o,1),n=t.heap[1],t.heap[--t.heap_max]=e,t.heap[--t.heap_max]=n,o[2*a]=o[2*e]+o[2*n],t.depth[a]=Math.max(t.depth[e],t.depth[n])+1,o[2*e+1]=o[2*n+1]=a,t.heap[1]=a++,t.pqdownheap(o,1);while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],function(g){var C,B,c,Q,h,l,E=i.dyn_tree,f=i.stat_desc.static_tree,u=i.stat_desc.extra_bits,d=i.stat_desc.extra_base,m=i.stat_desc.max_length,S=0;for(Q=0;Q<=15;Q++)g.bl_count[Q]=0;for(E[2*g.heap[g.heap_max]+1]=0,C=g.heap_max+1;C<573;C++)(Q=E[2*E[2*(B=g.heap[C])+1]+1]+1)>m&&(Q=m,S++),E[2*B+1]=Q,B>i.max_code||(g.bl_count[Q]++,h=0,B>=d&&(h=u[B-d]),g.opt_len+=(l=E[2*B])*(Q+h),f&&(g.static_len+=l*(f[2*B+1]+h)));if(S!==0){do{for(Q=m-1;g.bl_count[Q]===0;)Q--;g.bl_count[Q]--,g.bl_count[Q+1]+=2,g.bl_count[m]--,S-=2}while(S>0);for(Q=m;Q!==0;Q--)for(B=g.bl_count[Q];B!==0;)(c=g.heap[--C])>i.max_code||(E[2*c+1]!=Q&&(g.opt_len+=(Q-E[2*c+1])*E[2*c],E[2*c+1]=Q),B--)}}(t),function(g,C,B){var c,Q,h,l=[],E=0;for(c=1;c<=15;c++)l[c]=E=E+B[c-1]<<1;for(Q=0;Q<=C;Q++)(h=g[2*Q+1])!==0&&(g[2*Q]=A(l[h]++,h))}(o,i.max_code,t.bl_count)}}function Ot(i,A,t,e,n){var a=this;a.static_tree=i,a.extra_bits=A,a.extra_base=t,a.elems=e,a.max_length=n}function Ze(i,A,t,e,n){var a=this;a.good_length=i,a.max_lazy=A,a.nice_length=t,a.max_chain=e,a.func=n}ct._length_code=[0,1,2,3,4,5,6,7,8,8,9,9,10,10,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28],ct.base_length=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],ct.base_dist=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],ct.d_code=function(i){return i<256?cc[i]:cc[256+(i>>>7)]},ct.extra_lbits=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ct.extra_dbits=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],ct.extra_blbits=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],ct.bl_order=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],Ot.static_ltree=[12,8,140,8,76,8,204,8,44,8,172,8,108,8,236,8,28,8,156,8,92,8,220,8,60,8,188,8,124,8,252,8,2,8,130,8,66,8,194,8,34,8,162,8,98,8,226,8,18,8,146,8,82,8,210,8,50,8,178,8,114,8,242,8,10,8,138,8,74,8,202,8,42,8,170,8,106,8,234,8,26,8,154,8,90,8,218,8,58,8,186,8,122,8,250,8,6,8,134,8,70,8,198,8,38,8,166,8,102,8,230,8,22,8,150,8,86,8,214,8,54,8,182,8,118,8,246,8,14,8,142,8,78,8,206,8,46,8,174,8,110,8,238,8,30,8,158,8,94,8,222,8,62,8,190,8,126,8,254,8,1,8,129,8,65,8,193,8,33,8,161,8,97,8,225,8,17,8,145,8,81,8,209,8,49,8,177,8,113,8,241,8,9,8,137,8,73,8,201,8,41,8,169,8,105,8,233,8,25,8,153,8,89,8,217,8,57,8,185,8,121,8,249,8,5,8,133,8,69,8,197,8,37,8,165,8,101,8,229,8,21,8,149,8,85,8,213,8,53,8,181,8,117,8,245,8,13,8,141,8,77,8,205,8,45,8,173,8,109,8,237,8,29,8,157,8,93,8,221,8,61,8,189,8,125,8,253,8,19,9,275,9,147,9,403,9,83,9,339,9,211,9,467,9,51,9,307,9,179,9,435,9,115,9,371,9,243,9,499,9,11,9,267,9,139,9,395,9,75,9,331,9,203,9,459,9,43,9,299,9,171,9,427,9,107,9,363,9,235,9,491,9,27,9,283,9,155,9,411,9,91,9,347,9,219,9,475,9,59,9,315,9,187,9,443,9,123,9,379,9,251,9,507,9,7,9,263,9,135,9,391,9,71,9,327,9,199,9,455,9,39,9,295,9,167,9,423,9,103,9,359,9,231,9,487,9,23,9,279,9,151,9,407,9,87,9,343,9,215,9,471,9,55,9,311,9,183,9,439,9,119,9,375,9,247,9,503,9,15,9,271,9,143,9,399,9,79,9,335,9,207,9,463,9,47,9,303,9,175,9,431,9,111,9,367,9,239,9,495,9,31,9,287,9,159,9,415,9,95,9,351,9,223,9,479,9,63,9,319,9,191,9,447,9,127,9,383,9,255,9,511,9,0,7,64,7,32,7,96,7,16,7,80,7,48,7,112,7,8,7,72,7,40,7,104,7,24,7,88,7,56,7,120,7,4,7,68,7,36,7,100,7,20,7,84,7,52,7,116,7,3,8,131,8,67,8,195,8,35,8,163,8,99,8,227,8],Ot.static_dtree=[0,5,16,5,8,5,24,5,4,5,20,5,12,5,28,5,2,5,18,5,10,5,26,5,6,5,22,5,14,5,30,5,1,5,17,5,9,5,25,5,5,5,21,5,13,5,29,5,3,5,19,5,11,5,27,5,7,5,23,5],Ot.static_l_desc=new Ot(Ot.static_ltree,ct.extra_lbits,257,286,15),Ot.static_d_desc=new Ot(Ot.static_dtree,ct.extra_dbits,0,30,15),Ot.static_bl_desc=new Ot(null,ct.extra_blbits,0,19,7);var Pe=[new Ze(0,0,0,0,0),new Ze(4,4,8,4,1),new Ze(4,5,16,8,1),new Ze(4,6,32,32,1),new Ze(4,4,16,16,2),new Ze(8,16,32,32,2),new Ze(8,16,128,128,2),new Ze(8,32,128,256,2),new Ze(32,128,258,1024,2),new Ze(32,258,258,4096,2)],lr=["need dictionary","stream end","","","stream error","data error","","buffer error","",""];function Ec(i,A,t,e){var n=i[2*A],a=i[2*t];return n<a||n==a&&e[A]<=e[t]}function A2(){var i,A,t,e,n,a,o,s,I,r,g,C,B,c,Q,h,l,E,f,u,d,m,S,D,p,w,M,R,U,N,G,T,V,tA,z,W,Y,CA,K,AA,lA,Z=this,oA=new ct,wA=new ct,uA=new ct;function mA(){var b;for(b=0;b<286;b++)G[2*b]=0;for(b=0;b<30;b++)T[2*b]=0;for(b=0;b<19;b++)V[2*b]=0;G[512]=1,Z.opt_len=Z.static_len=0,W=CA=0}function fA(b,X){var j,eA,sA=-1,L=b[1],k=0,hA=7,BA=4;for(L===0&&(hA=138,BA=3),b[2*(X+1)+1]=65535,j=0;j<=X;j++)eA=L,L=b[2*(j+1)+1],++k<hA&&eA==L||(k<BA?V[2*eA]+=k:eA!==0?(eA!=sA&&V[2*eA]++,V[32]++):k<=10?V[34]++:V[36]++,k=0,sA=eA,L===0?(hA=138,BA=3):eA==L?(hA=6,BA=3):(hA=7,BA=4))}function RA(b){Z.pending_buf[Z.pending++]=b}function MA(b){RA(255&b),RA(b>>>8&255)}function SA(b,X){var j,eA=X;lA>16-eA?(MA(AA|=(j=b)<<lA&65535),AA=j>>>16-lA,lA+=eA-16):(AA|=b<<lA&65535,lA+=eA)}function TA(b,X){var j=2*b;SA(65535&X[j],65535&X[j+1])}function OA(b,X){var j,eA,sA=-1,L=b[1],k=0,hA=7,BA=4;for(L===0&&(hA=138,BA=3),j=0;j<=X;j++)if(eA=L,L=b[2*(j+1)+1],!(++k<hA&&eA==L)){if(k<BA)do TA(eA,V);while(--k!=0);else eA!==0?(eA!=sA&&(TA(eA,V),k--),TA(16,V),SA(k-3,2)):k<=10?(TA(17,V),SA(k-3,3)):(TA(18,V),SA(k-11,7));k=0,sA=eA,L===0?(hA=138,BA=3):eA==L?(hA=6,BA=3):(hA=7,BA=4)}}function JA(){lA==16?(MA(AA),AA=0,lA=0):lA>=8&&(RA(255&AA),AA>>>=8,lA-=8)}function YA(b,X){var j,eA,sA;if(Z.pending_buf[Y+2*W]=b>>>8&255,Z.pending_buf[Y+2*W+1]=255&b,Z.pending_buf[tA+W]=255&X,W++,b===0?G[2*X]++:(CA++,b--,G[2*(ct._length_code[X]+256+1)]++,T[2*ct.d_code(b)]++),(8191&W)==0&&M>2){for(j=8*W,eA=d-l,sA=0;sA<30;sA++)j+=T[2*sA]*(5+ct.extra_dbits[sA]);if(j>>>=3,CA<Math.floor(W/2)&&j<Math.floor(eA/2))return!0}return W==z-1}function HA(b,X){var j,eA,sA,L,k=0;if(W!==0)do j=Z.pending_buf[Y+2*k]<<8&65280|255&Z.pending_buf[Y+2*k+1],eA=255&Z.pending_buf[tA+k],k++,j===0?TA(eA,b):(TA((sA=ct._length_code[eA])+256+1,b),(L=ct.extra_lbits[sA])!==0&&SA(eA-=ct.base_length[sA],L),j--,TA(sA=ct.d_code(j),X),(L=ct.extra_dbits[sA])!==0&&SA(j-=ct.base_dist[sA],L));while(k<W);TA(256,b),K=b[513]}function kA(){lA>8?MA(AA):lA>0&&RA(255&AA),AA=0,lA=0}function rt(b,X,j){SA(0+(j?1:0),3),function(eA,sA,L){kA(),K=8,MA(sA),MA(~sA),Z.pending_buf.set(s.subarray(eA,eA+sA),Z.pending),Z.pending+=sA}(b,X)}function $A(b){(function(X,j,eA){var sA,L,k=0;M>0?(oA.build_tree(Z),wA.build_tree(Z),k=function(){var hA;for(fA(G,oA.max_code),fA(T,wA.max_code),uA.build_tree(Z),hA=18;hA>=3&&V[2*ct.bl_order[hA]+1]===0;hA--);return Z.opt_len+=3*(hA+1)+5+5+4,hA}(),(L=Z.static_len+3+7>>>3)<=(sA=Z.opt_len+3+7>>>3)&&(sA=L)):sA=L=j+5,j+4<=sA&&X!=-1?rt(X,j,eA):L==sA?(SA(2+(eA?1:0),3),HA(Ot.static_ltree,Ot.static_dtree)):(SA(4+(eA?1:0),3),function(hA,BA,EA){var dA;for(SA(hA-257,5),SA(BA-1,5),SA(EA-4,4),dA=0;dA<EA;dA++)SA(V[2*ct.bl_order[dA]+1],3);OA(G,hA-1),OA(T,BA-1)}(oA.max_code+1,wA.max_code+1,k+1),HA(G,T)),mA(),eA&&kA()})(l>=0?l:-1,d-l,b),l=d,i.flush_pending()}function x(){var b,X,j,eA;do{if((eA=I-S-d)==0&&d===0&&S===0)eA=n;else if(eA==-1)eA--;else if(d>=n+n-262){s.set(s.subarray(n,n+n),0),m-=n,d-=n,l-=n,j=b=B;do X=65535&g[--j],g[j]=X>=n?X-n:0;while(--b!=0);j=b=n;do X=65535&r[--j],r[j]=X>=n?X-n:0;while(--b!=0);eA+=n}if(i.avail_in===0)return;b=i.read_buf(s,d+S,eA),(S+=b)>=3&&(C=((C=255&s[d])<<h^255&s[d+1])&Q)}while(S<262&&i.avail_in!==0)}function y(b){var X,j,eA=p,sA=d,L=D,k=d>n-262?d-(n-262):0,hA=N,BA=o,EA=d+258,dA=s[sA+L-1],yA=s[sA+L];D>=U&&(eA>>=2),hA>S&&(hA=S);do if(s[(X=b)+L]==yA&&s[X+L-1]==dA&&s[X]==s[sA]&&s[++X]==s[sA+1]){sA+=2,X++;do;while(s[++sA]==s[++X]&&s[++sA]==s[++X]&&s[++sA]==s[++X]&&s[++sA]==s[++X]&&s[++sA]==s[++X]&&s[++sA]==s[++X]&&s[++sA]==s[++X]&&s[++sA]==s[++X]&&sA<EA);if(j=258-(EA-sA),sA=EA-258,j>L){if(m=b,L=j,j>=hA)break;dA=s[sA+L-1],yA=s[sA+L]}}while((b=65535&r[b&BA])>k&&--eA!=0);return L<=S?L:S}Z.depth=[],Z.bl_count=[],Z.heap=[],G=[],T=[],V=[],Z.pqdownheap=function(b,X){for(var j=Z.heap,eA=j[X],sA=X<<1;sA<=Z.heap_len&&(sA<Z.heap_len&&Ec(b,j[sA+1],j[sA],Z.depth)&&sA++,!Ec(b,eA,j[sA],Z.depth));)j[X]=j[sA],X=sA,sA<<=1;j[X]=eA},Z.deflateInit=function(b,X,j,eA,sA,L){return eA||(eA=8),sA||(sA=8),L||(L=0),b.msg=null,X==-1&&(X=6),sA<1||sA>9||eA!=8||j<9||j>15||X<0||X>9||L<0||L>2?-2:(b.dstate=Z,o=(n=1<<(a=j))-1,Q=(B=1<<(c=sA+7))-1,h=Math.floor((c+3-1)/3),s=new Uint8Array(2*n),r=[],g=[],z=1<<sA+6,Z.pending_buf=new Uint8Array(4*z),t=4*z,Y=Math.floor(z/2),tA=3*z,M=X,R=L,function(k){return k.total_in=k.total_out=0,k.msg=null,Z.pending=0,Z.pending_out=0,A=113,e=0,oA.dyn_tree=G,oA.stat_desc=Ot.static_l_desc,wA.dyn_tree=T,wA.stat_desc=Ot.static_d_desc,uA.dyn_tree=V,uA.stat_desc=Ot.static_bl_desc,AA=0,lA=0,K=8,mA(),function(){var hA;for(I=2*n,g[B-1]=0,hA=0;hA<B-1;hA++)g[hA]=0;w=Pe[M].max_lazy,U=Pe[M].good_length,N=Pe[M].nice_length,p=Pe[M].max_chain,d=0,l=0,S=0,E=D=2,u=0,C=0}(),0}(b))},Z.deflateEnd=function(){return A!=42&&A!=113&&A!=666?-2:(Z.pending_buf=null,g=null,r=null,s=null,Z.dstate=null,A==113?-3:0)},Z.deflateParams=function(b,X,j){var eA=0;return X==-1&&(X=6),X<0||X>9||j<0||j>2?-2:(Pe[M].func!=Pe[X].func&&b.total_in!==0&&(eA=b.deflate(1)),M!=X&&(w=Pe[M=X].max_lazy,U=Pe[M].good_length,N=Pe[M].nice_length,p=Pe[M].max_chain),R=j,eA)},Z.deflateSetDictionary=function(b,X,j){var eA,sA=j,L=0;if(!X||A!=42)return-2;if(sA<3)return 0;for(sA>n-262&&(L=j-(sA=n-262)),s.set(X.subarray(L,L+sA),0),d=sA,l=sA,C=((C=255&s[0])<<h^255&s[1])&Q,eA=0;eA<=sA-3;eA++)r[eA&o]=g[C=(C<<h^255&s[eA+2])&Q],g[C]=eA;return 0},Z.deflate=function(b,X){var j,eA,sA,L,k,hA;if(X>4||X<0)return-2;if(!b.next_out||!b.next_in&&b.avail_in!==0||A==666&&X!=4)return b.msg=lr[4],-2;if(b.avail_out===0)return b.msg=lr[7],-5;if(i=b,L=e,e=X,A==42&&(eA=8+(a-8<<4)<<8,(sA=(M-1&255)>>1)>3&&(sA=3),eA|=sA<<6,d!==0&&(eA|=32),A=113,RA((hA=eA+=31-eA%31)>>8&255),RA(255&hA)),Z.pending!==0){if(i.flush_pending(),i.avail_out===0)return e=-1,0}else if(i.avail_in===0&&X<=L&&X!=4)return i.msg=lr[7],-5;if(A==666&&i.avail_in!==0)return b.msg=lr[7],-5;if(i.avail_in!==0||S!==0||X!=0&&A!=666){switch(k=-1,Pe[M].func){case 0:k=function(BA){var EA,dA=65535;for(dA>t-5&&(dA=t-5);;){if(S<=1){if(x(),S===0&&BA==0)return 0;if(S===0)break}if(d+=S,S=0,EA=l+dA,(d===0||d>=EA)&&(S=d-EA,d=EA,$A(!1),i.avail_out===0)||d-l>=n-262&&($A(!1),i.avail_out===0))return 0}return $A(BA==4),i.avail_out===0?BA==4?2:0:BA==4?3:1}(X);break;case 1:k=function(BA){for(var EA,dA=0;;){if(S<262){if(x(),S<262&&BA==0)return 0;if(S===0)break}if(S>=3&&(dA=65535&g[C=(C<<h^255&s[d+2])&Q],r[d&o]=g[C],g[C]=d),dA!==0&&(d-dA&65535)<=n-262&&R!=2&&(E=y(dA)),E>=3)if(EA=YA(d-m,E-3),S-=E,E<=w&&S>=3){E--;do d++,dA=65535&g[C=(C<<h^255&s[d+2])&Q],r[d&o]=g[C],g[C]=d;while(--E!=0);d++}else d+=E,E=0,C=((C=255&s[d])<<h^255&s[d+1])&Q;else EA=YA(0,255&s[d]),S--,d++;if(EA&&($A(!1),i.avail_out===0))return 0}return $A(BA==4),i.avail_out===0?BA==4?2:0:BA==4?3:1}(X);break;case 2:k=function(BA){for(var EA,dA,yA=0;;){if(S<262){if(x(),S<262&&BA==0)return 0;if(S===0)break}if(S>=3&&(yA=65535&g[C=(C<<h^255&s[d+2])&Q],r[d&o]=g[C],g[C]=d),D=E,f=m,E=2,yA!==0&&D<w&&(d-yA&65535)<=n-262&&(R!=2&&(E=y(yA)),E<=5&&(R==1||E==3&&d-m>4096)&&(E=2)),D>=3&&E<=D){dA=d+S-3,EA=YA(d-1-f,D-3),S-=D-1,D-=2;do++d<=dA&&(yA=65535&g[C=(C<<h^255&s[d+2])&Q],r[d&o]=g[C],g[C]=d);while(--D!=0);if(u=0,E=2,d++,EA&&($A(!1),i.avail_out===0))return 0}else if(u!==0){if((EA=YA(0,255&s[d-1]))&&$A(!1),d++,S--,i.avail_out===0)return 0}else u=1,d++,S--}return u!==0&&(EA=YA(0,255&s[d-1]),u=0),$A(BA==4),i.avail_out===0?BA==4?2:0:BA==4?3:1}(X)}if(k!=2&&k!=3||(A=666),k==0||k==2)return i.avail_out===0&&(e=-1),0;if(k==1){if(X==1)SA(2,3),TA(256,Ot.static_ltree),JA(),1+K+10-lA<9&&(SA(2,3),TA(256,Ot.static_ltree),JA()),K=7;else if(rt(0,0,!1),X==3)for(j=0;j<B;j++)g[j]=0;if(i.flush_pending(),i.avail_out===0)return e=-1,0}}return X!=4?0:1}}function EQ(){var i=this;i.next_in_index=0,i.next_out_index=0,i.avail_in=0,i.total_in=0,i.avail_out=0,i.total_out=0}function QQ(i){var A=new EQ,t=512,e=new Uint8Array(t),n=i?i.level:-1;n===void 0&&(n=-1),A.deflateInit(n),A.next_out=e,this.append=function(a,o){var s,I=[],r=0,g=0,C=0;if(a.length){A.next_in_index=0,A.next_in=a,A.avail_in=a.length;do{if(A.next_out_index=0,A.avail_out=t,A.deflate(0)!=0)throw new Error("deflating: "+A.msg);A.next_out_index&&I.push(A.next_out_index==t?new Uint8Array(e):new Uint8Array(e.subarray(0,A.next_out_index))),C+=A.next_out_index,o&&A.next_in_index>0&&A.next_in_index!=r&&(o(A.next_in_index),r=A.next_in_index)}while(A.avail_in>0||A.avail_out===0);return s=new Uint8Array(C),I.forEach(function(B){s.set(B,g),g+=B.length}),s}},this.flush=function(){var a,o,s=[],I=0,r=0;do{if(A.next_out_index=0,A.avail_out=t,(a=A.deflate(4))!=1&&a!=0)throw new Error("deflating: "+A.msg);t-A.avail_out>0&&s.push(new Uint8Array(e.subarray(0,A.next_out_index))),r+=A.next_out_index}while(A.avail_in>0||A.avail_out===0);return A.deflateEnd(),o=new Uint8Array(r),s.forEach(function(g){o.set(g,I),I+=g.length}),o}}EQ.prototype={deflateInit:function(i,A){var t=this;return t.dstate=new A2,A||(A=15),t.dstate.deflateInit(t,i,A)},deflate:function(i){var A=this;return A.dstate?A.dstate.deflate(A,i):-2},deflateEnd:function(){var i=this;if(!i.dstate)return-2;var A=i.dstate.deflateEnd();return i.dstate=null,A},deflateParams:function(i,A){var t=this;return t.dstate?t.dstate.deflateParams(t,i,A):-2},deflateSetDictionary:function(i,A){var t=this;return t.dstate?t.dstate.deflateSetDictionary(t,i,A):-2},read_buf:function(i,A,t){var e=this,n=e.avail_in;return n>t&&(n=t),n===0?0:(e.avail_in-=n,i.set(e.next_in.subarray(e.next_in_index,e.next_in_index+n),A),e.next_in_index+=n,e.total_in+=n,n)},flush_pending:function(){var i=this,A=i.dstate.pending;A>i.avail_out&&(A=i.avail_out),A!==0&&(i.next_out.set(i.dstate.pending_buf.subarray(i.dstate.pending_out,i.dstate.pending_out+A),i.next_out_index),i.next_out_index+=A,i.dstate.pending_out+=A,i.total_out+=A,i.avail_out-=A,i.dstate.pending-=A,i.dstate.pending===0&&(i.dstate.pending_out=0))}},self._zipjs_Deflater=QQ;var ye=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],t2=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],e2=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],i2=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],n2=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],a2=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],s2=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function $I(){var i,A,t,e,n,a;function o(I,r,g,C,B,c,Q,h,l,E,f){var u,d,m,S,D,p,w,M,R,U,N,G,T,V,tA;U=0,D=g;do t[I[r+U]]++,U++,D--;while(D!==0);if(t[0]==g)return Q[0]=-1,h[0]=0,0;for(M=h[0],p=1;p<=15&&t[p]===0;p++);for(w=p,M<p&&(M=p),D=15;D!==0&&t[D]===0;D--);for(m=D,M>D&&(M=D),h[0]=M,V=1<<p;p<D;p++,V<<=1)if((V-=t[p])<0)return-3;if((V-=t[D])<0)return-3;for(t[D]+=V,a[1]=p=0,U=1,T=2;--D!=0;)a[T]=p+=t[U],T++,U++;D=0,U=0;do(p=I[r+U])!==0&&(f[a[p]++]=D),U++;while(++D<g);for(g=a[m],a[0]=D=0,U=0,S=-1,G=-M,n[0]=0,N=0,tA=0;w<=m;w++)for(u=t[w];u--!=0;){for(;w>G+M;){if(S++,tA=(tA=m-(G+=M))>M?M:tA,(d=1<<(p=w-G))>u+1&&(d-=u+1,T=w,p<tA))for(;++p<tA&&!((d<<=1)<=t[++T]);)d-=t[T];if(E[0]+(tA=1<<p)>1440)return-3;n[S]=N=E[0],E[0]+=tA,S!==0?(a[S]=D,e[0]=p,e[1]=M,e[2]=N-n[S-1]-(p=D>>>G-M),l.set(e,3*(n[S-1]+p))):Q[0]=N}for(e[1]=w-G,U>=g?e[0]=192:f[U]<C?(e[0]=f[U]<256?0:96,e[2]=f[U++]):(e[0]=c[f[U]-C]+16+64,e[2]=B[f[U++]-C]),d=1<<w-G,p=D>>>G;p<tA;p+=d)l.set(e,3*(N+p));for(p=1<<w-1;(D&p)!=0;p>>>=1)D^=p;for(D^=p,R=(1<<G)-1;(D&R)!=a[S];)S--,R=(1<<(G-=M))-1}return V!==0&&m!=1?-5:0}function s(I){var r;for(i||(i=[],A=[],t=new Int32Array(16),e=[],n=new Int32Array(15),a=new Int32Array(16)),A.length<I&&(A=[]),r=0;r<I;r++)A[r]=0;for(r=0;r<16;r++)t[r]=0;for(r=0;r<3;r++)e[r]=0;n.set(t.subarray(0,15),0),a.set(t.subarray(0,16),0)}this.inflate_trees_bits=function(I,r,g,C,B){var c;return s(19),i[0]=0,(c=o(I,0,19,19,null,null,g,r,C,i,A))==-3?B.msg="oversubscribed dynamic bit lengths tree":c!=-5&&r[0]!==0||(B.msg="incomplete dynamic bit lengths tree",c=-3),c},this.inflate_trees_dynamic=function(I,r,g,C,B,c,Q,h,l){var E;return s(288),i[0]=0,(E=o(g,0,I,257,i2,n2,c,C,h,i,A))!=0||C[0]===0?(E==-3?l.msg="oversubscribed literal/length tree":E!=-4&&(l.msg="incomplete literal/length tree",E=-3),E):(s(288),(E=o(g,I,r,0,a2,s2,Q,B,h,i,A))!=0||B[0]===0&&I>257?(E==-3?l.msg="oversubscribed distance tree":E==-5?(l.msg="incomplete distance tree",E=-3):E!=-4&&(l.msg="empty distance tree with lengths",E=-3),E):0)}}function o2(){var i,A,t,e,n=this,a=0,o=0,s=0,I=0,r=0,g=0,C=0,B=0,c=0,Q=0;function h(l,E,f,u,d,m,S,D){var p,w,M,R,U,N,G,T,V,tA,z,W,Y,CA,K,AA;G=D.next_in_index,T=D.avail_in,U=S.bitb,N=S.bitk,tA=(V=S.write)<S.read?S.read-V-1:S.end-V,z=ye[l],W=ye[E];do{for(;N<20;)T--,U|=(255&D.read_byte(G++))<<N,N+=8;if((R=(w=f)[AA=3*((M=u)+(p=U&z))])!==0)for(;;){if(U>>=w[AA+1],N-=w[AA+1],(16&R)!=0){for(Y=w[AA+2]+(U&ye[R&=15]),U>>=R,N-=R;N<15;)T--,U|=(255&D.read_byte(G++))<<N,N+=8;for(R=(w=d)[AA=3*((M=m)+(p=U&W))];;){if(U>>=w[AA+1],N-=w[AA+1],(16&R)!=0){for(R&=15;N<R;)T--,U|=(255&D.read_byte(G++))<<N,N+=8;if(CA=w[AA+2]+(U&ye[R]),U>>=R,N-=R,tA-=Y,V>=CA)V-(K=V-CA)>0&&2>V-K?(S.window[V++]=S.window[K++],S.window[V++]=S.window[K++],Y-=2):(S.window.set(S.window.subarray(K,K+2),V),V+=2,K+=2,Y-=2);else{K=V-CA;do K+=S.end;while(K<0);if(Y>(R=S.end-K)){if(Y-=R,V-K>0&&R>V-K)do S.window[V++]=S.window[K++];while(--R!=0);else S.window.set(S.window.subarray(K,K+R),V),V+=R,K+=R,R=0;K=0}}if(V-K>0&&Y>V-K)do S.window[V++]=S.window[K++];while(--Y!=0);else S.window.set(S.window.subarray(K,K+Y),V),V+=Y,K+=Y,Y=0;break}if((64&R)!=0)return D.msg="invalid distance code",T+=Y=N>>3<(Y=D.avail_in-T)?N>>3:Y,G-=Y,N-=Y<<3,S.bitb=U,S.bitk=N,D.avail_in=T,D.total_in+=G-D.next_in_index,D.next_in_index=G,S.write=V,-3;p+=w[AA+2],R=w[AA=3*(M+(p+=U&ye[R]))]}break}if((64&R)!=0)return(32&R)!=0?(T+=Y=N>>3<(Y=D.avail_in-T)?N>>3:Y,G-=Y,N-=Y<<3,S.bitb=U,S.bitk=N,D.avail_in=T,D.total_in+=G-D.next_in_index,D.next_in_index=G,S.write=V,1):(D.msg="invalid literal/length code",T+=Y=N>>3<(Y=D.avail_in-T)?N>>3:Y,G-=Y,N-=Y<<3,S.bitb=U,S.bitk=N,D.avail_in=T,D.total_in+=G-D.next_in_index,D.next_in_index=G,S.write=V,-3);if(p+=w[AA+2],(R=w[AA=3*(M+(p+=U&ye[R]))])===0){U>>=w[AA+1],N-=w[AA+1],S.window[V++]=w[AA+2],tA--;break}}else U>>=w[AA+1],N-=w[AA+1],S.window[V++]=w[AA+2],tA--}while(tA>=258&&T>=10);return T+=Y=N>>3<(Y=D.avail_in-T)?N>>3:Y,G-=Y,N-=Y<<3,S.bitb=U,S.bitk=N,D.avail_in=T,D.total_in+=G-D.next_in_index,D.next_in_index=G,S.write=V,0}n.init=function(l,E,f,u,d,m){i=0,C=l,B=E,t=f,c=u,e=d,Q=m,A=null},n.proc=function(l,E,f){var u,d,m,S,D,p,w,M=0,R=0,U=0;for(U=E.next_in_index,S=E.avail_in,M=l.bitb,R=l.bitk,p=(D=l.write)<l.read?l.read-D-1:l.end-D;;)switch(i){case 0:if(p>=258&&S>=10&&(l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,f=h(C,B,t,c,e,Q,l,E),U=E.next_in_index,S=E.avail_in,M=l.bitb,R=l.bitk,p=(D=l.write)<l.read?l.read-D-1:l.end-D,f!=0)){i=f==1?7:9;break}s=C,A=t,o=c,i=1;case 1:for(u=s;R<u;){if(S===0)return l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,l.inflate_flush(E,f);f=0,S--,M|=(255&E.read_byte(U++))<<R,R+=8}if(M>>>=A[1+(d=3*(o+(M&ye[u])))],R-=A[d+1],(m=A[d])===0){I=A[d+2],i=6;break}if((16&m)!=0){r=15&m,a=A[d+2],i=2;break}if((64&m)==0){s=m,o=d/3+A[d+2];break}if((32&m)!=0){i=7;break}return i=9,E.msg="invalid literal/length code",f=-3,l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,l.inflate_flush(E,f);case 2:for(u=r;R<u;){if(S===0)return l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,l.inflate_flush(E,f);f=0,S--,M|=(255&E.read_byte(U++))<<R,R+=8}a+=M&ye[u],M>>=u,R-=u,s=B,A=e,o=Q,i=3;case 3:for(u=s;R<u;){if(S===0)return l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,l.inflate_flush(E,f);f=0,S--,M|=(255&E.read_byte(U++))<<R,R+=8}if(M>>=A[1+(d=3*(o+(M&ye[u])))],R-=A[d+1],(16&(m=A[d]))!=0){r=15&m,g=A[d+2],i=4;break}if((64&m)==0){s=m,o=d/3+A[d+2];break}return i=9,E.msg="invalid distance code",f=-3,l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,l.inflate_flush(E,f);case 4:for(u=r;R<u;){if(S===0)return l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,l.inflate_flush(E,f);f=0,S--,M|=(255&E.read_byte(U++))<<R,R+=8}g+=M&ye[u],M>>=u,R-=u,i=5;case 5:for(w=D-g;w<0;)w+=l.end;for(;a!==0;){if(p===0&&(D==l.end&&l.read!==0&&(p=(D=0)<l.read?l.read-D-1:l.end-D),p===0&&(l.write=D,f=l.inflate_flush(E,f),p=(D=l.write)<l.read?l.read-D-1:l.end-D,D==l.end&&l.read!==0&&(p=(D=0)<l.read?l.read-D-1:l.end-D),p===0)))return l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,l.inflate_flush(E,f);l.window[D++]=l.window[w++],p--,w==l.end&&(w=0),a--}i=0;break;case 6:if(p===0&&(D==l.end&&l.read!==0&&(p=(D=0)<l.read?l.read-D-1:l.end-D),p===0&&(l.write=D,f=l.inflate_flush(E,f),p=(D=l.write)<l.read?l.read-D-1:l.end-D,D==l.end&&l.read!==0&&(p=(D=0)<l.read?l.read-D-1:l.end-D),p===0)))return l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,l.inflate_flush(E,f);f=0,l.window[D++]=I,p--,i=0;break;case 7:if(R>7&&(R-=8,S++,U--),l.write=D,f=l.inflate_flush(E,f),p=(D=l.write)<l.read?l.read-D-1:l.end-D,l.read!=l.write)return l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,l.inflate_flush(E,f);i=8;case 8:return f=1,l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,l.inflate_flush(E,f);case 9:return f=-3,l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,l.inflate_flush(E,f);default:return f=-2,l.bitb=M,l.bitk=R,E.avail_in=S,E.total_in+=U-E.next_in_index,E.next_in_index=U,l.write=D,l.inflate_flush(E,f)}},n.free=function(){}}$I.inflate_trees_fixed=function(i,A,t,e){return i[0]=9,A[0]=5,t[0]=t2,e[0]=e2,0};var Qc=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function r2(i,A){var t,e=this,n=0,a=0,o=0,s=0,I=[0],r=[0],g=new o2,C=0,B=new Int32Array(4320),c=new $I;e.bitk=0,e.bitb=0,e.window=new Uint8Array(A),e.end=A,e.read=0,e.write=0,e.reset=function(Q,h){h&&(h[0]=0),n==6&&g.free(Q),n=0,e.bitk=0,e.bitb=0,e.read=e.write=0},e.reset(i,null),e.inflate_flush=function(Q,h){var l,E,f;return E=Q.next_out_index,(l=((f=e.read)<=e.write?e.write:e.end)-f)>Q.avail_out&&(l=Q.avail_out),l!==0&&h==-5&&(h=0),Q.avail_out-=l,Q.total_out+=l,Q.next_out.set(e.window.subarray(f,f+l),E),E+=l,(f+=l)==e.end&&(f=0,e.write==e.end&&(e.write=0),(l=e.write-f)>Q.avail_out&&(l=Q.avail_out),l!==0&&h==-5&&(h=0),Q.avail_out-=l,Q.total_out+=l,Q.next_out.set(e.window.subarray(f,f+l),E),E+=l,f+=l),Q.next_out_index=E,e.read=f,h},e.proc=function(Q,h){var l,E,f,u,d,m,S,D;for(u=Q.next_in_index,d=Q.avail_in,E=e.bitb,f=e.bitk,S=(m=e.write)<e.read?e.read-m-1:e.end-m;;)switch(n){case 0:for(;f<3;){if(d===0)return e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);h=0,d--,E|=(255&Q.read_byte(u++))<<f,f+=8}switch(C=1&(l=7&E),l>>>1){case 0:E>>>=3,E>>>=l=7&(f-=3),f-=l,n=1;break;case 1:var p=[],w=[],M=[[]],R=[[]];$I.inflate_trees_fixed(p,w,M,R),g.init(p[0],w[0],M[0],0,R[0],0),E>>>=3,f-=3,n=6;break;case 2:E>>>=3,f-=3,n=3;break;case 3:return E>>>=3,f-=3,n=9,Q.msg="invalid block type",h=-3,e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h)}break;case 1:for(;f<32;){if(d===0)return e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);h=0,d--,E|=(255&Q.read_byte(u++))<<f,f+=8}if((~E>>>16&65535)!=(65535&E))return n=9,Q.msg="invalid stored block lengths",h=-3,e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);a=65535&E,E=f=0,n=a!==0?2:C!==0?7:0;break;case 2:if(d===0||S===0&&(m==e.end&&e.read!==0&&(S=(m=0)<e.read?e.read-m-1:e.end-m),S===0&&(e.write=m,h=e.inflate_flush(Q,h),S=(m=e.write)<e.read?e.read-m-1:e.end-m,m==e.end&&e.read!==0&&(S=(m=0)<e.read?e.read-m-1:e.end-m),S===0)))return e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);if(h=0,(l=a)>d&&(l=d),l>S&&(l=S),e.window.set(Q.read_buf(u,l),m),u+=l,d-=l,m+=l,S-=l,(a-=l)!=0)break;n=C!==0?7:0;break;case 3:for(;f<14;){if(d===0)return e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);h=0,d--,E|=(255&Q.read_byte(u++))<<f,f+=8}if(o=l=16383&E,(31&l)>29||(l>>5&31)>29)return n=9,Q.msg="too many length or distance symbols",h=-3,e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);if(l=258+(31&l)+(l>>5&31),!t||t.length<l)t=[];else for(D=0;D<l;D++)t[D]=0;E>>>=14,f-=14,s=0,n=4;case 4:for(;s<4+(o>>>10);){for(;f<3;){if(d===0)return e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);h=0,d--,E|=(255&Q.read_byte(u++))<<f,f+=8}t[Qc[s++]]=7&E,E>>>=3,f-=3}for(;s<19;)t[Qc[s++]]=0;if(I[0]=7,(l=c.inflate_trees_bits(t,I,r,B,Q))!=0)return(h=l)==-3&&(t=null,n=9),e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);s=0,n=5;case 5:for(;!(s>=258+(31&(l=o))+(l>>5&31));){var U,N;for(l=I[0];f<l;){if(d===0)return e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);h=0,d--,E|=(255&Q.read_byte(u++))<<f,f+=8}if((N=B[3*(r[0]+(E&ye[l=B[3*(r[0]+(E&ye[l]))+1]]))+2])<16)E>>>=l,f-=l,t[s++]=N;else{for(D=N==18?7:N-14,U=N==18?11:3;f<l+D;){if(d===0)return e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);h=0,d--,E|=(255&Q.read_byte(u++))<<f,f+=8}if(f-=l,U+=(E>>>=l)&ye[D],E>>>=D,f-=D,(D=s)+U>258+(31&(l=o))+(l>>5&31)||N==16&&D<1)return t=null,n=9,Q.msg="invalid bit length repeat",h=-3,e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);N=N==16?t[D-1]:0;do t[D++]=N;while(--U!=0);s=D}}r[0]=-1;var G=[],T=[],V=[],tA=[];if(G[0]=9,T[0]=6,(l=c.inflate_trees_dynamic(257+(31&(l=o)),1+(l>>5&31),t,G,T,V,tA,B,Q))!=0)return l==-3&&(t=null,n=9),h=l,e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);g.init(G[0],T[0],B,V[0],B,tA[0]),n=6;case 6:if(e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,(h=g.proc(e,Q,h))!=1)return e.inflate_flush(Q,h);if(h=0,g.free(Q),u=Q.next_in_index,d=Q.avail_in,E=e.bitb,f=e.bitk,S=(m=e.write)<e.read?e.read-m-1:e.end-m,C===0){n=0;break}n=7;case 7:if(e.write=m,h=e.inflate_flush(Q,h),S=(m=e.write)<e.read?e.read-m-1:e.end-m,e.read!=e.write)return e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);n=8;case 8:return h=1,e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);case 9:return h=-3,e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h);default:return h=-2,e.bitb=E,e.bitk=f,Q.avail_in=d,Q.total_in+=u-Q.next_in_index,Q.next_in_index=u,e.write=m,e.inflate_flush(Q,h)}},e.free=function(Q){e.reset(Q,null),e.window=null,B=null},e.set_dictionary=function(Q,h,l){e.window.set(Q.subarray(h,h+l),0),e.read=e.write=l},e.sync_point=function(){return n==1?1:0}}var g2=[0,0,255,255];function I2(){var i=this;function A(t){return t&&t.istate?(t.total_in=t.total_out=0,t.msg=null,t.istate.mode=7,t.istate.blocks.reset(t,null),0):-2}i.mode=0,i.method=0,i.was=[0],i.need=0,i.marker=0,i.wbits=0,i.inflateEnd=function(t){return i.blocks&&i.blocks.free(t),i.blocks=null,0},i.inflateInit=function(t,e){return t.msg=null,i.blocks=null,e<8||e>15?(i.inflateEnd(t),-2):(i.wbits=e,t.istate.blocks=new r2(t,1<<e),A(t),0)},i.inflate=function(t,e){var n,a;if(!t||!t.istate||!t.next_in)return-2;for(e=e==4?-5:0,n=-5;;)switch(t.istate.mode){case 0:if(t.avail_in===0)return n;if(n=e,t.avail_in--,t.total_in++,(15&(t.istate.method=t.read_byte(t.next_in_index++)))!=8){t.istate.mode=13,t.msg="unknown compression method",t.istate.marker=5;break}if(8+(t.istate.method>>4)>t.istate.wbits){t.istate.mode=13,t.msg="invalid window size",t.istate.marker=5;break}t.istate.mode=1;case 1:if(t.avail_in===0)return n;if(n=e,t.avail_in--,t.total_in++,a=255&t.read_byte(t.next_in_index++),((t.istate.method<<8)+a)%31!=0){t.istate.mode=13,t.msg="incorrect header check",t.istate.marker=5;break}if((32&a)==0){t.istate.mode=7;break}t.istate.mode=2;case 2:if(t.avail_in===0)return n;n=e,t.avail_in--,t.total_in++,t.istate.need=(255&t.read_byte(t.next_in_index++))<<24&4278190080,t.istate.mode=3;case 3:if(t.avail_in===0)return n;n=e,t.avail_in--,t.total_in++,t.istate.need+=(255&t.read_byte(t.next_in_index++))<<16&16711680,t.istate.mode=4;case 4:if(t.avail_in===0)return n;n=e,t.avail_in--,t.total_in++,t.istate.need+=(255&t.read_byte(t.next_in_index++))<<8&65280,t.istate.mode=5;case 5:return t.avail_in===0?n:(n=e,t.avail_in--,t.total_in++,t.istate.need+=255&t.read_byte(t.next_in_index++),t.istate.mode=6,2);case 6:return t.istate.mode=13,t.msg="need dictionary",t.istate.marker=0,-2;case 7:if((n=t.istate.blocks.proc(t,n))==-3){t.istate.mode=13,t.istate.marker=0;break}if(n==0&&(n=e),n!=1)return n;n=e,t.istate.blocks.reset(t,t.istate.was),t.istate.mode=12;case 12:return 1;case 13:return-3;default:return-2}},i.inflateSetDictionary=function(t,e,n){var a=0,o=n;return t&&t.istate&&t.istate.mode==6?(o>=1<<t.istate.wbits&&(a=n-(o=(1<<t.istate.wbits)-1)),t.istate.blocks.set_dictionary(e,a,o),t.istate.mode=7,0):-2},i.inflateSync=function(t){var e,n,a,o,s;if(!t||!t.istate)return-2;if(t.istate.mode!=13&&(t.istate.mode=13,t.istate.marker=0),(e=t.avail_in)===0)return-5;for(n=t.next_in_index,a=t.istate.marker;e!==0&&a<4;)t.read_byte(n)==g2[a]?a++:a=t.read_byte(n)!==0?0:4-a,n++,e--;return t.total_in+=n-t.next_in_index,t.next_in_index=n,t.avail_in=e,t.istate.marker=a,a!=4?-3:(o=t.total_in,s=t.total_out,A(t),t.total_in=o,t.total_out=s,t.istate.mode=7,0)},i.inflateSyncPoint=function(t){return t&&t.istate&&t.istate.blocks?t.istate.blocks.sync_point():-2}}function dQ(){}function fQ(){var i=new dQ,A=new Uint8Array(512),t=!1;i.inflateInit(),i.next_out=A,this.append=function(e,n){var a,o,s=[],I=0,r=0,g=0;if(e.length!==0){i.next_in_index=0,i.next_in=e,i.avail_in=e.length;do{if(i.next_out_index=0,i.avail_out=512,i.avail_in!==0||t||(i.next_in_index=0,t=!0),a=i.inflate(0),t&&a===-5){if(i.avail_in!==0)throw new Error("inflating: bad input")}else if(a!==0&&a!==1)throw new Error("inflating: "+i.msg);if((t||a===1)&&i.avail_in===e.length)throw new Error("inflating: bad input");i.next_out_index&&s.push(i.next_out_index===512?new Uint8Array(A):new Uint8Array(A.subarray(0,i.next_out_index))),g+=i.next_out_index,n&&i.next_in_index>0&&i.next_in_index!=I&&(n(i.next_in_index),I=i.next_in_index)}while(i.avail_in>0||i.avail_out===0);return o=new Uint8Array(g),s.forEach(function(C){o.set(C,r),r+=C.length}),o}},this.flush=function(){i.inflateEnd()}}dQ.prototype={inflateInit:function(i){var A=this;return A.istate=new I2,i||(i=15),A.istate.inflateInit(A,i)},inflate:function(i){var A=this;return A.istate?A.istate.inflate(A,i):-2},inflateEnd:function(){var i=this;if(!i.istate)return-2;var A=i.istate.inflateEnd(i);return i.istate=null,A},inflateSync:function(){var i=this;return i.istate?i.istate.inflateSync(i):-2},inflateSetDictionary:function(i,A){var t=this;return t.istate?t.istate.inflateSetDictionary(t,i,A):-2},read_byte:function(i){return this.next_in.subarray(i,i+1)[0]},read_buf:function(i,A){return this.next_in.subarray(i,i+A)}},self._zipjs_Inflater=fQ;var Tl,Fs="File format is not recognized.",dc="Error while reading zip file.";try{Tl=new Blob([new DataView(new ArrayBuffer(0))]).size===0}catch{}function ur(){this.crc=-1}function Al(){}function Vi(i,A){var t,e;return t=new ArrayBuffer(i),e=new Uint8Array(t),A&&e.set(A,0),{buffer:t,array:e,view:new DataView(t)}}function pr(){}function tl(i){var A,t=this;t.size=0,t.init=function(e,n){var a=new Blob([i],{type:"text/plain"});(A=new Gr(a)).init(function(){t.size=A.size,e()},n)},t.readUint8Array=function(e,n,a,o){A.readUint8Array(e,n,a,o)}}function el(i){var A,t=this;t.size=0,t.init=function(e){for(var n=i.length;i.charAt(n-1)=="=";)n--;A=i.indexOf(",")+1,t.size=Math.floor(.75*(n-A)),e()},t.readUint8Array=function(e,n,a){var o,s=Vi(n),I=4*Math.floor(e/3),r=4*Math.ceil((e+n)/3),g=self.atob(i.substring(I+A,r+A)),C=e-3*Math.floor(I/4);for(o=C;o<C+n;o++)s.array[o-C]=g.charCodeAt(o);a(s.array)}}function Gr(i){var A=this;A.size=0,A.init=function(t){A.size=i.size,t()},A.readUint8Array=function(t,e,n,a){var o=new FileReader;o.onload=function(s){n(new Uint8Array(s.target.result))},o.onerror=a;try{o.readAsArrayBuffer(function(s,I,r){if(I<0||r<0||I+r>s.size)throw new RangeError("offset:"+I+", length:"+r+", size:"+s.size);return s.slice?s.slice(I,I+r):s.webkitSlice?s.webkitSlice(I,I+r):s.mozSlice?s.mozSlice(I,I+r):s.msSlice?s.msSlice(I,I+r):void 0}(i,t,e))}catch(s){a(s)}}}function ks(){}function il(i){var A,t=this;t.init=function(e){A=new Blob([],{type:"text/plain"}),e()},t.writeUint8Array=function(e,n){A=new Blob([A,Tl?e:e.buffer],{type:"text/plain"}),n()},t.getData=function(e,n){var a=new FileReader;a.onload=function(o){e(o.target.result)},a.onerror=n,a.readAsText(A,i)}}function nl(i){var A=this,t="",e="";A.init=function(n){t+="data:"+(i||"")+";base64,",n()},A.writeUint8Array=function(n,a){var o,s=e.length,I=e;for(e="",o=0;o<3*Math.floor((s+n.length)/3)-s;o++)I+=String.fromCharCode(n[o]);for(;o<n.length;o++)e+=String.fromCharCode(n[o]);I.length>2?t+=self.btoa(I):e=I,a()},A.getData=function(n){n(t+self.btoa(e))}}function al(i){var A,t=this;t.init=function(e){A=new Blob([],{type:i}),e()},t.writeUint8Array=function(e,n){A=new Blob([A,Tl?e:e.buffer],{type:i}),n()},t.getData=function(e){e(A)}}function sl(i,A,t,e,n,a,o,s,I,r){var g,C,B,c=0,Q=A.sn;function h(){i.removeEventListener("message",l,!1),s(C,B)}function l(f){var u=f.data,d=u.data,m=u.error;if(m)return m.toString=function(){return"Error: "+this.message},void I(m);if(u.sn===Q)switch(typeof u.codecTime=="number"&&(i.codecTime+=u.codecTime),typeof u.crcTime=="number"&&(i.crcTime+=u.crcTime),u.type){case"append":d?(C+=d.length,e.writeUint8Array(d,function(){E()},r)):E();break;case"flush":B=u.crc,d?(C+=d.length,e.writeUint8Array(d,function(){h()},r)):h();break;case"progress":o&&o(g+u.loaded,a);break;case"importScripts":case"newTask":case"echo":break;default:console.warn("zip.js:launchWorkerProcess: unknown message: ",u)}}function E(){(g=524288*c)<=a?t.readUint8Array(n+g,Math.min(524288,a-g),function(f){o&&o(g,a);var u=g===0?A:{sn:Q};u.type="append",u.data=f;try{i.postMessage(u,[f.buffer])}catch{i.postMessage(u)}c++},I):i.postMessage({sn:Q,type:"flush"})}C=0,i.addEventListener("message",l,!1),E()}function ol(i,A,t,e,n,a,o,s,I,r){var g,C=0,B=0,c=a==="input",Q=a==="output",h=new ur;(function l(){var E;if((g=524288*C)<n)A.readUint8Array(e+g,Math.min(524288,n-g),function(f){var u;try{u=i.append(f,function(d){o&&o(g+d,n)})}catch(d){return void I(d)}u?(B+=u.length,t.writeUint8Array(u,function(){C++,setTimeout(l,1)},r),Q&&h.append(u)):(C++,setTimeout(l,1)),c&&h.append(f),o&&o(g,n)},I);else{try{E=i.flush()}catch(f){return void I(f)}E?(Q&&h.append(E),B+=E.length,t.writeUint8Array(E,function(){s(B,h.get())},r)):s(B,h.get())}})()}function fc(i,A,t,e,n,a,o,s,I,r,g){var C="input";Ct.useWebWorkers&&o?sl(i,{sn:A,codecClass:"_zipjs_NOOP",crcType:C},t,e,n,a,I,s,r,g):ol(new Al,t,e,n,a,C,I,s,r,g)}function uc(i){var A,t,e="",n=["\xC7","\xFC","\xE9","\xE2","\xE4","\xE0","\xE5","\xE7","\xEA","\xEB","\xE8","\xEF","\xEE","\xEC","\xC4","\xC5","\xC9","\xE6","\xC6","\xF4","\xF6","\xF2","\xFB","\xF9","\xFF","\xD6","\xDC","\xF8","\xA3","\xD8","\xD7","\u0192","\xE1","\xED","\xF3","\xFA","\xF1","\xD1","\xAA","\xBA","\xBF","\xAE","\xAC","\xBD","\xBC","\xA1","\xAB","\xBB","_","_","_","\xA6","\xA6","\xC1","\xC2","\xC0","\xA9","\xA6","\xA6","+","+","\xA2","\xA5","+","+","-","-","+","-","+","\xE3","\xC3","+","+","-","-","\xA6","-","+","\xA4","\xF0","\xD0","\xCA","\xCB","\xC8","i","\xCD","\xCE","\xCF","+","+","_","_","\xA6","\xCC","_","\xD3","\xDF","\xD4","\xD2","\xF5","\xD5","\xB5","\xFE","\xDE","\xDA","\xDB","\xD9","\xFD","\xDD","\xAF","\xB4","\xAD","\xB1","_","\xBE","\xB6","\xA7","\xF7","\xB8","\xB0","\xA8","\xB7","\xB9","\xB3","\xB2","_"," "];for(A=0;A<i.length;A++)e+=(t=255&i.charCodeAt(A))>127?n[t-128]:String.fromCharCode(t);return e}function pc(i){return decodeURIComponent(escape(i))}function mc(i){var A,t="";for(A=0;A<i.length;A++)t+=String.fromCharCode(i[A]);return t}function yc(i,A,t,e,n){i.version=A.view.getUint16(t,!0),i.bitFlag=A.view.getUint16(t+2,!0),i.compressionMethod=A.view.getUint16(t+4,!0),i.lastModDateRaw=A.view.getUint32(t+6,!0),i.lastModDate=function(a){var o=(4294901760&a)>>16,s=65535&a;try{return new Date(1980+((65024&o)>>9),((480&o)>>5)-1,31&o,(63488&s)>>11,(2016&s)>>5,2*(31&s),0)}catch{}}(i.lastModDateRaw),(1&i.bitFlag)!=1?((e||(8&i.bitFlag)!=8)&&(i.crc32=A.view.getUint32(t+10,!0),i.compressedSize=A.view.getUint32(t+14,!0),i.uncompressedSize=A.view.getUint32(t+18,!0)),i.compressedSize!==4294967295&&i.uncompressedSize!==4294967295?(i.filenameLength=A.view.getUint16(t+22,!0),i.extraFieldLength=A.view.getUint16(t+24,!0)):n("File is using Zip64 (4gb+ file size).")):n("File contains encrypted entry.")}function Dc(i){return unescape(encodeURIComponent(i))}function Sc(i){var A,t=[];for(A=0;A<i.length;A++)t.push(i.charCodeAt(A));return t}ur.prototype.append=function(i){for(var A=0|this.crc,t=this.table,e=0,n=0|i.length;e<n;e++)A=A>>>8^t[255&(A^i[e])];this.crc=A},ur.prototype.get=function(){return~this.crc},ur.prototype.table=function(){var i,A,t,e=[];for(i=0;i<256;i++){for(t=i,A=0;A<8;A++)1&t?t=t>>>1^3988292384:t>>>=1;e[i]=t}return e}(),Al.prototype.append=function(i,A){return i},Al.prototype.flush=function(){},(tl.prototype=new pr).constructor=tl,(el.prototype=new pr).constructor=el,(Gr.prototype=new pr).constructor=Gr,ks.prototype.getData=function(i){i(this.data)},(il.prototype=new ks).constructor=il,(nl.prototype=new ks).constructor=nl,(al.prototype=new ks).constructor=al;var l2={deflater:["z-worker.js","deflate.js"],inflater:["z-worker.js","inflate.js"]};function wc(i,A,t){if(Ct.workerScripts===null||Ct.workerScriptsPath===null){var e,n,a;if(Ct.workerScripts){if(e=Ct.workerScripts[i],!Array.isArray(e))return void t(new Error("zip.workerScripts."+i+" is not an array!"));n=e,a=document.createElement("a"),e=n.map(function(I){return a.href=I,a.href})}else(e=l2[i].slice(0))[0]=(Ct.workerScriptsPath||"")+e[0];var o=new Worker(e[0]);o.codecTime=o.crcTime=0,o.postMessage({type:"importScripts",scripts:e.slice(1)}),o.addEventListener("message",function I(r){var g=r.data;if(g.error)return o.terminate(),void t(g.error);g.type==="importScripts"&&(o.removeEventListener("message",I),o.removeEventListener("error",s),A(o))}),o.addEventListener("error",s)}else t(new Error("Either zip.workerScripts or zip.workerScriptsPath may be set, not both."));function s(I){o.terminate(),t(I)}}function _c(i){console.error(i)}const Ct={Reader:pr,Writer:ks,BlobReader:Gr,Data64URIReader:el,TextReader:tl,BlobWriter:al,Data64URIWriter:nl,TextWriter:il,createReader:function(i,A,t){i.init(function(){(function(e,n,a){var o=0;function s(){}s.prototype.getData=function(r,g,C,B){var c=this;function Q(E,f){B&&!function(u){var d=Vi(4);return d.view.setUint32(0,u),c.crc32==d.view.getUint32(0)}(f)?a("CRC failed."):r.getData(function(u){g(u)})}function h(E){a(E||"Error while reading file data.")}function l(E){a(E||"Error while writing file data.")}e.readUint8Array(c.offset,30,function(E){var f,u=Vi(E.length,E);u.view.getUint32(0)==1347093252?(yc(c,u,4,!1,a),f=c.offset+30+c.filenameLength+c.extraFieldLength,r.init(function(){c.compressionMethod===0?fc(c._worker,o++,e,r,f,c.compressedSize,B,Q,C,h,l):function(d,m,S,D,p,w,M,R,U,N,G){var T=M?"output":"none";Ct.useWebWorkers?sl(d,{sn:m,codecClass:"_zipjs_Inflater",crcType:T},S,D,p,w,U,R,N,G):ol(new fQ,S,D,p,w,T,U,R,N,G)}(c._worker,o++,e,r,f,c.compressedSize,B,Q,C,h,l)},l)):a(Fs)},h)};var I={getEntries:function(r){var g=this._worker;(function(C){function B(c,Q){e.readUint8Array(e.size-c,c,function(h){for(var l=h.length-22;l>=0;l--)if(h[l]===80&&h[l+1]===75&&h[l+2]===5&&h[l+3]===6)return void C(new DataView(h.buffer,l,22));Q()},function(){a(dc)})}e.size<22?a(Fs):B(22,function(){B(Math.min(65558,e.size),function(){a(Fs)})})})(function(C){var B,c;B=C.getUint32(16,!0),c=C.getUint16(8,!0),B<0||B>=e.size?a(Fs):e.readUint8Array(B,e.size-B,function(Q){var h,l,E,f,u=0,d=[],m=Vi(Q.length,Q);for(h=0;h<c;h++){if((l=new s)._worker=g,m.view.getUint32(u)!=1347092738)return void a(Fs);yc(l,m,u+6,!0,a),l.commentLength=m.view.getUint16(u+32,!0),l.directory=(16&m.view.getUint8(u+38))==16,l.offset=m.view.getUint32(u+42,!0),E=mc(m.array.subarray(u+46,u+46+l.filenameLength)),l.filename=(2048&l.bitFlag)==2048?pc(E):uc(E),l.directory||l.filename.charAt(l.filename.length-1)!="/"||(l.directory=!0),f=mc(m.array.subarray(u+46+l.filenameLength+l.extraFieldLength,u+46+l.filenameLength+l.extraFieldLength+l.commentLength)),l.comment=(2048&l.bitFlag)==2048?pc(f):uc(f),d.push(l),u+=46+l.filenameLength+l.extraFieldLength+l.commentLength}r(d)},function(){a(dc)})})},close:function(r){this._worker&&(this._worker.terminate(),this._worker=null),r&&r()},_worker:null};Ct.useWebWorkers?wc("inflater",function(r){I._worker=r,n(I)},function(r){a(r)}):n(I)})(i,A,t)},t=t||_c)},createWriter:function(i,A,t,e){e=!!e,i.init(function(){(function(n,a,o,s){var I={},r=[],g=0,C=0;function B(h){o(h||"Error while writing zip file.")}function c(h){o(h||"Error while reading file data.")}var Q={add:function(h,l,E,f,u){var d,m,S,D=this._worker;function p(M,R){var U=Vi(16);g+=M||0,U.view.setUint32(0,1347094280),R!==void 0&&(d.view.setUint32(10,R,!0),U.view.setUint32(4,R,!0)),l&&(U.view.setUint32(8,M,!0),d.view.setUint32(14,M,!0),U.view.setUint32(12,l.size,!0),d.view.setUint32(18,l.size,!0)),n.writeUint8Array(U.array,function(){g+=16,E()},B)}function w(){var M;u=u||{},h=h.trim(),u.directory&&h.charAt(h.length-1)!="/"&&(h+="/"),I.hasOwnProperty(h)?o("File already exists."):(m=Sc(Dc(h)),r.push(h),S=u.lastModDate||new Date,d=Vi(26),I[h]={headerArray:d.array,directory:u.directory,filename:m,offset:g,comment:Sc(Dc(u.comment||""))},d.view.setUint32(0,335546376),u.version&&d.view.setUint8(0,u.version),s||u.level===0||u.directory||d.view.setUint16(4,2048),d.view.setUint16(6,(S.getHours()<<6|S.getMinutes())<<5|S.getSeconds()/2,!0),d.view.setUint16(8,(S.getFullYear()-1980<<4|S.getMonth()+1)<<5|S.getDate(),!0),d.view.setUint16(22,m.length,!0),(M=Vi(30+m.length)).view.setUint32(0,1347093252),M.array.set(d.array,4),M.array.set(m,30),g+=M.array.length,n.writeUint8Array(M.array,function(){l?s||u.level===0?fc(D,C++,l,n,0,l.size,!0,p,f,c,B):function(R,U,N,G,T,V,tA,z,W){var Y="input";Ct.useWebWorkers?sl(R,{sn:U,options:{level:T},codecClass:"_zipjs_Deflater",crcType:Y},N,G,0,N.size,tA,V,z,W):ol(new QQ,N,G,0,N.size,Y,tA,V,z,W)}(D,C++,l,n,u.level,p,f,c,B):p()},B))}l?l.init(w,c):w()},close:function(h){this._worker&&(this._worker.terminate(),this._worker=null);var l,E,f,u=0,d=0;for(E=0;E<r.length;E++)u+=46+(f=I[r[E]]).filename.length+f.comment.length;for(l=Vi(u+22),E=0;E<r.length;E++)f=I[r[E]],l.view.setUint32(d,1347092738),l.view.setUint16(d+4,5120),l.array.set(f.headerArray,d+6),l.view.setUint16(d+32,f.comment.length,!0),f.directory&&l.view.setUint8(d+38,16),l.view.setUint32(d+42,f.offset,!0),l.array.set(f.filename,d+46),l.array.set(f.comment,d+46+f.filename.length),d+=46+f.filename.length+f.comment.length;l.view.setUint32(d,1347093766),l.view.setUint16(d+8,r.length,!0),l.view.setUint16(d+10,r.length,!0),l.view.setUint32(d+12,u,!0),l.view.setUint32(d+16,g,!0),n.writeUint8Array(l.array,function(){n.getData(h)},B)},_worker:null};Ct.useWebWorkers?wc("deflater",function(h){Q._worker=h,a(Q)},function(h){o(h)}):a(Q)})(i,A,t,e)},t=t||_c)},useWebWorkers:!0,workerScriptsPath:null,workerScripts:null};var La,Tt,_I=Ct.TextWriter,mr=Ct.BlobWriter,xI=Ct.Data64URIWriter,xc=Ct.TextReader,rl=Ct.BlobReader,Mc=Ct.Data64URIReader,C2=Ct.createReader,B2=Ct.createWriter;function Cr(i){var A,t=this;t.size=0,t.init=function(e){t.size=i.uncompressedSize,e()},t.readUint8Array=function(e,n,a,o){(function(s){t.data?s():i.getData(new mr,function(I){t.data=I,A=new rl(I),s()},null,t.checkCrc32)})(function(){A.readUint8Array(e,n,a,o)})}}function Fc(i){var A=0;return function t(e){A+=e.uncompressedSize||0,e.children.forEach(t)}(i),A}function gl(i,A,t){var e=0;function n(){++e<i.children.length?a(i.children[e]):A()}function a(o){o.directory?gl(o,n,t):(o.reader=new o.Reader(o.data,t),o.reader.init(function(){o.uncompressedSize=o.reader.size,n()}))}i.children.length?a(i.children[e]):A()}function Rc(i){var A=i.parent.children;A.forEach(function(t,e){t.id==i.id&&A.splice(e,1)})}function yr(i){i.entries=[],i.root=new Xa(i)}function ba(i,A,t,e){if(i.directory)return e?new Xa(i.fs,A,t,i):new Nr(i.fs,A,t,i);throw"Parent entry is not a directory."}function Pa(){}function Nr(i,A,t,e){var n=this;Pa.prototype.init.call(n,i,A,t,e),n.Reader=t.Reader,n.Writer=t.Writer,n.data=t.data,t.getData&&(n.getData=t.getData)}function Xa(i,A,t,e){Pa.prototype.init.call(this,i,A,t,e),this.directory=!0}function uQ(){yr(this)}(Cr.prototype=new Ct.Reader).constructor=Cr,Cr.prototype.checkCrc32=!1,(Pa.prototype={init:function(i,A,t,e){var n=this;if(i.root&&e&&e.getChildByName(A))throw"Entry filename already exists.";t||(t={}),n.fs=i,n.name=A,n.id=i.entries.length,n.parent=e,n.children=[],n.zipVersion=t.zipVersion||20,n.uncompressedSize=0,i.entries.push(n),e&&n.parent.children.push(n)},getFileEntry:function(i,A,t,e,n){var a=this;gl(a,function(){(function(o,s,I,r,g,C,B){var c=0;s.directory?function Q(h,l,E,f,u,d){var m=0;(function S(){var D=l.children[m];D?function(p){function w(M){c+=p.uncompressedSize||0,Q(M,p,function(){m++,S()},f,u,d)}p.directory?h.getDirectory(p.name,{create:!0},w,u):h.getFile(p.name,{create:!0},function(M){p.getData(new Ct.FileWriter(M,Ct.getMimeType(p.name)),w,function(R){f&&f(c+R,d)},B)},u)}(D):E()})()}(o,s,I,r,g,C):s.getData(new Ct.FileWriter(o,Ct.getMimeType(s.name)),I,r,B)})(i,a,A,t,e,Fc(a),n)},e)},moveTo:function(i){var A=this;if(!i.directory)throw"Target entry is not a directory.";if(i.isDescendantOf(A))throw"Entry is a ancestor of target entry.";if(A!=i){if(i.getChildByName(A.name))throw"Entry filename already exists.";Rc(A),A.parent=i,i.children.push(A)}},getFullname:function(){for(var i=this.name,A=this.parent;A;)i=(A.name?A.name+"/":"")+i,A=A.parent;return i},isDescendantOf:function(i){for(var A=this.parent;A&&A.id!=i.id;)A=A.parent;return!!A}}).constructor=Pa,Nr.prototype=La=new Pa,La.constructor=Nr,La.getData=function(i,A,t,e){var n=this;!i||i.constructor==n.Writer&&n.data?A(n.data):(n.reader||(n.reader=new n.Reader(n.data,e)),n.reader.init(function(){i.init(function(){(function(a,o,s,I,r){var g=0;(function C(){var B=524288*g;I&&I(B,a.size),B<a.size?a.readUint8Array(B,Math.min(524288,a.size-B),function(c){o.writeUint8Array(new Uint8Array(c),function(){g++,C()})},r):o.getData(s)})()})(n.reader,i,A,t,e)},e)}))},La.getText=function(i,A,t,e){this.getData(new _I(e),i,A,t)},La.getBlob=function(i,A,t,e){this.getData(new mr(i),A,t,e)},La.getData64URI=function(i,A,t,e){this.getData(new xI(i),A,t,e)},Xa.prototype=Tt=new Pa,Tt.constructor=Xa,Tt.addDirectory=function(i){return ba(this,i,null,!0)},Tt.addText=function(i,A){return ba(this,i,{data:A,Reader:xc,Writer:_I})},Tt.addBlob=function(i,A){return ba(this,i,{data:A,Reader:rl,Writer:mr})},Tt.addData64URI=function(i,A){return ba(this,i,{data:A,Reader:Mc,Writer:xI})},Tt.addFileEntry=function(i,A,t){(function(e,n,a,o){n.isDirectory?function s(I,r,g){(function(C,B){C.isDirectory&&C.createReader().readEntries(B),C.isFile&&B([])})(r,function(C){var B=0;(function c(){var Q=C[B];Q?function(h){function l(E){s(E,h,function(){B++,c()})}h.isDirectory&&l(I.addDirectory(h.name)),h.isFile&&h.file(function(E){var f=I.addBlob(h.name,E);f.uncompressedSize=E.size,l(f)},o)}(Q):g()})()})}(e,n,a):n.file(function(s){e.addBlob(n.name,s),a()},o)})(this,i,A,t)},Tt.addData=function(i,A){return ba(this,i,A)},Tt.importBlob=function(i,A,t){this.importZip(new rl(i),A,t)},Tt.importText=function(i,A,t){this.importZip(new xc(i),A,t)},Tt.importData64URI=function(i,A,t){this.importZip(new Mc(i),A,t)},Tt.exportBlob=function(i,A,t){this.exportZip(new mr("application/zip"),i,A,t)},Tt.exportText=function(i,A,t){this.exportZip(new _I,i,A,t)},Tt.exportFileEntry=function(i,A,t,e){this.exportZip(new Ct.FileWriter(i,"application/zip"),A,t,e)},Tt.exportData64URI=function(i,A,t){this.exportZip(new xI("application/zip"),i,A,t)},Tt.importZip=function(i,A,t){var e=this;C2(i,function(n){n.getEntries(function(a){a.forEach(function(o){var s=e,I=o.filename.split("/"),r=I.pop();I.forEach(function(g){s=s.getChildByName(g)||new Xa(e.fs,g,null,s)}),o.directory||ba(s,r,{data:o,Reader:Cr})}),A()})},t)},Tt.exportZip=function(i,A,t,e){var n=this;gl(n,function(){B2(i,function(a){(function(o,s,I,r,g){var C=0;(function B(c,Q,h,l,E){var f=0;(function u(){var d=Q.children[f];d?c.add(d.getFullname(),d.reader,function(){C+=d.uncompressedSize||0,B(c,d,function(){f++,u()},l,E)},function(m){l&&l(C+m,E)},{directory:d.directory,version:d.zipVersion}):h()})()})(o,s,I,r,g)})(a,n,function(){a.close(A)},t,Fc(n))},e)},e)},Tt.getChildByName=function(i){var A,t;for(A=0;A<this.children.length;A++)if((t=this.children[A]).name==i)return t},uQ.prototype={remove:function(i){Rc(i),this.entries[i.id]=null},find:function(i){var A,t=i.split("/"),e=this.root;for(A=0;e&&A<t.length;A++)e=e.getChildByName(t[A]);return e},getById:function(i){return this.entries[i]},importBlob:function(i,A,t){yr(this),this.root.importBlob(i,A,t)},importText:function(i,A,t){yr(this),this.root.importText(i,A,t)},importData64URI:function(i,A,t){yr(this),this.root.importData64URI(i,A,t)},exportBlob:function(i,A,t){this.root.exportBlob(i,A,t)},exportText:function(i,A,t){this.root.exportText(i,A,t)},exportFileEntry:function(i,A,t,e){this.root.exportFileEntry(i,A,t,e)},exportData64URI:function(i,A,t){this.root.exportData64URI(i,A,t)}},Ct.getMimeType=function(){return"application/octet-stream"};var h2={FS:uQ,ZipDirectoryEntry:Xa,ZipFileEntry:Nr};Ct.useWebWorkers=!1;var c2=function(){function i(t,e){this.el=t,this.inputEl=e,this.listeners={drop:[],dropstart:[],droperror:[]},this._onDragover=this._onDragover.bind(this),this._onDrop=this._onDrop.bind(this),this._onSelect=this._onSelect.bind(this),t.addEventListener("dragover",this._onDragover,!1),t.addEventListener("drop",this._onDrop,!1),e.addEventListener("change",this._onSelect)}var A=i.prototype;return A.on=function(t,e){return this.listeners[t].push(e),this},A._emit=function(t,e){return this.listeners[t].forEach(function(n){return n(e)}),this},A.destroy=function(){var t=this.el,e=this.inputEl;t.removeEventListener("dragover",this._onDragover,!1),t.removeEventListener("drop",this._onDrop,!1),e.removeEventListener("change",this._onSelect),delete this.el,delete this.inputEl,delete this.listeners},A._onDrop=function(t){t.stopPropagation(),t.preventDefault(),this._emit("dropstart");var e=Array.from(t.dataTransfer.files||[]),n=Array.from(t.dataTransfer.items||[]);if(e.length!==0||n.length!==0)if(n.length>0){var a=n.map(function(o){return o.webkitGetAsEntry()});a[0].name.match(/\.zip$/)?this._loadZip(n[0].getAsFile()):this._loadNextEntry(new Map,a)}else e.length===1&&e[0].name.match(/\.zip$/)&&this._loadZip(e[0]),this._emit("drop",{files:new Map(e.map(function(o){return[o.name,o]}))});else this._fail("Required drag-and-drop APIs are not supported in this browser.")},A._onDragover=function(t){t.stopPropagation(),t.preventDefault(),t.dataTransfer.dropEffect="copy"},A._onSelect=function(t){this._emit("dropstart");var e=[].slice.call(this.inputEl.files);if(e.length===1&&this._isZip(e[0]))this._loadZip(e[0]);else{var n=new Map;e.forEach(function(a){return n.set(a.webkitRelativePath||a.name,a)}),this._emit("drop",{files:n})}},A._loadNextEntry=function(t,e){var n=this,a=e.pop();if(a)if(a.isFile)a.file(function(s){t.set(a.fullPath,s),n._loadNextEntry(t,e)},function(){return console.error("Could not load file: %s",a.fullPath)});else if(a.isDirectory){var o=a.createReader();o.readEntries(function s(I){I.length?(e=e.concat(I),o.readEntries(s)):n._loadNextEntry(t,e)})}else console.warn("Unknown asset type: "+a.fullPath),this._loadNextEntry(t,e);else this._emit("drop",{files:t})},A._loadZip=function(t){var e=this,n=[],a=new Map,o=new h2.FS,s=function I(r){r.directory?r.children.forEach(I):r.name[0]!=="."&&n.push(new Promise(function(g){r.getData(new Ct.BlobWriter,function(C){C.name=r.name,a.set(r.getFullname(),C),g()})}))};o.importBlob(t,function(){s(o.root),Promise.all(n).then(function(){e._emit("drop",{files:a,archive:t})})})},A._isZip=function(t){return t.type==="application/zip"||t.name.match(/\.zip$/)},A._fail=function(t){this._emit("droperror",{message:t})},i}();let gt,Il;const Hl=new c2(jn,document.createElement("input"));jn.innerHTML="[Drop .VDB / .ZIP here]";Hl.on("drop",({files:i})=>{let A=[...i];const t=A[0][0],e=URL.createObjectURL(A[0][1]);jn.innerHTML="[Loaded! Parsing...]",kl(t,e).then(n=>{var I;jn.innerHTML="[Drop .VDB / .ZIP here]",gt=new bl(n,{resolution:200,steps:1e3,baseColor:16777215,absorbance:1,progressive:!0,emissiveGrid:(I=n.grids)==null?void 0:I.temperature});const a=n.grids[Object.keys(n.grids)[0]],o=new ln;o.set(...a.getPreciseWorldBbox());const s=new rA;o.getSize(s).multiplyScalar(.5),gt.position.y-=s.y,Il&&Il.add(gt)})});Hl.on("dropstart",()=>{gt&&(gt.parent&&gt.parent.remove(gt),gt.geometry.dispose(),gt.materials.forEach(i=>{i.densityMap3D.dispose(),i.emissiveMap3D&&i.emissiveMap3D.dispose()}),gt.dispose(),gt=null),jn.innerHTML="[Loading VDB file - please wait...]"});Hl.on("droperror",({message:i})=>{jn.innerHTML="[Error - please try again]",console.error({message:i})});const pQ=({scene:i})=>{Il=i;const A=new wt(new Be(20,32,32),new bI({color:16777215}));i.add(A);const t=new wt(new Be(20,32,32),new UI({color:16777215}));t.position.set(-200,0,200),i.add(t);const e=(f,u,d,m)=>{const S=new Zi,D=new eE(f,.5);return D.position.set(u,d,m),D.add(new wt(new Be(1,32,32),new nn({color:f}))),S.add(D),i.add(S),[D,S]},n=(f,u,d,m)=>{const S=new Zi,D=new tE(f,.5,null,.2,.6);return D.position.set(u,d,m),D.add(new wt(new Be(1,32,32),new nn({color:f}))),S.add(D),i.add(S),[D,S]},a=(f,u,d,m)=>{const S=new ul(f,.5);S.position.set(u,d,m);const D=new wt(new Be(1,32,32),new nn({color:f}));return D.position.set(u,d,m),i.add(S),i.add(D),[S,D]},[o,s]=n(16711935,50,80,0),[I]=n(16711680,0,80,0),[r,g]=e(16711935,50,80,0),[C]=e(16711680,0,80,0),[B,c]=e(16777096,0,0,0);t.add(c);const[Q]=e(16711935,0,-10,0);Q.children=[];const[h,l]=a(16711680,0,0,-80),E=new AE(16711680,255,1);i.add(E),setInterval(()=>{s.rotateY(.005),g.rotateX(.005)},1),Or([{folder:"Scene",children:[{id:"showMesh",name:"Show Debug Mesh",defaultValue:!1,onChange:f=>{gt&&(gt.visible=!f),A.visible=!!f}},{id:"backgroundColor",name:"Background Color",defaultValue:"#598eff",onChange:f=>{i.background.set(f)}},{id:"lightSetup",name:"Lights",defaultValue:"hemi",options:{"Hemisphere Light":"hemi","Spot Lights":"spot","Point Lights":"point","Directional Light":"dir",Sun:"sun",Glow:"glow",None:"none"},onChange:f=>{r.visible=f==="point",C.visible=f==="point",o.visible=f==="spot",I.visible=f==="spot",h.visible=f==="dir",E.visible=f==="dir",E.visible=f==="hemi",B.visible=f==="sun",Q.visible=f==="glow"}},{id:"lightColor",name:"Light Color",defaultValue:"#ff00ff",onChange:f=>{o.color.set(f),o.children[0].material.color.set(f),h.color.set(f),l.material.color.set(f),r.color.set(f),r.children[0].material.color.set(f),Q.color.set(f)}},{id:"lightIntensity",name:"Light Intensity",defaultValue:1,min:0,max:1,onChange:f=>{o.intensity=f,I.intensity=f,h.intensity=f,E.intensity=f,r.intensity=f,C.intensity=f,Q.intensity=f}}]},{folder:"Fog Volume",children:[{id:"wrap3D",name:"3D Wrapping",defaultValue:Tn,options:{"Three.ClampToEdgeWrapping":se,"Three.RepeatWrapping":Ks,"Three.MirroredRepeatWrapping":Tn},onChange:f=>{!gt||(gt.material.wrap3D=f)}},{id:"fogColor",name:"Fog Color",defaultValue:"#ffffff",onChange:f=>{gt&&gt.materials.forEach(u=>u.baseColor=f),A.material.color.set(f)}},{id:"scatterColor",name:"Scatter Color",defaultValue:"#000000",onChange:f=>{gt&&gt.materials.forEach(u=>u.scatterColor=f)}},{id:"absorbance",name:"Absorbance",defaultValue:.98,min:0,max:1,onChange:f=>{gt&&gt.materials.forEach(u=>u.absorbance=f)}},{id:"densityScale",name:"Density Scale",defaultValue:1,min:0,max:1,onChange:f=>{gt&&gt.materials.forEach(u=>u.densityScale=f)}},{id:"noise",name:"Noise",defaultValue:.5,min:0,max:1,onChange:f=>{gt&&gt.materials.forEach(u=>u.noiseScale=f)}},{id:"opacity",name:"Opacity",defaultValue:1,min:0,max:1,onChange:f=>{gt&&gt.materials.forEach(u=>u.opacity=f)}},{id:"steps",name:"Steps",defaultValue:400,min:10,max:1e3,onChange:f=>{gt&&gt.materials.forEach(u=>u.steps=f)}}]}])},E2="openvdb",Q2="0.2.14",d2="This project indirectly ports OpenVDB file format and tools to JavaScript, TypeScript, and Node. Specific 3D library implementations can be found in sub-directories.",f2="./index.js",u2={".":"./index.js","./three":"./three/index.js"},p2={three:"src/three"},m2=["openvdb","vdb","threejs","babylonjs","webgl","houdini","fluid"],y2={build:"rollup --config ./rollup.config.js && cd build && npm pack","build:examples":"cd examples && npm run build",dev:"cd examples && npm run dev",publish:"npm run build && cd ./build && npm publish"},D2={name:"mjurczyk",url:"https://discourse.threejs.org/u/mjurczyk"},S2=[{name:"mjurczyk",url:"https://discourse.threejs.org/u/mjurczyk"},{name:"notchris",url:"https://discourse.threejs.org/u/notchris"}],w2="MIT",_2={three:"^0.150.0"},x2={"@lopatnov/rollup-plugin-uglify":"^2.1.5","@rollup/plugin-node-resolve":"^14.1.0",rollup:"^2.79.1","rollup-plugin-copy":"^3.4.0","rollup-plugin-delete":"^2.0.0","rollup-plugin-peer-deps-external":"^2.2.4","stats.js":"^0.17.0"},M2={name:E2,version:Q2,description:d2,main:f2,exports:u2,directories:p2,keywords:m2,scripts:y2,author:D2,contributors:S2,license:w2,peerDependencies:_2,devDependencies:x2},Ts=new le(60,window.innerWidth/window.innerHeight,.01,1e4),_i=new um,wn=new $c({antialias:!0});document.querySelector(".package-version").innerHTML=`v${M2.version}`;const ll=new Um;document.body.appendChild(ll.dom);const F2=()=>{Ts.position.set(-100,80,80),_i.background=new st(5869311),wn.outputEncoding=ut,wn.setSize(window.innerWidth,window.innerHeight),wn.shadowMap.enabled=!0,new Lm(Ts,wn.domElement),document.body.appendChild(wn.domElement),window.addEventListener("resize",()=>{Ts.aspect=window.innerWidth/window.innerHeight,Ts.updateProjectionMatrix(),wn.setSize(window.innerWidth,window.innerHeight)})},mQ=()=>{requestAnimationFrame(mQ),ll.begin(),wn.render(_i,Ts),ll.end()};F2();mQ();pQ({scene:_i});
